

===== FILE: project_dump.js =====

const fs = require("fs");
const path = require("path");

// folders we should ignore
const ignoreDirs = ["node_modules", ".git", "dist", "build", ".next", ".turbo", "out", "coverage", "logs", "public"];

// only include code/config files
const allowedExtensions = [
  ".js", ".ts", ".tsx", ".jsx", ".json",
  ".md", ".css", ".scss", ".html", ".env", ".example"
];

function dumpProject(dir, outputFile) {
  const out = fs.createWriteStream(outputFile, { encoding: "utf-8" });

  function walk(currentPath) {
    const entries = fs.readdirSync(currentPath, { withFileTypes: true });

    for (const entry of entries) {
      if (ignoreDirs.includes(entry.name)) continue;

      const fullPath = path.join(currentPath, entry.name);

      if (entry.isDirectory()) {
        walk(fullPath);
      } else {
        const ext = path.extname(entry.name).toLowerCase();
        if (!allowedExtensions.includes(ext)) continue;

        const relPath = path.relative(dir, fullPath);
        try {
          const content = fs.readFileSync(fullPath, "utf-8");
          out.write(`\n\n===== FILE: ${relPath} =====\n\n`);
          out.write(content);
        } catch {
          out.write(`\n\n===== FILE: ${relPath} (SKIPPED - unreadable) =====\n\n`);
        }
      }
    }
  }

  walk(dir);
  out.end();
}

dumpProject(process.cwd(), "project_dump.txt");

===== FILE: sliptail-backend\controllers\authController.js =====

const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const { createUser, findUserByEmail } = require("../models/User");

const signup = async (req, res) => {
  const { email, password, role } = req.body;
  try {
    const existing = await findUserByEmail(email);
    if (existing) return res.status(400).json({ error: "Email already registered" });

    const passwordHash = await bcrypt.hash(password, 10);
    const user = await createUser({ email, passwordHash, role });

    const token = jwt.sign({ userId: user.id, role: user.role }, process.env.JWT_SECRET);
    res.status(201).json({ user, token });
  } catch (err) {
    console.error("Signup error:", err);
    res.status(500).json({ error: "Signup failed" });
  }
};

const login = async (req, res) => {
  const { email, password } = req.body;
  try {
    const user = await findUserByEmail(email);
    if (!user) return res.status(400).json({ error: "Invalid email or password" });

    const isMatch = await bcrypt.compare(password, user.password_hash);
    if (!isMatch) return res.status(400).json({ error: "Invalid email or password" });

    const token = jwt.sign({ userId: user.id, role: user.role }, process.env.JWT_SECRET);
    res.json({ user, token });
  } catch (err) {
    res.status(500).json({ error: "Login failed" });
  }
};

module.exports = { signup, login };

===== FILE: sliptail-backend\db\index.js =====

const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  port: process.env.DB_PORT,
});

module.exports = pool;

===== FILE: sliptail-backend\index.js =====

const express = require('express');
const cors = require('cors');
const cookieParser = require('cookie-parser');              // <-- add
require("dotenv").config();
const db = require('./db');

const authRoutes = require('./routes/auth');
const checkoutRoutes = require('./routes/checkout');
const stripeRoutes = require('./routes/stripe');
const productRoutes = require('./routes/products');
const orderRoutes = require("./routes/orders");
const downloadRoutes = require("./routes/downloads");
const requestRoutes = require("./routes/requests");
const creatorDashboardRoutes = require("./routes/creatorDashboard");
const membershipRoutes = require("./routes/memberships");
const postRoutes = require("./routes/posts");
const creatorRoutes = require("./routes/creators");
const categoryRoutes = require("./routes/categories");
const homeRoutes = require("./routes/home");
const reviewRoutes = require("./routes/reviews");
const emailRoutes = require("./routes/email");
const settingsRoutes = require("./routes/settings");
const notificationRoutes = require("./routes/notifications");
const adminRoutes = require("./routes/admin");
const stripeConnectRoutes = require("./routes/stripeConnect");
const stripeCheckoutRoutes = require("./routes/stripeCheckout");
const stripeWebhook = require("./routes/stripeWebhook");
const meRoutes = require('./routes/me'); 
const FRONTEND = (process.env.FRONTEND_URL || "http://localhost:3000").replace(/\/$/, "");    
const path = require("path");               // <-- creator-status etc.

const passport = require("passport");
const cron = require("node-cron");
const { notifyMembershipsExpiring } = require("./utils/notify");
const { notFound, errorHandler } = require("./middleware/error");

const app = express();

// If deploying behind a proxy/load balancer (Railway/Render/Heroku/Nginx/Cloudflare)
app.set('trust proxy', 1); // so secure cookies work

// Webhook MUST come before json parser (raw body)
app.post("/api/stripe/webhook", express.raw({ type: "application/json" }), stripeWebhook);

// CORS: allow your frontend origin + credentials for cookies
app.use(cors({
  origin: FRONTEND,
  credentials: true,
    methods: ["GET","POST","PUT","PATCH","DELETE","OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization"], // <-- allow Bearer header
}));

app.use(cookieParser());                                    // <-- add
app.use(express.json({ limit: "25mb" }));

// Auth + OAuth
app.use(passport.initialize());
app.use('/api/auth', authRoutes);
app.use("/api/auth", require("./routes/authGoogle"));       // ok to share base path

// API routes
app.use('/api/stripe', stripeRoutes);
app.use('/api/products', productRoutes);
app.use("/api/orders", orderRoutes);
app.use("/api/downloads", downloadRoutes);
app.use("/api/requests", requestRoutes);
app.use("/api/creator/dashboard", creatorDashboardRoutes);
app.use("/api/memberships", membershipRoutes);
app.use("/api/posts", postRoutes);
app.use("/api/creators", creatorRoutes);
app.use("/api/creator", require("./routes/creator"));
app.use("/api/categories", categoryRoutes);
app.use("/api/home", homeRoutes);
app.use("/api/reviews", reviewRoutes);
app.use("/api/email", emailRoutes);
app.use("/api/settings", settingsRoutes);
app.use("/api/notifications", notificationRoutes);
app.use("/api/admin", adminRoutes);
app.use("/api/stripe-connect", stripeConnectRoutes);
app.use("/api/stripe-checkout", stripeCheckoutRoutes);
app.use("/uploads", express.static(path.join(__dirname, "public", "uploads")));
app.use("/api/checkout", checkoutRoutes);

// Mount /api/me BEFORE notFound/errorHandler
app.use('/api/me', meRoutes);                               // <-- move up

// Health + test
app.get('/api/health', (req, res) => res.json({ message: '✅ Server is running!' }));
app.get('/test-db', async (req, res) => {
  try {
    const result = await db.query('SELECT NOW()');
    res.json({ now: result.rows[0].now });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// 404 + error handlers LAST
app.use(notFound);
app.use(errorHandler);

// Cron (optional)
if (process.env.CRON_ENABLED === "true") {
  cron.schedule("0 9 * * *", async () => {
    try {
      await notifyMembershipsExpiring({ days: 3 });
      console.log("Membership-expiring emails sent.");
    } catch (e) {
      console.error("Cron job failed:", e);
    }
  }, { timezone: process.env.CRON_TZ || "America/Chicago" });
}

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`API listening on http://localhost:${PORT}`);
});

===== FILE: sliptail-backend\middleware\auth.js =====

const jwt = require("jsonwebtoken");
const db = require("../db");

function clearAuthCookie(res) {
  if (res.clearCookie) {
    try {
      res.clearCookie("token", { httpOnly: true, sameSite: "lax", secure: true, path: "/" });
    } catch {}
  }
}

async function requireAuth(req, res, next) {
  try {
    let token = null;

    // 1) Bearer token preferred
    const h = req.headers.authorization || "";
    if (h.startsWith("Bearer ")) token = h.slice(7);

    // 2) Fallback: cookie
    if (!token && req.cookies?.token) token = req.cookies.token;

    if (!token) {
      clearAuthCookie(res);
      console.warn("requireAuth: NO TOKEN — headers.authorization:", req.headers.authorization);
      return res.status(401).json({ error: "Unauthorized (no token)" });
    }

    // 3) Verify signature
    const payload = jwt.verify(token, process.env.JWT_SECRET);
    const userId = payload.id;

    // 4) SOURCE OF TRUTH: ensure user still exists & is active
    const { rows } = await db.query(
      `SELECT id, email, role, email_verified_at, is_active
         FROM users
        WHERE id = $1
        LIMIT 1`,
      [userId]
    );
    const u = rows[0];

    if (!u) {
      clearAuthCookie(res);
      return res.status(401).json({ error: "Session invalid" });
    }
    if (u.is_active === false) {
      clearAuthCookie(res);
      return res.status(401).json({ error: "Account inactive" });
    }

    // 5) Attach fresh DB-backed user (✅ normalize role to lowercase)
    req.user = {
      id: u.id,
      email: u.email,
      role: String(u.role || "user").toLowerCase(), // <— key change
      email_verified_at: u.email_verified_at || null,
    };

    return next();
  } catch (e) {
    clearAuthCookie(res);
    return res.status(401).json({ error: "Unauthorized" });
  }
}

// ✅ Only creators
function requireCreator(req, res, next) {
  if (!req.user) return res.status(401).json({ error: "Not authenticated" });
  if (String(req.user.role).toLowerCase() !== "creator")
    return res.status(403).json({ error: "Creator access only" });
  next();
}

// ✅ Only admins
function requireAdmin(req, res, next) {
  if (!req.user) return res.status(401).json({ error: "Not authenticated" });
  if (String(req.user.role).toLowerCase() !== "admin")
    return res.status(403).json({ error: "Admin access only" });
  next();
}

module.exports = { requireAuth, requireCreator, requireAdmin };

===== FILE: sliptail-backend\middleware\error.js =====

class ApiError extends Error {
  constructor(status = 500, message = "Internal server error", details = null) {
    super(message);
    this.status = status;
    this.details = details;
    // mark safe-to-show messages for 4xx; hide 5xx by default
    this.expose = status >= 400 && status < 500;
  }
}

const createError = (status, message, details) => new ApiError(status, message, details);

// If no route matched
const notFound = (req, res, next) => {
  next(createError(404, "Not found"));
};

// Centralized error responder
const errorHandler = (err, req, res, next) => {
  const status = err.status && Number.isInteger(err.status) ? err.status : 500;

  // For 5xx, don’t leak internals in production
  const safeMessage =
    status >= 500 && process.env.NODE_ENV === "production"
      ? "Internal server error"
      : err.message || "Error";

  const payload = { error: safeMessage };

  if (err.details) payload.details = err.details;

  // Include stack only outside production
  if (process.env.NODE_ENV !== "production" && err.stack) {
    payload.stack = err.stack;
  }

  // Optional: quick request tracing
  // payload.requestId = req.headers["x-request-id"];

  res.status(status).json(payload);
};

// Optional helper: wrap async route handlers to auto-forward errors
const asyncHandler = (fn) => (req, res, next) =>
  Promise.resolve(fn(req, res, next)).catch(next);

module.exports = {
  ApiError,
  createError,
  notFound,
  errorHandler,
  asyncHandler,
};

===== FILE: sliptail-backend\middleware\rateLimit.js =====

// middleware/rateLimit.js
const rateLimit = require("express-rate-limit");

/**
 * Generic limiter: 300 requests / 15 minutes (per IP)
 * Use on most POST endpoints.
 */
const standardLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 300,
  standardHeaders: true,
  legacyHeaders: false,
});

/**
 * Strict limiter: 20 requests / 15 minutes (per IP)
 * Use on sensitive endpoints: login, verify-email, checkout session, password reset.
 */
const strictLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 20,
  standardHeaders: true,
  legacyHeaders: false,
  message: { error: "Too many attempts, please try again later." },
});

/**
 * Super strict (optional): 5 req / 15m — for password reset request
 */
const superStrictLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  standardHeaders: true,
  legacyHeaders: false,
  message: { error: "Too many attempts, please try again later." },
});

module.exports = { standardLimiter, strictLimiter, superStrictLimiter };

===== FILE: sliptail-backend\middleware\requireVerified.js =====

module.exports = function requireVerified(req, res, next) {
  if (!req.user) return res.status(401).json({ error: "Unauthorized" });
  if (!req.user.email_verified_at) {
    return res.status(403).json({ error: "Email not verified" });
  }
  next();
};

===== FILE: sliptail-backend\middleware\validate.js =====

function validate(schema) {
  return (req, res, next) => {
    try {
      const data = {
        body: req.body,
        params: req.params,
        query: req.query,
      };
      const parsed = schema.parse(data);
      // overwrite validated values so downstream uses sanitized data
      req.body = parsed.body || req.body;
      req.params = parsed.params || req.params;
      req.query = parsed.query || req.query;
      next();
    } catch (e) {
      const issues = e?.issues?.map(i => `${i.path.join(".")}: ${i.message}`) || ["Invalid request"];
      return res.status(400).json({ error: "Validation failed", details: issues });
    }
  };
}
module.exports = { validate };

===== FILE: sliptail-backend\models\User.js =====

const db = require("../db");

const createUser = async ({ email, passwordHash, role }) => {
  const result = await db.query(
    "INSERT INTO users (email, password_hash, role) VALUES ($1, $2, $3) RETURNING id, email, role",
    [email, passwordHash, role]
  );
  return result.rows[0];
};

const findUserByEmail = async (email) => {
  const result = await db.query("SELECT * FROM users WHERE email = $1", [email]);
  return result.rows[0];
};

module.exports = {
  createUser,
  findUserByEmail,
};

===== FILE: sliptail-backend\package-lock.json =====

{
  "name": "sliptail-backend",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "sliptail-backend",
      "version": "1.0.0",
      "license": "ISC",
      "dependencies": {
        "bcrypt": "^6.0.0",
        "cookie-parser": "^1.4.7",
        "cors": "^2.8.5",
        "dotenv": "^17.2.1",
        "express": "^5.1.0",
        "express-rate-limit": "^8.0.1",
        "fluent-ffmpeg": "^2.1.3",
        "jsonwebtoken": "^9.0.2",
        "multer": "^2.0.2",
        "node-cron": "^4.2.1",
        "nodemailer": "^7.0.5",
        "passport": "^0.7.0",
        "passport-google-oauth20": "^2.0.0",
        "pg": "^8.16.3",
        "stripe": "^18.4.0",
        "zod": "^4.1.5"
      },
      "devDependencies": {
        "nodemon": "^3.1.10"
      }
    },
    "node_modules/accepts": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-2.0.0.tgz",
      "integrity": "sha512-5cvg6CtKwfgdmVqY1WIiXKc3Q1bkRqGLi+2W/6ao+6Y7gu/RCwRuAhGEzh5B4KlszSuTLgZYuqFqo5bImjNKng==",
      "license": "MIT",
      "dependencies": {
        "mime-types": "^3.0.0",
        "negotiator": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/anymatch": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz",
      "integrity": "sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "normalize-path": "^3.0.0",
        "picomatch": "^2.0.4"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/append-field": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/append-field/-/append-field-1.0.0.tgz",
      "integrity": "sha512-klpgFSWLW1ZEs8svjfb7g4qWY0YS5imI82dTg+QahUvJ8YqAY0P10Uk8tTyh9ZGuYEZEMaeJYCF5BFuX552hsw==",
      "license": "MIT"
    },
    "node_modules/async": {
      "version": "0.2.10",
      "resolved": "https://registry.npmjs.org/async/-/async-0.2.10.tgz",
      "integrity": "sha512-eAkdoKxU6/LkKDBzLpT+t6Ff5EtfSF4wx1WfJiPEEV7WNLnDaRXk0oVysiEPm262roaachGexwUv94WhSgN5TQ=="
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/base64url": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/base64url/-/base64url-3.0.1.tgz",
      "integrity": "sha512-ir1UPr3dkwexU7FdV8qBBbNDRUhMmIekYMFZfi+C/sLNnRESKPl23nB9b2pltqfOQNnGzsDdId90AEtG5tCx4A==",
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/bcrypt": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/bcrypt/-/bcrypt-6.0.0.tgz",
      "integrity": "sha512-cU8v/EGSrnH+HnxV2z0J7/blxH8gq7Xh2JFT6Aroax7UohdmiJJlxApMxtKfuI7z68NvvVcmR78k2LbT6efhRg==",
      "hasInstallScript": true,
      "license": "MIT",
      "dependencies": {
        "node-addon-api": "^8.3.0",
        "node-gyp-build": "^4.8.4"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/binary-extensions": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.3.0.tgz",
      "integrity": "sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/body-parser": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-2.2.0.tgz",
      "integrity": "sha512-02qvAaxv8tp7fBa/mw1ga98OGm+eCbqzJOKoRt70sLmfEEi+jyBYVTDGfCL/k06/4EMk/z01gCe7HoCH/f2LTg==",
      "license": "MIT",
      "dependencies": {
        "bytes": "^3.1.2",
        "content-type": "^1.0.5",
        "debug": "^4.4.0",
        "http-errors": "^2.0.0",
        "iconv-lite": "^0.6.3",
        "on-finished": "^2.4.1",
        "qs": "^6.14.0",
        "raw-body": "^3.0.0",
        "type-is": "^2.0.0"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fill-range": "^7.1.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/buffer-equal-constant-time": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/buffer-equal-constant-time/-/buffer-equal-constant-time-1.0.1.tgz",
      "integrity": "sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA==",
      "license": "BSD-3-Clause"
    },
    "node_modules/buffer-from": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.2.tgz",
      "integrity": "sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==",
      "license": "MIT"
    },
    "node_modules/busboy": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/busboy/-/busboy-1.6.0.tgz",
      "integrity": "sha512-8SFQbg/0hQ9xy3UNTB0YEnsNBbWfhf7RtnzpL7TkBiTBRfrQ9Fxcnz7VJsleJpyp6rVLvXiuORqjlHi5q+PYuA==",
      "dependencies": {
        "streamsearch": "^1.1.0"
      },
      "engines": {
        "node": ">=10.16.0"
      }
    },
    "node_modules/bytes": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/call-bound": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "get-intrinsic": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/chokidar": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.6.0.tgz",
      "integrity": "sha512-7VT13fmjotKpGipCW9JEQAusEPE+Ei8nl6/g4FBAmIm0GOOLMua9NDDo/DWp0ZAxCr3cPq5ZpBqmPAQgDda2Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "anymatch": "~3.1.2",
        "braces": "~3.0.2",
        "glob-parent": "~5.1.2",
        "is-binary-path": "~2.1.0",
        "is-glob": "~4.0.1",
        "normalize-path": "~3.0.0",
        "readdirp": "~3.6.0"
      },
      "engines": {
        "node": ">= 8.10.0"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/concat-stream": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/concat-stream/-/concat-stream-2.0.0.tgz",
      "integrity": "sha512-MWufYdFw53ccGjCA+Ol7XJYpAlW6/prSMzuPOTRnJGcGzuhLn4Scrz7qf6o8bROZ514ltazcIFJZevcfbo0x7A==",
      "engines": [
        "node >= 6.0"
      ],
      "license": "MIT",
      "dependencies": {
        "buffer-from": "^1.0.0",
        "inherits": "^2.0.3",
        "readable-stream": "^3.0.2",
        "typedarray": "^0.0.6"
      }
    },
    "node_modules/content-disposition": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-1.0.0.tgz",
      "integrity": "sha512-Au9nRL8VNUut/XSzbQA38+M78dzP4D+eqg3gfJHMIHHYa3bg067xj1KxMUWj+VULbiZMowKngFFbKczUrNJ1mg==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "5.2.1"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/content-type": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
      "integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie": {
      "version": "0.7.2",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.2.tgz",
      "integrity": "sha512-yki5XnKuf750l50uGTllt6kKILY4nQ1eNIQatoXEByZ5dWgnKqbnqmTrBE5B4N7lrMJKQ2ytWMiTO2o0v6Ew/w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie-parser": {
      "version": "1.4.7",
      "resolved": "https://registry.npmjs.org/cookie-parser/-/cookie-parser-1.4.7.tgz",
      "integrity": "sha512-nGUvgXnotP3BsjiLX2ypbQnWoGUPIIfHQNZkkC668ntrzGWEZVW70HDEB1qnNGMicPje6EttlIgzo51YSwNQGw==",
      "license": "MIT",
      "dependencies": {
        "cookie": "0.7.2",
        "cookie-signature": "1.0.6"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/cookie-parser/node_modules/cookie-signature": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.0.6.tgz",
      "integrity": "sha512-QADzlaHc8icV8I7vbaJXJwod9HWYp8uCqf1xa4OfNu1T7JVxQIrUgOWtHdNDtPiywmFbiS12VjotIXLrKM3orQ==",
      "license": "MIT"
    },
    "node_modules/cookie-signature": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.2.2.tgz",
      "integrity": "sha512-D76uU73ulSXrD1UXF4KE2TMxVVwhsnCgfAyTg9k8P6KGZjlXKrOLe4dJQKI3Bxi5wjesZoFXJWElNWBjPZMbhg==",
      "license": "MIT",
      "engines": {
        "node": ">=6.6.0"
      }
    },
    "node_modules/cors": {
      "version": "2.8.5",
      "resolved": "https://registry.npmjs.org/cors/-/cors-2.8.5.tgz",
      "integrity": "sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==",
      "license": "MIT",
      "dependencies": {
        "object-assign": "^4",
        "vary": "^1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/debug": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.1.tgz",
      "integrity": "sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/dotenv": {
      "version": "17.2.1",
      "resolved": "https://registry.npmjs.org/dotenv/-/dotenv-17.2.1.tgz",
      "integrity": "sha512-kQhDYKZecqnM0fCnzI5eIv5L4cAe/iRI+HqMbO/hbRdTAeXDG+M9FjipUxNfbARuEg4iHIbhnhs78BCHNbSxEQ==",
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://dotenvx.com"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/ecdsa-sig-formatter": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.11.tgz",
      "integrity": "sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/ee-first": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
      "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
      "license": "MIT"
    },
    "node_modules/encodeurl": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
      "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/escape-html": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==",
      "license": "MIT"
    },
    "node_modules/etag": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
      "integrity": "sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/express": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/express/-/express-5.1.0.tgz",
      "integrity": "sha512-DT9ck5YIRU+8GYzzU5kT3eHGA5iL+1Zd0EutOmTE9Dtk+Tvuzd23VBU+ec7HPNSTxXYO55gPV/hq4pSBJDjFpA==",
      "license": "MIT",
      "dependencies": {
        "accepts": "^2.0.0",
        "body-parser": "^2.2.0",
        "content-disposition": "^1.0.0",
        "content-type": "^1.0.5",
        "cookie": "^0.7.1",
        "cookie-signature": "^1.2.1",
        "debug": "^4.4.0",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "etag": "^1.8.1",
        "finalhandler": "^2.1.0",
        "fresh": "^2.0.0",
        "http-errors": "^2.0.0",
        "merge-descriptors": "^2.0.0",
        "mime-types": "^3.0.0",
        "on-finished": "^2.4.1",
        "once": "^1.4.0",
        "parseurl": "^1.3.3",
        "proxy-addr": "^2.0.7",
        "qs": "^6.14.0",
        "range-parser": "^1.2.1",
        "router": "^2.2.0",
        "send": "^1.1.0",
        "serve-static": "^2.2.0",
        "statuses": "^2.0.1",
        "type-is": "^2.0.1",
        "vary": "^1.1.2"
      },
      "engines": {
        "node": ">= 18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/express-rate-limit": {
      "version": "8.0.1",
      "resolved": "https://registry.npmjs.org/express-rate-limit/-/express-rate-limit-8.0.1.tgz",
      "integrity": "sha512-aZVCnybn7TVmxO4BtlmnvX+nuz8qHW124KKJ8dumsBsmv5ZLxE0pYu7S2nwyRBGHHCAzdmnGyrc5U/rksSPO7Q==",
      "license": "MIT",
      "dependencies": {
        "ip-address": "10.0.1"
      },
      "engines": {
        "node": ">= 16"
      },
      "funding": {
        "url": "https://github.com/sponsors/express-rate-limit"
      },
      "peerDependencies": {
        "express": ">= 4.11"
      }
    },
    "node_modules/fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/finalhandler": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-2.1.0.tgz",
      "integrity": "sha512-/t88Ty3d5JWQbWYgaOGCCYfXRwV1+be02WqYYlL6h0lEiUAMPM8o8qKGO01YIkOHzka2up08wvgYD0mDiI+q3Q==",
      "license": "MIT",
      "dependencies": {
        "debug": "^4.4.0",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "on-finished": "^2.4.1",
        "parseurl": "^1.3.3",
        "statuses": "^2.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/fluent-ffmpeg": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/fluent-ffmpeg/-/fluent-ffmpeg-2.1.3.tgz",
      "integrity": "sha512-Be3narBNt2s6bsaqP6Jzq91heDgOEaDCJAXcE3qcma/EJBSy5FB4cvO31XBInuAuKBx8Kptf8dkhjK0IOru39Q==",
      "deprecated": "Package no longer supported. Contact Support at https://www.npmjs.com/support for more info.",
      "license": "MIT",
      "dependencies": {
        "async": "^0.2.9",
        "which": "^1.1.1"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/forwarded": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
      "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fresh": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/fresh/-/fresh-2.0.0.tgz",
      "integrity": "sha512-Rx/WycZ60HOaqLKAi6cHRKKI7zxWbJ31MhntmtwMoaTeF7XFH9hhBp8vITaMidfljRQ6eYWCKkaTK+ykVJHP2A==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-flag": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
      "integrity": "sha512-sKJf1+ceQBr4SMkvQnBDNDtf4TXpVhVGateu0t918bl30FnbE2m4vNLX+VWe/dpjlb+HugGYzW7uQXH98HPEYw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/http-errors": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz",
      "integrity": "sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==",
      "license": "MIT",
      "dependencies": {
        "depd": "2.0.0",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "toidentifier": "1.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/http-errors/node_modules/statuses": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz",
      "integrity": "sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/iconv-lite": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.3.tgz",
      "integrity": "sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==",
      "license": "MIT",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3.0.0"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/ignore-by-default": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/ignore-by-default/-/ignore-by-default-1.0.1.tgz",
      "integrity": "sha512-Ius2VYcGNk7T90CppJqcIkS5ooHUZyIQK+ClZfMfMNFEF9VSE73Fq+906u/CWu92x4gzZMWOwfFYckPObzdEbA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "license": "ISC"
    },
    "node_modules/ip-address": {
      "version": "10.0.1",
      "resolved": "https://registry.npmjs.org/ip-address/-/ip-address-10.0.1.tgz",
      "integrity": "sha512-NWv9YLW4PoW2B7xtzaS3NCot75m6nK7Icdv0o3lfMceJVRfSoQwqD4wEH5rLwoKJwUiZ/rfpiVBhnaF0FK4HoA==",
      "license": "MIT",
      "engines": {
        "node": ">= 12"
      }
    },
    "node_modules/ipaddr.js": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/is-binary-path": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
      "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "binary-extensions": "^2.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/is-promise": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/is-promise/-/is-promise-4.0.0.tgz",
      "integrity": "sha512-hvpoI6korhJMnej285dSg6nu1+e6uxs7zG3BYAm5byqDsgJNWwxzM6z6iZiAgQR4TJ30JmBTOwqZUw3WlyH3AQ==",
      "license": "MIT"
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==",
      "license": "ISC"
    },
    "node_modules/jsonwebtoken": {
      "version": "9.0.2",
      "resolved": "https://registry.npmjs.org/jsonwebtoken/-/jsonwebtoken-9.0.2.tgz",
      "integrity": "sha512-PRp66vJ865SSqOlgqS8hujT5U4AOgMfhrwYIuIhfKaoSCZcirrmASQr8CX7cUg+RMih+hgznrjp99o+W4pJLHQ==",
      "license": "MIT",
      "dependencies": {
        "jws": "^3.2.2",
        "lodash.includes": "^4.3.0",
        "lodash.isboolean": "^3.0.3",
        "lodash.isinteger": "^4.0.4",
        "lodash.isnumber": "^3.0.3",
        "lodash.isplainobject": "^4.0.6",
        "lodash.isstring": "^4.0.1",
        "lodash.once": "^4.0.0",
        "ms": "^2.1.1",
        "semver": "^7.5.4"
      },
      "engines": {
        "node": ">=12",
        "npm": ">=6"
      }
    },
    "node_modules/jwa": {
      "version": "1.4.2",
      "resolved": "https://registry.npmjs.org/jwa/-/jwa-1.4.2.tgz",
      "integrity": "sha512-eeH5JO+21J78qMvTIDdBXidBd6nG2kZjg5Ohz/1fpa28Z4CcsWUzJ1ZZyFq/3z3N17aZy+ZuBoHljASbL1WfOw==",
      "license": "MIT",
      "dependencies": {
        "buffer-equal-constant-time": "^1.0.1",
        "ecdsa-sig-formatter": "1.0.11",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/jws": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/jws/-/jws-3.2.2.tgz",
      "integrity": "sha512-YHlZCB6lMTllWDtSPHz/ZXTsi8S00usEV6v1tjq8tOUZzw7DpSDWVXjXDre6ed1w/pd495ODpHZYSdkRTsa0HA==",
      "license": "MIT",
      "dependencies": {
        "jwa": "^1.4.1",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/lodash.includes": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/lodash.includes/-/lodash.includes-4.3.0.tgz",
      "integrity": "sha512-W3Bx6mdkRTGtlJISOvVD/lbqjTlPPUDTMnlXZFnVwi9NKJ6tiAk6LVdlhZMm17VZisqhKcgzpO5Wz91PCt5b0w==",
      "license": "MIT"
    },
    "node_modules/lodash.isboolean": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isboolean/-/lodash.isboolean-3.0.3.tgz",
      "integrity": "sha512-Bz5mupy2SVbPHURB98VAcw+aHh4vRV5IPNhILUCsOzRmsTmSQ17jIuqopAentWoehktxGd9e/hbIXq980/1QJg==",
      "license": "MIT"
    },
    "node_modules/lodash.isinteger": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/lodash.isinteger/-/lodash.isinteger-4.0.4.tgz",
      "integrity": "sha512-DBwtEWN2caHQ9/imiNeEA5ys1JoRtRfY3d7V9wkqtbycnAmTvRRmbHKDV4a0EYc678/dia0jrte4tjYwVBaZUA==",
      "license": "MIT"
    },
    "node_modules/lodash.isnumber": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isnumber/-/lodash.isnumber-3.0.3.tgz",
      "integrity": "sha512-QYqzpfwO3/CWf3XP+Z+tkQsfaLL/EnUlXWVkIk5FUPc4sBdTehEqZONuyRt2P67PXAk+NXmTBcc97zw9t1FQrw==",
      "license": "MIT"
    },
    "node_modules/lodash.isplainobject": {
      "version": "4.0.6",
      "resolved": "https://registry.npmjs.org/lodash.isplainobject/-/lodash.isplainobject-4.0.6.tgz",
      "integrity": "sha512-oSXzaWypCMHkPC3NvBEaPHf0KsA5mvPrOPgQWDsbg8n7orZ290M0BmC/jgRZ4vcJ6DTAhjrsSYgdsW/F+MFOBA==",
      "license": "MIT"
    },
    "node_modules/lodash.isstring": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/lodash.isstring/-/lodash.isstring-4.0.1.tgz",
      "integrity": "sha512-0wJxfxH1wgO3GrbuP+dTTk7op+6L41QCXbGINEmD+ny/G/eCqGzxyCsh7159S+mgDDcoarnBw6PC1PS5+wUGgw==",
      "license": "MIT"
    },
    "node_modules/lodash.once": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/lodash.once/-/lodash.once-4.1.1.tgz",
      "integrity": "sha512-Sb487aTOCr9drQVL8pIxOzVhafOjZN9UU54hiN8PU3uAiSV7lx1yYNpbNmex2PK6dSJoNTSJUUswT651yww3Mg==",
      "license": "MIT"
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/media-typer": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-1.1.0.tgz",
      "integrity": "sha512-aisnrDP4GNe06UcKFnV5bfMNPBUw4jsLGaWwWfnH3v02GnBuXX2MCVn5RbrWo0j3pczUilYblq7fQ7Nw2t5XKw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/merge-descriptors": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-2.0.0.tgz",
      "integrity": "sha512-Snk314V5ayFLhp3fkUREub6WtjBfPdCPY1Ln8/8munuLuiYhsABgBVWsozAG+MWMbVEvcdcpbi9R7ww22l9Q3g==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/mime-db": {
      "version": "1.54.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.54.0.tgz",
      "integrity": "sha512-aU5EJuIN2WDemCcAp2vFBfp/m4EAhWJnUNSSw0ixs7/kXbd6Pg64EmwJkNdFhB8aWt1sH2CTXrLxo/iAGV3oPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-3.0.1.tgz",
      "integrity": "sha512-xRc4oEhT6eaBpU1XF7AjpOFD+xQmXNB5OVKwp4tqCuBpHLS/ZbBDrc07mYTDqVMg6PfxUjjNp85O6Cd2Z/5HWA==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "^1.54.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/minimist": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.8.tgz",
      "integrity": "sha512-2yyAR8qBkN3YuheJanUpWC5U3bb5osDywNB8RzDVlDwDHbocAJveqqj1u8+SVD7jkWT4yvsHCpWqqWqAxb0zCA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/mkdirp": {
      "version": "0.5.6",
      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.6.tgz",
      "integrity": "sha512-FP+p8RB8OWpF3YZBCrP5gtADmtXApB5AMLn+vdyA+PyxCjrCs00mjyUozssO33cwDeT3wNGdLxJ5M//YqtHAJw==",
      "license": "MIT",
      "dependencies": {
        "minimist": "^1.2.6"
      },
      "bin": {
        "mkdirp": "bin/cmd.js"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/multer": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/multer/-/multer-2.0.2.tgz",
      "integrity": "sha512-u7f2xaZ/UG8oLXHvtF/oWTRvT44p9ecwBBqTwgJVq0+4BW1g8OW01TyMEGWBHbyMOYVHXslaut7qEQ1meATXgw==",
      "license": "MIT",
      "dependencies": {
        "append-field": "^1.0.0",
        "busboy": "^1.6.0",
        "concat-stream": "^2.0.0",
        "mkdirp": "^0.5.6",
        "object-assign": "^4.1.1",
        "type-is": "^1.6.18",
        "xtend": "^4.0.2"
      },
      "engines": {
        "node": ">= 10.16.0"
      }
    },
    "node_modules/multer/node_modules/media-typer": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-0.3.0.tgz",
      "integrity": "sha512-dq+qelQ9akHpcOl/gUVRTxVIOkAJ1wR3QAvb4RsVjS8oVoFjDGTc679wJYmUmknUF5HwMLOgb5O+a3KxfWapPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/multer/node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/multer/node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/multer/node_modules/type-is": {
      "version": "1.6.18",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-1.6.18.tgz",
      "integrity": "sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==",
      "license": "MIT",
      "dependencies": {
        "media-typer": "0.3.0",
        "mime-types": "~2.1.24"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/negotiator": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-1.0.0.tgz",
      "integrity": "sha512-8Ofs/AUQh8MaEcrlq5xOX0CQ9ypTF5dl78mjlMNfOK08fzpgTHQRQPBxcPlEtIw0yRpws+Zo/3r+5WRby7u3Gg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/node-addon-api": {
      "version": "8.5.0",
      "resolved": "https://registry.npmjs.org/node-addon-api/-/node-addon-api-8.5.0.tgz",
      "integrity": "sha512-/bRZty2mXUIFY/xU5HLvveNHlswNJej+RnxBjOMkidWfwZzgTbPG1E3K5TOxRLOR+5hX7bSofy8yf1hZevMS8A==",
      "license": "MIT",
      "engines": {
        "node": "^18 || ^20 || >= 21"
      }
    },
    "node_modules/node-cron": {
      "version": "4.2.1",
      "resolved": "https://registry.npmjs.org/node-cron/-/node-cron-4.2.1.tgz",
      "integrity": "sha512-lgimEHPE/QDgFlywTd8yTR61ptugX3Qer29efeyWw2rv259HtGBNn1vZVmp8lB9uo9wC0t/AT4iGqXxia+CJFg==",
      "license": "ISC",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/node-gyp-build": {
      "version": "4.8.4",
      "resolved": "https://registry.npmjs.org/node-gyp-build/-/node-gyp-build-4.8.4.tgz",
      "integrity": "sha512-LA4ZjwlnUblHVgq0oBF3Jl/6h/Nvs5fzBLwdEF4nuxnFdsfajde4WfxtJr3CaiH+F6ewcIB/q4jQ4UzPyid+CQ==",
      "license": "MIT",
      "bin": {
        "node-gyp-build": "bin.js",
        "node-gyp-build-optional": "optional.js",
        "node-gyp-build-test": "build-test.js"
      }
    },
    "node_modules/nodemailer": {
      "version": "7.0.5",
      "resolved": "https://registry.npmjs.org/nodemailer/-/nodemailer-7.0.5.tgz",
      "integrity": "sha512-nsrh2lO3j4GkLLXoeEksAMgAOqxOv6QumNRVQTJwKH4nuiww6iC2y7GyANs9kRAxCexg3+lTWM3PZ91iLlVjfg==",
      "license": "MIT-0",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/nodemon": {
      "version": "3.1.10",
      "resolved": "https://registry.npmjs.org/nodemon/-/nodemon-3.1.10.tgz",
      "integrity": "sha512-WDjw3pJ0/0jMFmyNDp3gvY2YizjLmmOUQo6DEBY+JgdvW/yQ9mEeSw6H5ythl5Ny2ytb7f9C2nIbjSxMNzbJXw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "chokidar": "^3.5.2",
        "debug": "^4",
        "ignore-by-default": "^1.0.1",
        "minimatch": "^3.1.2",
        "pstree.remy": "^1.1.8",
        "semver": "^7.5.3",
        "simple-update-notifier": "^2.0.0",
        "supports-color": "^5.5.0",
        "touch": "^3.1.0",
        "undefsafe": "^2.0.5"
      },
      "bin": {
        "nodemon": "bin/nodemon.js"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/nodemon"
      }
    },
    "node_modules/normalize-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/oauth": {
      "version": "0.10.2",
      "resolved": "https://registry.npmjs.org/oauth/-/oauth-0.10.2.tgz",
      "integrity": "sha512-JtFnB+8nxDEXgNyniwz573xxbKSOu3R8D40xQKqcjwJ2CDkYqUDI53o6IuzDJBx60Z8VKCm271+t8iFjakrl8Q==",
      "license": "MIT"
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.13.4",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/on-finished": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
      "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
      "license": "MIT",
      "dependencies": {
        "ee-first": "1.1.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/parseurl": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/passport": {
      "version": "0.7.0",
      "resolved": "https://registry.npmjs.org/passport/-/passport-0.7.0.tgz",
      "integrity": "sha512-cPLl+qZpSc+ireUvt+IzqbED1cHHkDoVYMo30jbJIdOOjQ1MQYZBPiNvmi8UM6lJuOpTPXJGZQk0DtC4y61MYQ==",
      "license": "MIT",
      "dependencies": {
        "passport-strategy": "1.x.x",
        "pause": "0.0.1",
        "utils-merge": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4.0"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/jaredhanson"
      }
    },
    "node_modules/passport-google-oauth20": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/passport-google-oauth20/-/passport-google-oauth20-2.0.0.tgz",
      "integrity": "sha512-KSk6IJ15RoxuGq7D1UKK/8qKhNfzbLeLrG3gkLZ7p4A6DBCcv7xpyQwuXtWdpyR0+E0mwkpjY1VfPOhxQrKzdQ==",
      "license": "MIT",
      "dependencies": {
        "passport-oauth2": "1.x.x"
      },
      "engines": {
        "node": ">= 0.4.0"
      }
    },
    "node_modules/passport-oauth2": {
      "version": "1.8.0",
      "resolved": "https://registry.npmjs.org/passport-oauth2/-/passport-oauth2-1.8.0.tgz",
      "integrity": "sha512-cjsQbOrXIDE4P8nNb3FQRCCmJJ/utnFKEz2NX209f7KOHPoX18gF7gBzBbLLsj2/je4KrgiwLLGjf0lm9rtTBA==",
      "license": "MIT",
      "dependencies": {
        "base64url": "3.x.x",
        "oauth": "0.10.x",
        "passport-strategy": "1.x.x",
        "uid2": "0.0.x",
        "utils-merge": "1.x.x"
      },
      "engines": {
        "node": ">= 0.4.0"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/jaredhanson"
      }
    },
    "node_modules/passport-strategy": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/passport-strategy/-/passport-strategy-1.0.0.tgz",
      "integrity": "sha512-CB97UUvDKJde2V0KDWWB3lyf6PC3FaZP7YxZ2G8OAtn9p4HI9j9JLP9qjOGZFvyl8uwNT8qM+hGnz/n16NI7oA==",
      "engines": {
        "node": ">= 0.4.0"
      }
    },
    "node_modules/path-to-regexp": {
      "version": "8.2.0",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-8.2.0.tgz",
      "integrity": "sha512-TdrF7fW9Rphjq4RjrW0Kp2AW0Ahwu9sRGTkS6bvDi0SCwZlEZYmcfDbEsTz8RVk0EHIS/Vd1bv3JhG+1xZuAyQ==",
      "license": "MIT",
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/pause": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/pause/-/pause-0.0.1.tgz",
      "integrity": "sha512-KG8UEiEVkR3wGEb4m5yZkVCzigAD+cVEJck2CzYZO37ZGJfctvVptVO192MwrtPhzONn6go8ylnOdMhKqi4nfg=="
    },
    "node_modules/pg": {
      "version": "8.16.3",
      "resolved": "https://registry.npmjs.org/pg/-/pg-8.16.3.tgz",
      "integrity": "sha512-enxc1h0jA/aq5oSDMvqyW3q89ra6XIIDZgCX9vkMrnz5DFTw/Ny3Li2lFQ+pt3L6MCgm/5o2o8HW9hiJji+xvw==",
      "license": "MIT",
      "dependencies": {
        "pg-connection-string": "^2.9.1",
        "pg-pool": "^3.10.1",
        "pg-protocol": "^1.10.3",
        "pg-types": "2.2.0",
        "pgpass": "1.0.5"
      },
      "engines": {
        "node": ">= 16.0.0"
      },
      "optionalDependencies": {
        "pg-cloudflare": "^1.2.7"
      },
      "peerDependencies": {
        "pg-native": ">=3.0.1"
      },
      "peerDependenciesMeta": {
        "pg-native": {
          "optional": true
        }
      }
    },
    "node_modules/pg-cloudflare": {
      "version": "1.2.7",
      "resolved": "https://registry.npmjs.org/pg-cloudflare/-/pg-cloudflare-1.2.7.tgz",
      "integrity": "sha512-YgCtzMH0ptvZJslLM1ffsY4EuGaU0cx4XSdXLRFae8bPP4dS5xL1tNB3k2o/N64cHJpwU7dxKli/nZ2lUa5fLg==",
      "license": "MIT",
      "optional": true
    },
    "node_modules/pg-connection-string": {
      "version": "2.9.1",
      "resolved": "https://registry.npmjs.org/pg-connection-string/-/pg-connection-string-2.9.1.tgz",
      "integrity": "sha512-nkc6NpDcvPVpZXxrreI/FOtX3XemeLl8E0qFr6F2Lrm/I8WOnaWNhIPK2Z7OHpw7gh5XJThi6j6ppgNoaT1w4w==",
      "license": "MIT"
    },
    "node_modules/pg-int8": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/pg-int8/-/pg-int8-1.0.1.tgz",
      "integrity": "sha512-WCtabS6t3c8SkpDBUlb1kjOs7l66xsGdKpIPZsg4wR+B3+u9UAum2odSsF9tnvxg80h4ZxLWMy4pRjOsFIqQpw==",
      "license": "ISC",
      "engines": {
        "node": ">=4.0.0"
      }
    },
    "node_modules/pg-pool": {
      "version": "3.10.1",
      "resolved": "https://registry.npmjs.org/pg-pool/-/pg-pool-3.10.1.tgz",
      "integrity": "sha512-Tu8jMlcX+9d8+QVzKIvM/uJtp07PKr82IUOYEphaWcoBhIYkoHpLXN3qO59nAI11ripznDsEzEv8nUxBVWajGg==",
      "license": "MIT",
      "peerDependencies": {
        "pg": ">=8.0"
      }
    },
    "node_modules/pg-protocol": {
      "version": "1.10.3",
      "resolved": "https://registry.npmjs.org/pg-protocol/-/pg-protocol-1.10.3.tgz",
      "integrity": "sha512-6DIBgBQaTKDJyxnXaLiLR8wBpQQcGWuAESkRBX/t6OwA8YsqP+iVSiond2EDy6Y/dsGk8rh/jtax3js5NeV7JQ==",
      "license": "MIT"
    },
    "node_modules/pg-types": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/pg-types/-/pg-types-2.2.0.tgz",
      "integrity": "sha512-qTAAlrEsl8s4OiEQY69wDvcMIdQN6wdz5ojQiOy6YRMuynxenON0O5oCpJI6lshc6scgAY8qvJ2On/p+CXY0GA==",
      "license": "MIT",
      "dependencies": {
        "pg-int8": "1.0.1",
        "postgres-array": "~2.0.0",
        "postgres-bytea": "~1.0.0",
        "postgres-date": "~1.0.4",
        "postgres-interval": "^1.1.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/pgpass": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/pgpass/-/pgpass-1.0.5.tgz",
      "integrity": "sha512-FdW9r/jQZhSeohs1Z3sI1yxFQNFvMcnmfuj4WBMUTxOrAyLMaTcE1aAMBiTlbMNaXvBCQuVi0R7hd8udDSP7ug==",
      "license": "MIT",
      "dependencies": {
        "split2": "^4.1.0"
      }
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/postgres-array": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/postgres-array/-/postgres-array-2.0.0.tgz",
      "integrity": "sha512-VpZrUqU5A69eQyW2c5CA1jtLecCsN2U/bD6VilrFDWq5+5UIEVO7nazS3TEcHf1zuPYO/sqGvUvW62g86RXZuA==",
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/postgres-bytea": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/postgres-bytea/-/postgres-bytea-1.0.0.tgz",
      "integrity": "sha512-xy3pmLuQqRBZBXDULy7KbaitYqLcmxigw14Q5sj8QBVLqEwXfeybIKVWiqAXTlcvdvb0+xkOtDbfQMOf4lST1w==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/postgres-date": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/postgres-date/-/postgres-date-1.0.7.tgz",
      "integrity": "sha512-suDmjLVQg78nMK2UZ454hAG+OAW+HQPZ6n++TNDUX+L0+uUlLywnoxJKDou51Zm+zTCjrCl0Nq6J9C5hP9vK/Q==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/postgres-interval": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/postgres-interval/-/postgres-interval-1.2.0.tgz",
      "integrity": "sha512-9ZhXKM/rw350N1ovuWHbGxnGh/SNJ4cnxHiM0rxE4VN41wsg8P8zWn9hv/buK00RP4WvlOyr/RBDiptyxVbkZQ==",
      "license": "MIT",
      "dependencies": {
        "xtend": "^4.0.0"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/proxy-addr": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
      "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
      "license": "MIT",
      "dependencies": {
        "forwarded": "0.2.0",
        "ipaddr.js": "1.9.1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/pstree.remy": {
      "version": "1.1.8",
      "resolved": "https://registry.npmjs.org/pstree.remy/-/pstree.remy-1.1.8.tgz",
      "integrity": "sha512-77DZwxQmxKnu3aR542U+X8FypNzbfJ+C5XQDk3uWjWxn6151aIMGthWYRXTqT1E5oJvg+ljaa2OJi+VfvCOQ8w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/qs": {
      "version": "6.14.0",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.14.0.tgz",
      "integrity": "sha512-YWWTjgABSKcvs/nWBi9PycY/JiPJqOD4JA6o9Sej2AtvSGarXxKC3OQSk4pAarbdQlKAh5D4FCQkJNkW+GAn3w==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "side-channel": "^1.1.0"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/range-parser": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/raw-body": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-3.0.0.tgz",
      "integrity": "sha512-RmkhL8CAyCRPXCE28MMH0z2PNWQBNk2Q09ZdxM9IOOXwxwZbN+qbWaatPkdkWIKL2ZVDImrN/pK5HTRz2PcS4g==",
      "license": "MIT",
      "dependencies": {
        "bytes": "3.1.2",
        "http-errors": "2.0.0",
        "iconv-lite": "0.6.3",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/readable-stream": {
      "version": "3.6.2",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.2.tgz",
      "integrity": "sha512-9u/sniCrY3D5WdsERHzHE4G2YCXqoG5FTHUiCC4SIbr6XcLZBY05ya9EKjYek9O5xOAwjGq+1JdGBAS7Q9ScoA==",
      "license": "MIT",
      "dependencies": {
        "inherits": "^2.0.3",
        "string_decoder": "^1.1.1",
        "util-deprecate": "^1.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/readdirp": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
      "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "picomatch": "^2.2.1"
      },
      "engines": {
        "node": ">=8.10.0"
      }
    },
    "node_modules/router": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/router/-/router-2.2.0.tgz",
      "integrity": "sha512-nLTrUKm2UyiL7rlhapu/Zl45FwNgkZGaCpZbIHajDYgwlJCOzLSk+cIPAnsEqV955GjILJnKbdQC1nVPz+gAYQ==",
      "license": "MIT",
      "dependencies": {
        "debug": "^4.4.0",
        "depd": "^2.0.0",
        "is-promise": "^4.0.0",
        "parseurl": "^1.3.3",
        "path-to-regexp": "^8.0.0"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "7.7.2",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.2.tgz",
      "integrity": "sha512-RF0Fw+rO5AMf9MAyaRXI4AV0Ulj5lMHqVxxdSgiVbixSCXoEmmX/jk0CuJw4+3SqroYO9VoUh+HcuJivvtJemA==",
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/send": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/send/-/send-1.2.0.tgz",
      "integrity": "sha512-uaW0WwXKpL9blXE2o0bRhoL2EGXIrZxQ2ZQ4mgcfoBxdFmQold+qWsD2jLrfZ0trjKL6vOw0j//eAwcALFjKSw==",
      "license": "MIT",
      "dependencies": {
        "debug": "^4.3.5",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "etag": "^1.8.1",
        "fresh": "^2.0.0",
        "http-errors": "^2.0.0",
        "mime-types": "^3.0.1",
        "ms": "^2.1.3",
        "on-finished": "^2.4.1",
        "range-parser": "^1.2.1",
        "statuses": "^2.0.1"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/serve-static": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-2.2.0.tgz",
      "integrity": "sha512-61g9pCh0Vnh7IutZjtLGGpTA355+OPn2TyDv/6ivP2h/AdAVX9azsoxmg2/M6nZeQZNYBEwIcsne1mJd9oQItQ==",
      "license": "MIT",
      "dependencies": {
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "parseurl": "^1.3.3",
        "send": "^1.2.0"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==",
      "license": "ISC"
    },
    "node_modules/side-channel": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3",
        "side-channel-list": "^1.0.0",
        "side-channel-map": "^1.0.1",
        "side-channel-weakmap": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-list": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-map": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-weakmap": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3",
        "side-channel-map": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/simple-update-notifier": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/simple-update-notifier/-/simple-update-notifier-2.0.0.tgz",
      "integrity": "sha512-a2B9Y0KlNXl9u/vsW6sTIu9vGEpfKu2wRV6l1H3XEas/0gUIzGzBoP/IouTcUQbm9JWZLH3COxyn03TYlFax6w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "semver": "^7.5.3"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/split2": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/split2/-/split2-4.2.0.tgz",
      "integrity": "sha512-UcjcJOWknrNkF6PLX83qcHM6KHgVKNkV62Y8a5uYDVv9ydGQVwAHMKqHdJje1VTWpljG0WYpCDhrCdAOYH4TWg==",
      "license": "ISC",
      "engines": {
        "node": ">= 10.x"
      }
    },
    "node_modules/statuses": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.2.tgz",
      "integrity": "sha512-DvEy55V3DB7uknRo+4iOGT5fP1slR8wQohVdknigZPMpMstaKJQWhwiYBACJE3Ul2pTnATihhBYnRhZQHGBiRw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/streamsearch": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/streamsearch/-/streamsearch-1.1.0.tgz",
      "integrity": "sha512-Mcc5wHehp9aXz1ax6bZUyY5afg9u2rv5cqQI3mRrYkGC8rW2hM02jWuwjtL++LS5qinSyhj2QfLyNsuc+VsExg==",
      "engines": {
        "node": ">=10.0.0"
      }
    },
    "node_modules/string_decoder": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.3.0.tgz",
      "integrity": "sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "~5.2.0"
      }
    },
    "node_modules/stripe": {
      "version": "18.4.0",
      "resolved": "https://registry.npmjs.org/stripe/-/stripe-18.4.0.tgz",
      "integrity": "sha512-LKFeDnDYo4U/YzNgx2Lc9PT9XgKN0JNF1iQwZxgkS4lOw5NunWCnzyH5RhTlD3clIZnf54h7nyMWkS8VXPmtTQ==",
      "license": "MIT",
      "dependencies": {
        "qs": "^6.11.0"
      },
      "engines": {
        "node": ">=12.*"
      },
      "peerDependencies": {
        "@types/node": ">=12.x.x"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        }
      }
    },
    "node_modules/supports-color": {
      "version": "5.5.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
      "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^3.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "license": "MIT",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/touch": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/touch/-/touch-3.1.1.tgz",
      "integrity": "sha512-r0eojU4bI8MnHr8c5bNo7lJDdI2qXlWWJk6a9EAFG7vbhTjElYhBVS3/miuE0uOuoLdb8Mc/rVfsmm6eo5o9GA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "nodetouch": "bin/nodetouch.js"
      }
    },
    "node_modules/type-is": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-2.0.1.tgz",
      "integrity": "sha512-OZs6gsjF4vMp32qrCbiVSkrFmXtG/AZhY3t0iAMrMBiAZyV9oALtXO8hsrHbMXF9x6L3grlFuwW2oAz7cav+Gw==",
      "license": "MIT",
      "dependencies": {
        "content-type": "^1.0.5",
        "media-typer": "^1.1.0",
        "mime-types": "^3.0.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/typedarray": {
      "version": "0.0.6",
      "resolved": "https://registry.npmjs.org/typedarray/-/typedarray-0.0.6.tgz",
      "integrity": "sha512-/aCDEGatGvZ2BIk+HmLf4ifCJFwvKFNb9/JeZPMulfgFracn9QFcAf5GO8B/mweUjSoblS5In0cWhqpfs/5PQA==",
      "license": "MIT"
    },
    "node_modules/uid2": {
      "version": "0.0.4",
      "resolved": "https://registry.npmjs.org/uid2/-/uid2-0.0.4.tgz",
      "integrity": "sha512-IevTus0SbGwQzYh3+fRsAMTVVPOoIVufzacXcHPmdlle1jUpq7BRL+mw3dgeLanvGZdwwbWhRV6XrcFNdBmjWA==",
      "license": "MIT"
    },
    "node_modules/undefsafe": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/undefsafe/-/undefsafe-2.0.5.tgz",
      "integrity": "sha512-WxONCrssBM8TSPRqN5EmsjVrsv4A8X12J4ArBiiayv3DyyG3ZlIg6yysuuSYdZsVz3TKcTg2fd//Ujd4CHV1iA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==",
      "license": "MIT"
    },
    "node_modules/utils-merge": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
      "integrity": "sha512-pMZTvIkT1d+TFGvDOqodOclx0QWkkgi6Tdoa8gC8ffGAAqz9pzPTZWAybbsHHoED/ztMtkv/VoYTYyShUn81hA==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4.0"
      }
    },
    "node_modules/vary": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
      "integrity": "sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/which": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/which/-/which-1.3.1.tgz",
      "integrity": "sha512-HxJdYWq1MTIQbJ3nw0cqssHoTNU267KlrDuGZ1WYlxDStUtKUhOaJmh112/TZmHxxUfuJqPXSOm7tDyas0OSIQ==",
      "license": "ISC",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "which": "bin/which"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==",
      "license": "ISC"
    },
    "node_modules/xtend": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/xtend/-/xtend-4.0.2.tgz",
      "integrity": "sha512-LKYU1iAXJXUgAXn9URjiu+MWhyUXHsvfp7mcuYm9dSUKK0/CjtrUwFAxD82/mCWbtLsGjFIad0wIsod4zrTAEQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.4"
      }
    },
    "node_modules/zod": {
      "version": "4.1.5",
      "resolved": "https://registry.npmjs.org/zod/-/zod-4.1.5.tgz",
      "integrity": "sha512-rcUUZqlLJgBC33IT3PNMgsCq6TzLQEG/Ei/KTCU0PedSWRMAXoOUN+4t/0H+Q8bdnLPdqUYnvboJT0bn/229qg==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/colinhacks"
      }
    }
  }
}


===== FILE: sliptail-backend\package.json =====

{
  "name": "sliptail-backend",
  "version": "1.0.0",
  "main": "index.js",
  "type": "commonjs",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcrypt": "^6.0.0",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^17.2.1",
    "express": "^5.1.0",
    "express-rate-limit": "^8.0.1",
    "fluent-ffmpeg": "^2.1.3",
    "jsonwebtoken": "^9.0.2",
    "multer": "^2.0.2",
    "node-cron": "^4.2.1",
    "nodemailer": "^7.0.5",
    "passport": "^0.7.0",
    "passport-google-oauth20": "^2.0.0",
    "pg": "^8.16.3",
    "stripe": "^18.4.0",
    "zod": "^4.1.5"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}


===== FILE: sliptail-backend\routes\admin.js =====

const express = require("express");
const db = require("../db");
const { requireAuth, requireAdmin } = require("../middleware/auth");

const router = express.Router();

// All admin routes require auth + admin
router.use(requireAuth, requireAdmin);

/* ------------------------- helpers: tx + optional delete ---------------- */

async function withTx(run) {
  // Works with either a Pool (db.connect) or a simple { query } helper.
  if (typeof db.connect === "function") {
    const client = await db.connect();
    try {
      await client.query("BEGIN");
      const result = await run((q, p) => client.query(q, p));
      await client.query("COMMIT");
      return result;
    } catch (e) {
      try { await client.query("ROLLBACK"); } catch {}
      throw e;
    } finally {
      client.release();
    }
  } else {
    try {
      await db.query("BEGIN");
      const result = await run((q, p) => db.query(q, p));
      await db.query("COMMIT");
      return result;
    } catch (e) {
      try { await db.query("ROLLBACK"); } catch {}
      throw e;
    }
  }
}

/**
 * Run a DELETE that may reference a table/column your DB might not have.
 * - Skips cleanly if relation (42P01) or column (42703) is missing.
 * - Re-throws other errors.
 */
async function runOptional(queryFn, sql, params) {
  try {
    return await queryFn(sql, params);
  } catch (e) {
    // undefined_table OR undefined_column -> skip
    if (e && (e.code === "42P01" || e.code === "42703")) {
      console.warn("[hard-delete] skipped:", e.message);
      return { rows: [] };
    }
    throw e;
  }
}

/**
 * HARD DELETE a user and all related rows we know about.
 * Order matters when FKs exist without ON DELETE CASCADE.
 * Add/remove tables here as your schema evolves.
 */
async function hardDeleteUser(queryFn, userId) {
  // 1) BY PRODUCT ownership (delete child rows that point to products)
  // Orders for this user's products
  await runOptional(queryFn,
    `DELETE FROM orders o USING products p
      WHERE o.product_id = p.id AND p.user_id = $1`,
    [userId]
  );
  // Reviews for this user's products
  await runOptional(queryFn,
    `DELETE FROM reviews r USING products p
      WHERE r.product_id = p.id AND p.user_id = $1`,
    [userId]
  );

  // 2) BY USER direct relationships
  await runOptional(queryFn, `DELETE FROM reviews WHERE buyer_id = $1`, [userId]);
  await runOptional(queryFn, `DELETE FROM reviews WHERE creator_id = $1`, [userId]);
  await runOptional(queryFn, `DELETE FROM memberships WHERE user_id = $1`, [userId]);
  await runOptional(queryFn, `DELETE FROM memberships WHERE creator_id = $1`, [userId]);
  await runOptional(queryFn, `DELETE FROM requests WHERE buyer_id = $1`, [userId]);
  await runOptional(queryFn, `DELETE FROM requests WHERE seller_id = $1`, [userId]);
  await runOptional(queryFn, `DELETE FROM notifications WHERE user_id = $1`, [userId]);
  await runOptional(queryFn, `DELETE FROM notifications WHERE actor_id = $1`, [userId]);
  await runOptional(queryFn, `DELETE FROM posts WHERE user_id = $1`, [userId]);
  await runOptional(queryFn, `DELETE FROM downloads WHERE user_id = $1`, [userId]);
  await runOptional(queryFn, `DELETE FROM downloads WHERE buyer_id = $1`, [userId]);
  await runOptional(queryFn, `DELETE FROM messages WHERE sender_id = $1 OR recipient_id = $1`, [userId]);
  await runOptional(queryFn, `DELETE FROM orders WHERE buyer_id = $1`, [userId]);

  // 3) Creator-specific joins & resources
  await runOptional(queryFn, `DELETE FROM creator_categories WHERE creator_id = $1`, [userId]);
  await runOptional(queryFn, `DELETE FROM products WHERE user_id = $1`, [userId]);
  await runOptional(queryFn, `DELETE FROM creator_profiles WHERE user_id = $1`, [userId]);

  // 4) Finally the user
  const deleted = await queryFn(`DELETE FROM users WHERE id = $1 RETURNING id`, [userId]);
  if (!deleted.rows.length) {
    throw Object.assign(new Error("User not found"), { statusCode: 404 });
  }
}

/* ------------------------- USERS: list / search ------------------------- */
/**
 * GET /api/admin/users?query=&limit=20&offset=0&only_active=true&role=ALL|ADMIN|CREATOR|USER
 * - query matches email/username (ILIKE)
 */
router.get("/users", async (req, res) => {
  try {
    const q = (req.query.query || "").trim();
    const onlyActive = req.query.only_active === "true";
    const role = String(req.query.role || "ALL").toLowerCase(); // <-- NEW
    const limit = Math.min(parseInt(req.query.limit || "20", 10), 100);
    const offset = Math.max(parseInt(req.query.offset || "0", 10), 0);

    const conds = [];
    const params = [];
    if (q) {
      params.push(`%${q}%`, `%${q}%`);
      conds.push(`(email ILIKE $${params.length - 1} OR COALESCE(username,'') ILIKE $${params.length})`);
    }
    if (onlyActive) {
      params.push(true);
      conds.push(`is_active = $${params.length}`);
    }
    // role filter (admin|creator|user), case-insensitive
    if (["admin", "creator", "user"].includes(role)) {            // <-- NEW
      params.push(role);
      conds.push(`LOWER(role) = $${params.length}`);
    }

    params.push(limit, offset);

    const where = conds.length ? `WHERE ${conds.join(" AND ")}` : "";
    const sql = `
      SELECT id, email, username, role, is_active, email_verified_at, created_at
        FROM users
        ${where}
        ORDER BY created_at DESC
        LIMIT $${params.length - 1} OFFSET $${params.length}
    `;
    const { rows } = await db.query(sql, params);
    res.json({ users: rows });
  } catch (e) {
    console.error("admin GET /users error:", e);
    res.status(500).json({ error: "Failed to fetch users" });
  }
});

/* ----------------------- USERS: deactivate/reactivate ------------------- */
router.post("/users/:id/deactivate", async (req, res) => {
  try {
    const id = parseInt(req.params.id, 10);
    const { rows } = await db.query(
      `UPDATE users SET is_active=false WHERE id=$1 RETURNING id, is_active`,
      [id]
    );
    if (!rows.length) return res.status(404).json({ error: "User not found" });
    res.json({ success: true, user: rows[0] });
  } catch (e) {
    console.error("admin POST /users/:id/deactivate error:", e);
    res.status(500).json({ error: "Failed to deactivate user" });
  }
});

router.post("/users/:id/reactivate", async (req, res) => {
  try {
    const id = parseInt(req.params.id, 10);
    const { rows } = await db.query(
      `UPDATE users SET is_active=true WHERE id=$1 RETURNING id, is_active`,
      [id]
    );
    if (!rows.length) return res.status(404).json({ error: "User not found" });
    res.json({ success: true, user: rows[0] });
  } catch (e) {
    console.error("admin POST /users/:id/reactivate error:", e);
    res.status(500).json({ error: "Failed to reactivate user" });
  }
});

/* ----------------------------- HARD DELETE ------------------------------ */
/** DELETE /api/admin/users/:id (hard delete + dependents) */
router.delete("/users/:id", async (req, res) => {
  const userId = parseInt(req.params.id, 10);
  try {
    await withTx(async (q) => {
      await hardDeleteUser(q, userId);
    });
    res.json({ success: true, id: userId });
  } catch (e) {
    const status = e.statusCode || 500;
    console.error("admin DELETE /users/:id error:", e);
    res.status(status).json({ error: e.message || "Failed to hard-delete user" });
  }
});

/* -------------------------- CREATORS: list & remove --------------------- */
/**
 * GET /api/admin/creators?query=&only_active=true&limit=20&offset=0
 * Lists creators with role + featured flag.
 */
router.get("/creators", async (req, res) => {
  try {
    const q = (req.query.query || "").trim();
    const onlyActive = req.query.only_active === "true";
    const limit = Math.min(parseInt(req.query.limit || "20", 10), 100);
    const offset = Math.max(parseInt(req.query.offset || "0", 10), 0);

    const conds = [`u.role = 'creator'`];
    const params = [];
    if (q) {
      params.push(`%${q}%`, `%${q}%`, `%${q}%`);
      conds.push(
        `(u.email ILIKE $${params.length - 2} OR COALESCE(u.username,'') ILIKE $${params.length - 1} OR COALESCE(cp.display_name,'') ILIKE $${params.length})`
      );
    }
    if (onlyActive) {
      conds.push(`u.is_active = true AND cp.is_active = true`);
    }

    params.push(limit, offset);

    const where = `WHERE ${conds.join(" AND ")}`;
    const sql = `
      SELECT
        u.id,
        u.email,
        u.username,
        u.role,
        u.is_active AS user_active,
        cp.is_active AS creator_active,
        cp.is_featured,
        cp.display_name,
        cp.created_at,
        cp.updated_at
      FROM users u
      JOIN creator_profiles cp ON cp.user_id = u.id
      ${where}
      ORDER BY cp.created_at DESC
      LIMIT $${params.length - 1} OFFSET $${params.length}
    `;
    const { rows } = await db.query(sql, params);
    res.json({ creators: rows });
  } catch (e) {
    console.error("admin GET /creators error:", e);
    res.status(500).json({ error: "Failed to fetch creators" });
  }
});

/** DELETE /api/admin/creators/:id (hard delete creator + dependents) */
router.delete("/creators/:id", async (req, res) => {
  const creatorId = parseInt(req.params.id, 10);
  try {
    await withTx(async (q) => {
      await hardDeleteUser(q, creatorId);
    });
    res.json({ success: true, id: creatorId });
  } catch (e) {
    const status = e.statusCode || 500;
    console.error("admin DELETE /creators/:id error:", e);
    res.status(status).json({ error: e.message || "Failed to hard-delete creator" });
  }
});

/* ------------------------ FEATURE / UNFEATURE CREATORS ------------------ */
router.post("/creators/:id/feature", async (req, res) => {
  try {
    const creatorId = parseInt(req.params.id, 10);
    const { rows } = await db.query(
      `UPDATE creator_profiles SET is_featured=true WHERE user_id=$1 RETURNING user_id, is_featured`,
      [creatorId]
    );
    if (!rows.length) return res.status(404).json({ error: "Creator profile not found" });
    res.json({ success: true, profile: rows[0] });
  } catch (e) {
    console.error("admin POST /creators/:id/feature error:", e);
    res.status(500).json({ error: "Failed to feature creator" });
  }
});

// PATCH alias to match the Step-3 spec (keeps the same flow)
router.patch("/creators/:id/feature", async (req, res) => {
  try {
    const creatorId = parseInt(req.params.id, 10);
    const { rows } = await db.query(
      `UPDATE creator_profiles SET is_featured=true WHERE user_id=$1 RETURNING user_id, is_featured`,
      [creatorId]
    );
    if (!rows.length) return res.status(404).json({ error: "Creator profile not found" });
    res.json({ success: true, profile: rows[0] });
  } catch (e) {
    console.error("admin PATCH /creators/:id/feature error:", e);
    res.status(500).json({ error: "Failed to feature creator" });
  }
});

router.post("/creators/:id/unfeature", async (req, res) => {
  try {
    const creatorId = parseInt(req.params.id, 10);
    const { rows } = await db.query(
      `UPDATE creator_profiles SET is_featured=false WHERE user_id=$1 RETURNING user_id, is_featured`,
      [creatorId]
    );
    if (!rows.length) return res.status(404).json({ error: "Creator profile not found" });
    res.json({ success: true, profile: rows[0] });
  } catch (e) {
    console.error("admin POST /creators/:id/unfeature error:", e);
    res.status(500).json({ error: "Failed to unfeature creator" });
  }
});

/* --------------------------- REVIEWS: moderation ------------------------ */
router.get("/reviews", async (req, res) => {
  try {
    const { creator_id, product_id } = req.query;
    const includeHidden = req.query.include_hidden === "true";
    const limit = Math.min(parseInt(req.query.limit || "20", 10), 100);
    const offset = Math.max(parseInt(req.query.offset || "0", 10), 0);

    const conds = [];
    const params = [];
    if (creator_id) { params.push(parseInt(creator_id, 10)); conds.push(`r.creator_id = $${params.length}`); }
    if (product_id) { params.push(parseInt(product_id, 10)); conds.push(`r.product_id = $${params.length}`); }
    if (!includeHidden) conds.push(`r.hidden = false`);

    const where = conds.length ? `WHERE ${conds.join(" AND ")}` : "";
    params.push(limit, offset);

    const { rows } = await db.query(
      `SELECT r.id, r.product_id, r.creator_id, r.buyer_id, r.rating, r.comment, r.hidden, r.created_at
         FROM reviews r
        ${where}
        ORDER BY r.created_at DESC
        LIMIT $${params.length - 1} OFFSET $${params.length}`,
      params
    );
    res.json({ reviews: rows });
  } catch (e) {
    console.error("admin GET /reviews error:", e);
    res.status(500).json({ error: "Failed to fetch reviews" });
  }
});

router.post("/reviews/:id/hide", async (req, res) => {
  try {
    const id = parseInt(req.params.id, 10);
    const { rows } = await db.query(
      `UPDATE reviews SET hidden=true WHERE id=$1 RETURNING id, hidden`,
      [id]
    );
    if (!rows.length) return res.status(404).json({ error: "Review not found" });
    res.json({ success: true, review: rows[0] });
  } catch (e) {
    console.error("admin POST /reviews/:id/hide error:", e);
    res.status(500).json({ error: "Failed to hide review" });
  }
});

router.post("/reviews/:id/unhide", async (req, res) => {
  try {
    const id = parseInt(req.params.id, 10);
    const { rows } = await db.query(
      `UPDATE reviews SET hidden=false WHERE id=$1 RETURNING id, hidden`,
      [id]
    );
    if (!rows.length) return res.status(404).json({ error: "Review not found" });
    res.json({ success: true, review: rows[0] });
  } catch (e) {
    console.error("admin POST /reviews/:id/unhide error:", e);
    res.status(500).json({ error: "Failed to unhide review" });
  }
});

router.delete("/reviews/:id", async (req, res) => {
  try {
    const id = parseInt(req.params.id, 10);
    const { rows } = await db.query(
      `DELETE FROM reviews WHERE id=$1 RETURNING id`,
      [id]
    );
    if (!rows.length) return res.status(404).json({ error: "Review not found" });
    res.json({ success: true, id });
  } catch (e) {
    console.error("admin DELETE /reviews/:id error:", e);
    res.status(500).json({ error: "Failed to delete review" });
  }
});

/* ----------------------------- CATEGORIES CRUD -------------------------- */
router.get("/categories", async (_req, res) => {
  try {
    const { rows } = await db.query(
      `SELECT id, name, slug, active, created_at FROM categories ORDER BY name ASC`
    );
    res.json({ categories: rows });
  } catch (e) {
    console.error("admin GET /categories error:", e);
    res.status(500).json({ error: "Failed to fetch categories" });
  }
});

router.post("/categories", async (req, res) => {
  try {
    const { name, slug } = req.body || {};
    if (!name) return res.status(400).json({ error: "name required" });
    const { rows } = await db.query(
      `INSERT INTO categories (name, slug, active)
       VALUES ($1, COALESCE($2, NULL), TRUE)
       ON CONFLICT (slug) DO NOTHING
       RETURNING *`,
      [name, slug || null]
    );
    res.status(201).json({ category: rows[0] || null });
  } catch (e) {
    console.error("admin POST /categories error:", e);
    res.status(500).json({ error: "Failed to create category" });
  }
});

router.put("/categories/:id", async (req, res) => {
  try {
    const id = parseInt(req.params.id, 10);
    const { name, slug } = req.body || {};
    const { rows } = await db.query(
      `UPDATE categories
          SET name = COALESCE($1, name),
              slug = COALESCE($2, slug)
        WHERE id=$3
        RETURNING *`,
      [name ?? null, slug ?? null, id]
    );
    if (!rows.length) return res.status(404).json({ error: "Category not found" });
    res.json({ category: rows[0] });
  } catch (e) {
    console.error("admin PUT /categories/:id error:", e);
    res.status(500).json({ error: "Failed to update category" });
  }
});

/** HARD DELETE category + join rows */
router.delete("/categories/:id", async (req, res) => {
  const id = parseInt(req.params.id, 10);
  try {
    await withTx(async (q) => {
      await runOptional(q, `DELETE FROM creator_categories WHERE category_id=$1`, [id]);
      const del = await q(`DELETE FROM categories WHERE id=$1 RETURNING id`, [id]);
      if (!del.rows.length) throw Object.assign(new Error("Category not found"), { statusCode: 404 });
    });
    res.json({ success: true, id });
  } catch (e) {
    const status = e.statusCode || 500;
    console.error("admin DELETE /categories/:id error:", e);
    res.status(status).json({ error: e.message || "Failed to delete category" });
  }
});

/* -------------------------------- METRICS -------------------------------- */
router.get("/metrics", async (_req, res) => {
  try {
    const sql = `
      SELECT
        (SELECT COALESCE(SUM(amount_cents),0)/100.0 FROM orders WHERE status='paid') AS total_revenue,
        (SELECT COUNT(*) FROM memberships
          WHERE status IN ('active','trialing')
            AND current_period_end >= NOW()) AS active_members,
        (SELECT COUNT(DISTINCT p.user_id) FROM products p WHERE COALESCE(p.active,true)=true) AS active_creators,
        (SELECT COUNT(*) FROM users) AS total_users,
        (SELECT COUNT(*) FROM users WHERE role='creator') AS total_creators,
        (SELECT COUNT(*) FROM products) AS total_products
    `;
    const { rows } = await db.query(sql);
    res.json(rows[0]);
  } catch (e) {
    console.error("admin GET /metrics error:", e);
    res.status(500).json({ error: "Failed to fetch metrics" });
  }
});

module.exports = router;


===== FILE: sliptail-backend\routes\auth.js =====

const express = require("express");
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const crypto = require("crypto");
const db = require("../db");
const { enqueueAndSend } = require("../utils/emailQueue");
const { validate } = require("../middleware/validate");
const { authSignup, authLogin } = require("../validators/schemas");
const { strictLimiter } = require("../middleware/rateLimit");

const router = express.Router();

const {
  JWT_SECRET,
  APP_URL = "http://localhost:5000",
  FRONTEND_URL = "http://localhost:3000",
} = process.env;

const BASE_URL = APP_URL.replace(/\/$/, "");
const FRONTEND_BASE = FRONTEND_URL.replace(/\/$/, "");

// ---------- helpers ----------
function toSafeUser(u) {
  return {
    id: u.id,
    email: u.email,
    username: u.username,
    role: u.role,
    email_verified_at: u.email_verified_at,
    created_at: u.created_at,
  };
}

function issueJwt(user) {
  return jwt.sign(
    {
      id: user.id,
      email: user.email,
      role: user.role || "user",
      email_verified_at: user.email_verified_at,
    },
    JWT_SECRET,
    { expiresIn: "7d" }
  );
}

async function sendVerifyEmail(userId, email) {
  // Invalidate any prior unconsumed verify tokens
  await db.query(
    `UPDATE user_tokens
        SET consumed_at = NOW()
      WHERE user_id = $1 AND token_type = 'email_verify' AND consumed_at IS NULL`,
    [userId]
  );

  const token = crypto.randomBytes(32).toString("hex");
  const expires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24h
  await db.query(
    `INSERT INTO user_tokens (user_id, token, token_type, expires_at, created_at)
     VALUES ($1, $2, 'email_verify', $3, NOW())`,
    [userId, token, expires]
  );

  // Backend endpoint that will consume the token:
  const verifyUrl = `${BASE_URL}/api/auth/verify?token=${token}`;

  // IMPORTANT: your email_queue schema uses template + payload_json
  await enqueueAndSend({
    to: email,
    subject: "Verify your email",
    template: "verify_email",
    payload: { verify_url: verifyUrl },
  });
}

// ---------- routes ----------

/**
 * POST /api/auth/signup
 * Body: { email, password, username? }
 * Creates the user, sends verify email, DOES NOT issue JWT yet.
 */
router.post("/signup", strictLimiter, validate(authSignup), async (req, res) => {
  try {
    const { email, password, username } = req.body || {};
    if (!email || !password) {
      return res.status(400).json({ error: "email and password are required" });
    }
    const lower = String(email).toLowerCase();

    // must not exist
    const { rows: exists } = await db.query(
      `SELECT id FROM users WHERE email=$1 LIMIT 1`,
      [lower]
    );
    if (exists.length) {
      return res.status(409).json({ error: "Email already in use" });
    }

    const hash = await bcrypt.hash(password, 10);

    // IMPORTANT: write to password_hash (not "password")
    const { rows } = await db.query(
      `INSERT INTO users (email, password_hash, username, role, created_at)
       VALUES ($1, $2, $3, 'user', NOW())
       RETURNING *`,
      [lower, hash, username || null]
    );

    const user = rows[0];

    // Try to send verification email, but DO NOT fail signup if email queue/mailer crashes
    try {
      await sendVerifyEmail(user.id, user.email);
    } catch (e) {
      console.warn("verify email enqueue failed:", e?.message || e);
    }

    return res.status(202).json({ checkEmail: true });
  } catch (e) {
    console.error("signup error:", e);
    return res.status(500).json({ error: "Failed to sign up" });
  }
});

/**
 * POST /api/auth/verify/resend
 * Body: { email }
 * Resends a verify email if the account exists and is not verified.
 * Always returns success to avoid user enumeration.
 */
router.post("/verify/resend", strictLimiter, async (req, res) => {
  try {
    const { email } = req.body || {};
    if (!email) return res.status(400).json({ error: "Email is required" });
    const lower = String(email).toLowerCase();

    const { rows } = await db.query(
      `SELECT id, email_verified_at FROM users WHERE email=$1 LIMIT 1`,
      [lower]
    );
    if (rows.length && !rows[0].email_verified_at) {
      try {
        await sendVerifyEmail(rows[0].id, lower);
      } catch (e) {
        console.warn("resend verify enqueue failed:", e?.message || e);
      }
    }
    return res.json({ success: true });
  } catch (e) {
    console.error("resend verify error:", e);
    // still return success to avoid enumeration
    return res.json({ success: true });
  }
});

/**
 * GET /api/auth/verify?token=...
 * Consumes email verification token and marks user verified.
 * Redirects to FRONTEND_URL/​auth/verified for nice UX.
 */
router.get("/verify", async (req, res) => {
  const { token } = req.query || {};
  if (!token) return res.status(400).json({ error: "Missing token" });

  try {
    const { rows } = await db.query(
      `SELECT user_id
         FROM user_tokens
        WHERE token=$1
          AND token_type='email_verify'
          AND consumed_at IS NULL
          AND expires_at > NOW()
        LIMIT 1`,
      [token]
    );
    if (!rows.length) return res.status(400).json({ error: "Invalid or expired token" });

    const userId = rows[0].user_id;

    await db.query("BEGIN");
    // Mark user verified; keep both boolean and timestamp in sync if you use both
    await db.query(
      `UPDATE users
          SET email_verified = TRUE,
              email_verified_at = NOW()
        WHERE id = $1`,
      [userId]
    );
    await db.query(
      `UPDATE user_tokens
          SET consumed_at = NOW()
        WHERE token = $1`,
      [token]
    );
    await db.query("COMMIT");

    // Redirect to frontend "verified" page
    return res.redirect(`${FRONTEND_BASE}/auth/verified`);
  } catch (e) {
    await db.query("ROLLBACK").catch(() => {});
    console.error("verify error:", e);
    return res.status(500).json({ error: "Verification failed" });
  }
});

/**
 * POST /api/auth/login
 * Body: { email, password }
 * Requires email to be verified first.
 */
router.post("/login", strictLimiter, validate(authLogin), async (req, res) => {
  try {
    const { email, password } = req.body || {};
    if (!email || !password) {
      return res.status(400).json({ error: "email and password are required" });
    }
    const lower = String(email).toLowerCase();

    const { rows } = await db.query(
      `SELECT * FROM users WHERE email=$1 LIMIT 1`,
      [lower]
    );
    const user = rows[0];

    // Social-only or missing hash:
    if (!user || !user.password_hash) {
      return res.status(401).json({ error: "Invalid credentials" });
    }

    const ok = await bcrypt.compare(password, user.password_hash || "");
    if (!ok) return res.status(401).json({ error: "Invalid credentials" });

    // block unverified users
    if (!user.email_verified_at) {
      return res.status(403).json({ error: "Please verify your email to continue." });
    }

    const token = issueJwt(user);
    return res.json({ token, user: toSafeUser(user) });
  } catch (e) {
    console.error("login error:", e);
    return res.status(500).json({ error: "Failed to login" });
  }
});

/**
 * POST /api/auth/forgot
 * Body: { email }
 * Always responds success (prevents user enumeration)
 */
router.post("/forgot", strictLimiter, async (req, res) => {
  try {
    const { email } = req.body || {};
    if (!email) return res.status(400).json({ error: "Email is required" });
    const lower = String(email).toLowerCase();

    const { rows } = await db.query(`SELECT id FROM users WHERE email=$1 LIMIT 1`, [lower]);
    if (rows.length) {
      const userId = rows[0].id;

      // invalidate old tokens
      await db.query(
        `UPDATE user_tokens
            SET consumed_at = NOW()
          WHERE user_id=$1 AND token_type='password_reset' AND consumed_at IS NULL`,
        [userId]
      );

      const token = crypto.randomBytes(32).toString("hex");
      const expires = new Date(Date.now() + 60 * 60 * 1000); // 1h

      await db.query(
        `INSERT INTO user_tokens (user_id, token, token_type, expires_at, created_at)
         VALUES ($1, $2, 'password_reset', $3, NOW())`,
        [userId, token, expires]
      );

      // Queue reset email using template + payload (matches email_queue schema)
      try {
        await enqueueAndSend({
          to: lower,
          subject: "Reset your password",
          template: "reset_password",
          payload: { reset_url: `${FRONTEND_BASE}/reset-password?token=${token}` },
        });
      } catch (e) {
        console.warn("password reset email enqueue failed:", e?.message || e);
      }
    }

    return res.json({ success: true, message: "If this email exists, a reset link was sent." });
  } catch (e) {
    console.error("forgot error:", e);
    return res.status(500).json({ error: "Failed to process request" });
  }
});

/**
 * POST /api/auth/reset
 * Body: { token, password }
 * Consumes token and sets new password
 */
router.post("/reset", strictLimiter, async (req, res) => {
  try {
    const { token, password } = req.body || {};
    if (!token || !password) {
      return res.status(400).json({ error: "token and password are required" });
    }

    const { rows } = await db.query(
      `SELECT user_id, expires_at, consumed_at
         FROM user_tokens
        WHERE token=$1 AND token_type='password_reset'`,
      [token]
    );
    const t = rows[0];
    if (!t) return res.status(400).json({ error: "Invalid token" });
    if (t.consumed_at) return res.status(400).json({ error: "Token already used" });
    if (new Date(t.expires_at) < new Date()) return res.status(400).json({ error: "Token expired" });

    const hashed = await bcrypt.hash(password, 10);

    await db.query("BEGIN");
    // IMPORTANT: update password_hash
    await db.query(`UPDATE users SET password_hash=$1 WHERE id=$2`, [hashed, t.user_id]);
    await db.query(`UPDATE user_tokens SET consumed_at=NOW() WHERE token=$1`, [token]);
    await db.query("COMMIT");

    return res.json({ success: true, message: "Password updated" });
  } catch (e) {
    await db.query("ROLLBACK").catch(() => {});
    console.error("reset error:", e);
    return res.status(500).json({ error: "Failed to reset password" });
  }
});

// --- lightweight bearer auth just for /me ---
function authFromBearer(req, res, next) {
  try {
    const h = req.headers.authorization || "";
    if (!h.startsWith("Bearer ")) return res.status(401).json({ error: "Unauthorized" });
    const token = h.slice("Bearer ".length);
    const payload = jwt.verify(token, process.env.JWT_SECRET);
    req.user = payload;
    next();
  } catch (_) {
    return res.status(401).json({ error: "Unauthorized" });
  }
}

/**
 * GET /api/auth/me
 * Requires Authorization: Bearer <token>
 * Returns the safe user object so the client can populate auth state.
 */
router.get("/me", authFromBearer, async (req, res) => {
  const { id } = req.user || {};
  if (!id) return res.status(401).json({ error: "Unauthorized" });

  const { rows } = await db.query(
    `SELECT id, email, username, role, email_verified_at, created_at
       FROM users WHERE id=$1 LIMIT 1`,
    [id]
  );
  if (!rows.length) return res.status(404).json({ error: "Not found" });
  res.json({ user: rows[0] });
});

module.exports = router;

===== FILE: sliptail-backend\routes\authGoogle.js =====

const express = require("express");
const passport = require("passport");
const GoogleStrategy = require("passport-google-oauth20").Strategy;
const db = require("../db");
const jwt = require("jsonwebtoken");

const router = express.Router();

const {
  GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, GOOGLE_CALLBACK_URL, FRONTEND_URL, JWT_SECRET
} = process.env;

passport.use(new GoogleStrategy({
  clientID: GOOGLE_CLIENT_ID,
  clientSecret: GOOGLE_CLIENT_SECRET,
  callbackURL: GOOGLE_CALLBACK_URL
}, async (accessToken, refreshToken, profile, done) => {
  try {
    const googleId = profile.id;
    const email = profile.emails && profile.emails[0]?.value;
    const emailVerified = profile.emails && profile.emails[0]?.verified;

    if (!email) return done(null, false);

    // find or create user
    const { rows } = await db.query(`SELECT * FROM users WHERE google_id=$1 OR email=$2 LIMIT 1`, [googleId, email]);
    let user = rows[0];

    if (!user) {
      // create user with verified email (Google gives verified flag)
      const { rows: ins } = await db.query(
        `INSERT INTO users (email, google_id, username, email_verified_at, created_at)
         VALUES ($1,$2,$3,$4,NOW()) RETURNING *`,
        [email, googleId, profile.displayName || email.split("@")[0], emailVerified ? new Date() : null]
      );
      user = ins[0];
    } else if (!user.google_id) {
      // link google to existing account
      await db.query(`UPDATE users SET google_id=$1 WHERE id=$2`, [googleId, user.id]);
      if (emailVerified && !user.email_verified_at) {
        await db.query(`UPDATE users SET email_verified_at=NOW() WHERE id=$1`, [user.id]);
      }
    }

    return done(null, user);
  } catch (e) {
    return done(e);
  }
}));

router.get("/google/start", passport.authenticate("google", {
  scope: ["profile", "email"]
}));

router.get("/google/callback",
  passport.authenticate("google", { session: false, failureRedirect: (FRONTEND_URL || "/") }),
  async (req, res) => {
    const user = req.user;
    // issue your normal JWT
    const token = jwt.sign({ id: user.id, email: user.email }, JWT_SECRET, { expiresIn: "7d" });

    // redirect back to frontend with token in fragment or query
    const base = (FRONTEND_URL || "http://localhost:3000").replace(/\/$/,"");
    return res.redirect(`${base}/oauth-complete#token=${token}`);
  }
);

module.exports = router;

===== FILE: sliptail-backend\routes\authLogout.js =====

const express = require("express");
const router = express.Router();

router.post("/logout", (req, res) => {
  // Clear cookies (use same options as when they were set)
  res.clearCookie("auth", {
    httpOnly: true,
    sameSite: "lax",
    secure: process.env.NODE_ENV !== "development",
    path: "/", // important: match the original path
  });

  // If you also issue a "token" cookie, clear that too
  res.clearCookie("token", {
    httpOnly: true,
    sameSite: "lax",
    secure: process.env.NODE_ENV !== "development",
    path: "/",
  });

  // Tell the client logout succeeded
  res.json({ ok: true });
});

module.exports = router;

===== FILE: sliptail-backend\routes\authMe.js =====

const express = require("express");
const router = express.Router();
const { requireAuth } = require("../middleware/auth");
router.get("/me", requireAuth, (req, res) => res.json(req.user));
module.exports = router;

===== FILE: sliptail-backend\routes\categories.js =====

const express = require("express");
const db = require("../db");
const { requireAuth, requireAdmin } = require("../middleware/auth");

const router = express.Router();

/**
 * Public: list categories
 * - Default: active categories only
 * - With ?count=true: include creator counts (eligible creators only)
 */
router.get("/", async (req, res) => {
  const withCounts = String(req.query.count || "").toLowerCase() === "true";

  try {
    if (!withCounts) {
      // plain categories (current flow)
      const { rows } = await db.query(
        `SELECT id, name, slug
           FROM categories
          WHERE active = TRUE
          ORDER BY name ASC`
      );
      return res.json({ categories: rows });
    }

    // with creator counts
    const { rows } = await db.query(
      `
      SELECT
        c.id,
        c.name,
        c.slug,
        COUNT(DISTINCT cp.user_id)::int AS creators_count
      FROM categories c
      LEFT JOIN creator_categories cc ON cc.category_id = c.id
      LEFT JOIN creator_profiles cp    ON cp.user_id     = cc.creator_id
      LEFT JOIN users u                ON u.id           = cp.user_id
      LEFT JOIN products p             ON p.user_id      = cp.user_id AND p.active = TRUE
      WHERE c.active = TRUE
        AND (cp.user_id IS NULL
             OR (u.enabled = TRUE
                 AND u.role = 'creator'
                 AND cp.is_profile_complete = TRUE
                 AND cp.is_active = TRUE))
      GROUP BY c.id, c.name, c.slug
      ORDER BY c.name ASC
      `
    );
    res.json({ categories: rows });
  } catch (e) {
    console.error("list categories error:", e);
    res.status(500).json({ error: "Failed to fetch categories" });
  }
});

/**
 * Admin: create category
 * Body: { name, slug }
 */
router.post("/", requireAuth, requireAdmin, async (req, res) => {
  const { name, slug } = req.body || {};
  try {
    const { rows } = await db.query(
      `INSERT INTO categories (name, slug, active)
       VALUES ($1, $2, TRUE)
       RETURNING *`,
      [name, slug]
    );
    res.status(201).json({ category: rows[0] });
  } catch (e) {
    console.error("create category error:", e);
    res.status(500).json({ error: "Failed to create category" });
  }
});

/**
 * Admin: update category (rename, toggle active)
 * Body: { name?, slug?, active? }
 */
router.patch("/:id", requireAuth, requireAdmin, async (req, res) => {
  const id = parseInt(req.params.id, 10);
  const { name, slug, active } = req.body || {};
  try {
    const { rows } = await db.query(
      `UPDATE categories
          SET name = COALESCE($1, name),
              slug = COALESCE($2, slug),
              active = COALESCE($3, active)
        WHERE id=$4
        RETURNING *`,
      [name ?? null, slug ?? null, typeof active === "boolean" ? active : null, id]
    );
    if (!rows.length) return res.status(404).json({ error: "Category not found" });
    res.json({ category: rows[0] });
  } catch (e) {
    console.error("update category error:", e);
    res.status(500).json({ error: "Failed to update category" });
  }
});

module.exports = router;

===== FILE: sliptail-backend\routes\checkout.js =====

// backend/routes/checkout.js
const express = require("express");
const Stripe = require("stripe");
const db = require("../db");
const { requireAuth } = require("../middleware/auth");

const router = express.Router();
const stripe = Stripe(process.env.STRIPE_SECRET_KEY);

// Prefer FRONTEND_URL; fall back to APP_URL; default to local Next dev URL
const FRONTEND_BASE = (
  process.env.FRONTEND_URL ||
  process.env.APP_URL ||
  "http://localhost:3000"
).replace(/\/$/, "");

/**
 * POST /api/checkout/session
 * Body: { product_id|productId, product_type|productType, quantity? }
 * Returns: { url }
 */
router.post("/session", requireAuth, async (req, res) => {
  const {
    product_id,
    productId,
    product_type,
    productType,
    quantity,
  } = req.body || {};

  const pid = parseInt(product_id || productId, 10);
  if (!pid) return res.status(400).json({ error: "product_id is required" });

  const qty = Math.max(1, parseInt(quantity || "1", 10));

  try {
    const { rows } = await db.query(
      `SELECT p.id,
              p.user_id              AS creator_id,
              p.title,
              p.description,
              p.product_type,
              p.price,
              u.email                AS creator_email,
              u.stripe_account_id    AS creator_stripe_account
         FROM products p
         JOIN users u ON u.id = p.user_id
        WHERE p.id=$1 AND p.active = TRUE
        LIMIT 1`,
      [pid]
    );
    if (!rows.length) return res.status(404).json({ error: "Product not found" });

    const prod = rows[0];
    const mode =
      (product_type || productType || prod.product_type) === "membership"
        ? "subscription"
        : "payment";

    const lineItem = {
      quantity: qty,
      price_data: {
        currency: "usd",
        unit_amount: Number(prod.price) || 0,
        product_data: {
          name: prod.title,
          description: prod.description || undefined,
        },
      },
    };
    if (mode === "subscription") {
      lineItem.price_data.recurring = { interval: "month" };
    }

    const success_url = `${FRONTEND_BASE}/purchases/success?session_id={CHECKOUT_SESSION_ID}`;
    const cancel_url = `${FRONTEND_BASE}/creators/${prod.creator_id}?canceled=1`;

    const sessionParams = {
      mode,
      line_items: [lineItem],
      success_url,
      cancel_url,
      customer_email: req.user.email, // prefill with the signed-in user's email
      allow_promotion_codes: true,
      billing_address_collection: "auto",
    };

    // If using Stripe Connect to pay creators:
    if (prod.creator_stripe_account) {
      // Example 10% platform fee:
      const fee = Math.round((Number(prod.price) || 0) * 0.04);
      if (mode === "payment") {
        sessionParams.payment_intent_data = {
          application_fee_amount: fee,
          transfer_data: { destination: prod.creator_stripe_account },
        };
      } else {
        sessionParams.subscription_data = {
          application_fee_percent: 4,
          transfer_data: { destination: prod.creator_stripe_account },
        };
      }
    }

    const session = await stripe.checkout.sessions.create(sessionParams);
    return res.json({ url: session.url });
  } catch (e) {
    console.error("create checkout session error:", e);
    return res.status(500).json({ error: "Failed to start checkout" });
  }
});

module.exports = router;


===== FILE: sliptail-backend\routes\creator.js =====

const express = require("express");
const router = express.Router();
const db = require("../db");
const { requireAuth } = require("../middleware/auth");

// Simple, fast status: creator if they have ANY product (or any active product)
router.get("/status", requireAuth, async (req, res) => {
  try {
    const userId = req.user.id;
    const { rows } = await db.query(
      `SELECT
         EXISTS(SELECT 1 FROM products WHERE user_id=$1)       AS has_any,
         EXISTS(SELECT 1 FROM products WHERE user_id=$1 AND active=TRUE) AS has_active`,
      [userId]
    );
    const hasAny = rows[0]?.has_any === true || rows[0]?.has_any === "t";
    const hasActive = rows[0]?.has_active === true || rows[0]?.has_active === "t";
    // "active" means they’re a creator for nav purposes
    res.json({ active: hasAny || hasActive });
  } catch (e) {
    console.error("creator status error:", e);
    // Don’t break the UI — default to false
    res.status(200).json({ active: false });
  }
});

module.exports = router;

===== FILE: sliptail-backend\routes\creatorDashboard.js =====

// routes/creatorDashboard.js
const express = require("express");
const db = require("../db");
const { requireAuth, requireCreator } = require("../middleware/auth");

const router = express.Router();

/**
 * GET /api/creator/dashboard/summary
 * Fast counters for the creator's dashboard.
 *
 * Returns:
 * {
 *   products_count,
 *   sales_count,
 *   sales_gross_cents,
 *   sales_last_30d_cents,
 *   requests_pending_count,
 *   requests_delivered_7d_count,
 *   members_active_count,
 *   reviews_avg,
 *   reviews_count
 * }
 */
router.get("/summary", requireAuth, requireCreator, async (req, res) => {
  const creatorId = req.user.id;

  try {
    // products created by me
    const { rows: products } = await db.query(
      `SELECT COUNT(*)::int AS products_count
         FROM products
        WHERE user_id = $1`,
      [creatorId]
    );

    // one-time purchase sales (orders join my products)
    const { rows: sales } = await db.query(
      `SELECT
         COUNT(o.id)::int                       AS sales_count,
         COALESCE(SUM(o.amount),0)::bigint      AS sales_gross_cents,
         COALESCE(SUM(CASE WHEN o.created_at >= NOW() - INTERVAL '30 days' THEN o.amount ELSE 0 END),0)::bigint AS sales_last_30d_cents
       FROM orders o
       JOIN products p ON p.id = o.product_id
      WHERE p.user_id = $1
        AND o.status = 'paid'`,
      [creatorId]
    );

    // requests: how many are pending for me; how many delivered in last 7 days
    const { rows: reqs } = await db.query(
      `SELECT
         COALESCE(SUM(CASE WHEN cr.status = 'pending' THEN 1 ELSE 0 END),0)::int AS requests_pending_count,
         COALESCE(SUM(CASE WHEN cr.status = 'delivered' AND cr.created_at >= NOW() - INTERVAL '7 days' THEN 1 ELSE 0 END),0)::int AS requests_delivered_7d_count
       FROM custom_requests cr
      WHERE cr.creator_id = $1`,
      [creatorId]
    );

    // active memberships (buyer has access now)
    const { rows: members } = await db.query(
      `SELECT COUNT(*)::int AS members_active_count
         FROM memberships m
        WHERE m.creator_id = $1
          AND m.status IN ('active','trialing')
          AND NOW() <= m.current_period_end`,
      [creatorId]
    );

    // reviews: avg + count for me
    const { rows: reviews } = await db.query(
      `SELECT
         COALESCE(AVG(r.rating), 0)::numeric(3,2) AS reviews_avg,
         COUNT(r.id)::int                          AS reviews_count
       FROM reviews r
      WHERE r.creator_id = $1`,
      [creatorId]
    );

    res.json({
      ...products[0],
      ...sales[0],
      ...reqs[0],
      ...members[0],
      ...reviews[0],
    });
  } catch (e) {
    console.error("creator summary error:", e);
    res.status(500).json({ error: "Failed to fetch creator summary" });
  }
});

/**
 * GET /api/creator/dashboard/earnings?range=30d
 * Daily earnings (paid orders of my products) for a simple chart.
 * range supports '7d' | '30d' | '90d' | '365d' (default 30d)
 */
router.get("/earnings", requireAuth, requireCreator, async (req, res) => {
  const creatorId = req.user.id;
  const range = (req.query.range || "30d").toLowerCase();
  const map = { "7d": "7 days", "30d": "30 days", "90d": "90 days", "365d": "365 days" };
  const interval = map[range] || map["30d"];

  try {
    // group by day in server timezone; sum order amounts for PAID orders on my products
    const { rows } = await db.query(
      `SELECT
         to_char(date_trunc('day', o.created_at), 'YYYY-MM-DD') AS day,
         COALESCE(SUM(o.amount),0)::bigint AS amount_cents
       FROM orders o
       JOIN products p ON p.id = o.product_id
      WHERE p.user_id = $1
        AND o.status = 'paid'
        AND o.created_at >= NOW() - INTERVAL '${interval}'
      GROUP BY 1
      ORDER BY 1`,
      [creatorId]
    );

    res.json({ range, points: rows });
  } catch (e) {
    console.error("creator earnings error:", e);
    res.status(500).json({ error: "Failed to fetch earnings" });
  }
});

module.exports = router;

===== FILE: sliptail-backend\routes\creators.js =====

const express = require("express");
const db = require("../db");
const { requireAuth, requireAdmin } = require("../middleware/auth");
const { recomputeCreatorActive } = require("../services/creatorStatus");
const jwt = require("jsonwebtoken");

// media upload deps
const multer = require("multer");
const path = require("path");
const fs = require("fs");

const router = express.Router();

/* -------------------------------- helpers -------------------------------- */

function toSafeUser(u) {
  return {
    id: u.id,
    email: u.email,
    username: u.username,
    role: u.role,
    email_verified_at: u.email_verified_at,
    created_at: u.created_at,
  };
}
function issueJwtFromUserRow(u) {
  return jwt.sign(
    {
      id: u.id,
      email: u.email,
      role: u.role || "user",
      email_verified_at: u.email_verified_at,
    },
    process.env.JWT_SECRET,
    { expiresIn: "7d" }
  );
}

// Build a public URL (relative path under /uploads) from an absolute file path.
function toPublicUrl(absPath) {
  const marker = `${path.sep}uploads${path.sep}`;
  const idx = absPath.lastIndexOf(marker);
  if (idx === -1) return null;
  const rel = absPath.slice(idx).replace(/\\/g, "/");
  return `/${rel}`;
}

// column-existence helper (so we can handle missing categories.slug, users.enabled)
async function hasColumn(table, column) {
  const { rows } = await db.query(
    `SELECT 1 FROM information_schema.columns
     WHERE table_schema='public' AND table_name=$1 AND column_name=$2
     LIMIT 1`,
    [table, column]
  );
  return rows.length > 0;
}

// Build a safe users.enabled clause (no-op if column missing)
async function usersEnabledClause() {
  const has = await hasColumn("users", "enabled");
  return has ? "u.enabled = TRUE" : "TRUE";
}

/* --------------------------- media upload setup --------------------------- */

const creatorUploadRoot = path.join(__dirname, "..", "public", "uploads", "creators");
if (!fs.existsSync(creatorUploadRoot)) {
  fs.mkdirSync(creatorUploadRoot, { recursive: true });
}
const imageMimes = new Set(["image/png", "image/jpeg", "image/webp", "image/gif"]);

const creatorStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const userId = req.user?.id || "unknown";
    const userDir = path.join(creatorUploadRoot, String(userId));
    if (!fs.existsSync(userDir)) fs.mkdirSync(userDir, { recursive: true });
    cb(null, userDir);
  },
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname || "").toLowerCase();
    const base = `${Date.now()}-${Math.random().toString(36).slice(2)}`;
    cb(null, `${base}${ext || ".jpg"}`);
  },
});

const uploadCreatorMedia = multer({
  storage: creatorStorage,
  limits: { fileSize: 15 * 1024 * 1024 }, // 15MB per file
  fileFilter: (req, file, cb) => {
    if (!imageMimes.has(file.mimetype)) return cb(new Error("Only image files are allowed"));
    cb(null, true);
  },
});

// Lightweight single-file uploader (reuse same storage & filter)
const uploadSingleImage = multer({
  storage: creatorStorage,
  limits: { fileSize: 15 * 1024 * 1024 },
  fileFilter: (req, file, cb) => {
    if (!imageMimes.has(file.mimetype)) return cb(new Error("Only image files are allowed"));
    cb(null, true);
  },
});

/* --------------------------------- routes -------------------------------- */

/**
 * LEGACY: immediately set role=creator.
 */
router.post("/become", requireAuth, async (req, res) => {
  const userId = req.user.id;

  try {
    await db.query("BEGIN");

    await db.query(
      `UPDATE users SET role='creator'
         WHERE id=$1 AND (role IS NULL OR role <> 'creator')`,
      [userId]
    );

    const { rows } = await db.query(`SELECT * FROM users WHERE id=$1 LIMIT 1`, [userId]);
    if (!rows.length) {
      await db.query("ROLLBACK");
      return res.status(404).json({ error: "User not found" });
    }

    const user = rows[0];
    const token = issueJwtFromUserRow(user);
    await db.query("COMMIT");

    res.cookie("token", token, {
      httpOnly: true,
      sameSite: "lax",
      secure: process.env.NODE_ENV !== "development",
      maxAge: 7 * 24 * 60 * 60 * 1000,
      path: "/",
    });

    return res.json({ success: true, creator_id: userId, token, user: toSafeUser(user) });
  } catch (e) {
    await db.query("ROLLBACK").catch(() => {});
    console.error("become creator error:", e);
    return res.status(500).json({ error: "Failed to become a creator" });
  }
});

/**
 * Activate creator role only if truly ready.
 */
router.post("/activate", requireAuth, async (req, res) => {
  const userId = req.user.id;

  try {
    const status = await recomputeCreatorActive(db, userId);

    const missing = [];
    if (!status?.profileComplete) missing.push("Complete your profile");
    if (!status?.stripeConnected) missing.push("Connect your Stripe account");
    if (!status?.hasPublishedProduct) missing.push("Publish at least one product");

    if (missing.length) {
      return res.status(400).json({ success: false, missing });
    }

    await db.query("BEGIN");

    await db.query(
      `UPDATE users SET role='creator'
         WHERE id=$1 AND (role IS NULL OR role <> 'creator')`,
      [userId]
    );

    const { rows } = await db.query(`SELECT * FROM users WHERE id=$1 LIMIT 1`, [userId]);
    if (!rows.length) {
      await db.query("ROLLBACK");
      return res.status(404).json({ error: "User not found" });
    }

    const user = rows[0];
    const token = issueJwtFromUserRow(user);

    await db.query("COMMIT");

    res.cookie("token", token, {
      httpOnly: true,
      sameSite: "lax",
      secure: process.env.NODE_ENV !== "development",
      maxAge: 7 * 24 * 60 * 60 * 1000,
      path: "/",
    });

    return res.json({ success: true, token, user: toSafeUser(user) });
  } catch (e) {
    try { await db.query("ROLLBACK"); } catch {}
    console.error("activate error:", e);
    return res.status(500).json({ error: "Failed to activate creator" });
  }
});

/**
 * Upload my creator media (profile image + 4 gallery photos)
 */
router.post(
  "/me/media",
  requireAuth,
  uploadCreatorMedia.fields([
    { name: "profile_image", maxCount: 1 },
    { name: "gallery", maxCount: 4 },
  ]),
  async (req, res) => {
    const userId = req.user.id;

    try {
      const prof = req.files?.profile_image?.[0] || null;
      const gal = Array.isArray(req.files?.gallery) ? req.files.gallery : [];

      if (!prof) return res.status(400).json({ error: "profile_image is required" });
      if (gal.length !== 4) return res.status(400).json({ error: "Exactly 4 gallery photos are required" });

      const profilePublic = toPublicUrl(prof.path);
      const galleryPublic = gal.map((f) => toPublicUrl(f.path)).filter(Boolean);

      if (!profilePublic || galleryPublic.length !== 4) {
        return res.status(500).json({ error: "Failed to generate public URLs" });
      }

      await db.query("BEGIN");

      await db.query(
        `INSERT INTO creator_profiles (user_id, display_name, bio, profile_image, featured, created_at, updated_at)
         VALUES ($1, NULL, NULL, $2, FALSE, NOW(), NOW())
         ON CONFLICT (user_id) DO UPDATE
           SET profile_image = EXCLUDED.profile_image,
               updated_at = NOW()`,
        [userId, profilePublic]
      );

      await db.query(`DELETE FROM creator_profile_photos WHERE user_id=$1`, [userId]);
      const values = galleryPublic.map((_, i) => `($1,$${i + 2},$${i + 6})`).join(",");
      const params = [userId, ...galleryPublic, ...[1, 2, 3, 4]];
      await db.query(
        `INSERT INTO creator_profile_photos (user_id, url, position) VALUES ${values}`,
        params
      );

      await db.query("COMMIT");

      res.json({ profile_image: profilePublic, gallery: galleryPublic });
    } catch (e) {
      try { await db.query("ROLLBACK"); } catch {}
      console.error("creator media upload error:", e);
      res.status(500).json({ error: "Failed to upload creator media" });
    }
  }
);

/**
 * Upsert MY creator profile (multipart or JSON)
 */
router.post(
  "/me",
  requireAuth,
  (req, res, next) => {
    const ct = req.headers["content-type"] || "";
    if (ct.startsWith("multipart/form-data")) {
      return uploadCreatorMedia.fields([
        { name: "profile_image", maxCount: 1 },
        { name: "gallery", maxCount: 4 },
      ])(req, res, next);
    }
    return next();
  },
  async (req, res) => {
    const userId = req.user.id;
    const isMultipart = !!req.files;

    try {
      let display_name = (req.body?.display_name || "").trim();
      let bio = (req.body?.bio || "").trim();

      if (!display_name || !bio) {
        return res.status(400).json({ error: "display_name and bio are required" });
      }

      let profile_image_url = null;
      let gallery_urls = null;

      if (isMultipart) {
        const prof = req.files?.profile_image?.[0] || null;
        const gal = Array.isArray(req.files?.gallery) ? req.files.gallery : [];

        if (!prof) return res.status(400).json({ error: "profile_image is required" });
        if (gal.length !== 4) return res.status(400).json({ error: "Exactly 4 gallery photos are required" });

        profile_image_url = toPublicUrl(prof.path);
        gallery_urls = gal.map((f) => toPublicUrl(f.path)).filter(Boolean);

        if (!profile_image_url || gallery_urls.length !== 4) {
          return res.status(500).json({ error: "Failed to generate public URLs" });
        }
      } else {
        profile_image_url = req.body?.profile_image || null;
        const gallery = Array.isArray(req.body?.gallery) ? req.body.gallery : null;
        gallery_urls = gallery ? gallery.slice(0, 4).filter(Boolean) : null;
      }

      await db.query("BEGIN");

      const { rows: profRows } = await db.query(
        `INSERT INTO creator_profiles (user_id, display_name, bio, profile_image, featured, is_profile_complete, created_at, updated_at)
         VALUES ($1,$2,$3,$4,false, TRUE, NOW(), NOW())
         ON CONFLICT (user_id) DO UPDATE
           SET display_name        = COALESCE(EXCLUDED.display_name, creator_profiles.display_name),
               bio                 = COALESCE(EXCLUDED.bio,          creator_profiles.bio),
               profile_image       = COALESCE(EXCLUDED.profile_image,creator_profiles.profile_image),
               is_profile_complete = TRUE,
               updated_at          = NOW()
         RETURNING user_id, display_name, bio, profile_image, featured, is_profile_complete`,
        [userId, display_name || null, bio || null, profile_image_url || null]
      );

      if (gallery_urls) {
        await db.query(`DELETE FROM creator_profile_photos WHERE user_id=$1`, [userId]);

        if (gallery_urls.length) {
          const values = gallery_urls.map((_, i) => `($1,$${i + 2},$${i + 2 + gallery_urls.length})`).join(",");
          const params = [userId, ...gallery_urls, ...gallery_urls.map((_, i) => i + 1)];
          await db.query(
            `INSERT INTO creator_profile_photos (user_id, url, position) VALUES ${values}`,
            params
          );
        }
      }

      const { rows: galleryRows } = await db.query(
        `SELECT ARRAY_AGG(url ORDER BY position) AS gallery
           FROM creator_profile_photos WHERE user_id=$1`,
        [userId]
      );

      await db.query("COMMIT");

      const status = await recomputeCreatorActive(db, userId);

      return res.json({
        profile: {
          ...profRows[0],
          gallery: galleryRows?.[0]?.gallery || [],
        },
        creator_status: status,
      });
    } catch (e) {
      try { await db.query("ROLLBACK"); } catch {}
      console.error("creator profile save error:", e);
      return res.status(500).json({ error: "Failed to save profile" });
    }
  }
);

/**
 * GET my (raw) creator profile (no eligibility gating) + gallery
 */
router.get("/me", requireAuth, async (req, res) => {
  const userId = req.user.id;
  try {
    const { rows: prof } = await db.query(
      `SELECT user_id, display_name, bio, profile_image, featured, is_profile_complete, is_active
         FROM creator_profiles WHERE user_id=$1 LIMIT 1`,
      [userId]
    );
    const profile = prof[0] || null;

    const { rows: photos } = await db.query(
      `SELECT url, position FROM creator_profile_photos WHERE user_id=$1 ORDER BY position ASC`,
      [userId]
    );
    const gallery = photos.map((p) => p.url).slice(0, 4);

    return res.json({
      user_id: userId,
      display_name: profile?.display_name || null,
      bio: profile?.bio || null,
      profile_image: profile?.profile_image || null,
      featured: profile?.featured || false,
      is_profile_complete: profile?.is_profile_complete || false,
      is_active: profile?.is_active || false,
      gallery,
    });
  } catch (e) {
    console.error("get my creator profile error:", e);
    return res.status(500).json({ error: "Failed to load profile" });
  }
});

/**
 * PATCH: Update ONLY my profile image (single file)
 */
router.patch(
  "/me/profile-image",
  requireAuth,
  uploadSingleImage.single("profile_image"),
  async (req, res) => {
    const userId = req.user.id;
    try {
      if (!req.file) return res.status(400).json({ error: "profile_image file is required" });
      const url = toPublicUrl(req.file.path);
      if (!url) return res.status(500).json({ error: "Failed to store image" });
      // Try UPDATE first (schema-aware update of updated_at if column exists)
      const hasUpdatedAt = await hasColumn("creator_profiles", "updated_at").catch(() => false);
      const updateSets = ["profile_image=$2"]; // base set
      if (hasUpdatedAt) updateSets.push("updated_at=NOW()");
      const updateSql = `UPDATE creator_profiles SET ${updateSets.join(",")} WHERE user_id=$1`;
      const upd = await db.query(updateSql, [userId, url]);

      if (upd.rowCount === 0) {
        // Need to INSERT minimal row (schema-aware for optional columns)
        const cols = ["user_id", "profile_image"]; // mandatory
        const vals = ["$1", "$2"]; // placeholders
        const params = [userId, url];
        const optionalCols = [
          { name: "featured", value: "FALSE" },
          { name: "is_profile_complete", value: "FALSE" },
          { name: "created_at", value: "NOW()" },
          { name: "updated_at", value: "NOW()" },
        ];
        for (const oc of optionalCols) {
          // eslint-disable-next-line no-await-in-loop
          const exists = await hasColumn("creator_profiles", oc.name).catch(() => false);
            if (exists) {
              cols.push(oc.name);
              vals.push(oc.value);
            }
        }
        const insertSql = `INSERT INTO creator_profiles (${cols.join(",")}) VALUES (${vals.join(",")})`;
        await db.query(insertSql, params);
      }
      return res.json({ profile_image: url });
    } catch (e) {
      console.error("update profile image error:", e);
      return res.status(500).json({ error: "Failed to update profile image" });
    }
  }
);

/**
 * PATCH: Replace ONE gallery photo by position (1-4)
 * Field name: photo
 */
router.patch(
  "/me/gallery/:position",
  requireAuth,
  uploadSingleImage.single("photo"),
  async (req, res) => {
    const userId = req.user.id;
    const pos = parseInt(req.params.position, 10);
    if (Number.isNaN(pos) || pos < 1 || pos > 4) {
      return res.status(400).json({ error: "position must be 1-4" });
    }
    try {
      if (!req.file) return res.status(400).json({ error: "photo file is required" });
      const url = toPublicUrl(req.file.path);
      if (!url) return res.status(500).json({ error: "Failed to store image" });
      // Ensure profile row exists (schema-aware minimal insert)
      const { rows: existing } = await db.query(
        `SELECT 1 FROM creator_profiles WHERE user_id=$1 LIMIT 1`,
        [userId]
      );
      if (!existing.length) {
        const cols = ["user_id"]; const vals = ["$1"]; const params = [userId];
        const optionalCols = [
          { name: "is_active", value: "FALSE" },
          { name: "featured", value: "FALSE" },
          { name: "is_profile_complete", value: "FALSE" },
          { name: "created_at", value: "NOW()" },
          { name: "updated_at", value: "NOW()" },
        ];
        for (const oc of optionalCols) {
          // eslint-disable-next-line no-await-in-loop
          const exists = await hasColumn("creator_profiles", oc.name).catch(() => false);
          if (exists) { cols.push(oc.name); vals.push(oc.value); }
        }
        const insertSql = `INSERT INTO creator_profiles (${cols.join(",")}) VALUES (${vals.join(",")})`;
        await db.query(insertSql, params);
      }

      await db.query(`DELETE FROM creator_profile_photos WHERE user_id=$1 AND position=$2`, [userId, pos]);
      await db.query(
        `INSERT INTO creator_profile_photos (user_id, url, position) VALUES ($1,$2,$3)`,
        [userId, url, pos]
      );

      const { rows: photos } = await db.query(
        `SELECT url, position FROM creator_profile_photos WHERE user_id=$1 ORDER BY position`,
        [userId]
      );
      const gallery = photos.map((p) => p.url).slice(0, 4);
      return res.json({ position: pos, url, gallery });
    } catch (e) {
      console.error("update gallery photo error:", e);
      return res.status(500).json({ error: "Failed to update gallery photo" });
    }
  }
);

/**
 * PUBLIC: Get a creator profile (gated/eligible)
 */
router.get("/:creatorId", async (req, res) => {
  const creatorId = parseInt(req.params.creatorId, 10);

  try {
    const enabledClause = await usersEnabledClause();

    const { rows } = await db.query(
      `
      SELECT
        cp.user_id,
        cp.display_name,
        cp.bio,
        cp.profile_image,
        cp.featured,
        COALESCE(AVG(r.rating),0)::numeric(3,2) AS average_rating,
        COUNT(DISTINCT p.id)::int               AS products_count
      FROM creator_profiles cp
      JOIN users u
        ON u.id = cp.user_id
      LEFT JOIN reviews  r
        ON r.creator_id = cp.user_id
      LEFT JOIN products p
        ON p.user_id = cp.user_id
       AND p.active  = TRUE
      WHERE cp.user_id = $1
        AND ${enabledClause}
        AND u.role = 'creator'
        AND cp.is_profile_complete = TRUE
        AND cp.is_active = TRUE
      GROUP BY cp.user_id, cp.display_name, cp.bio, cp.profile_image, cp.featured
      HAVING COUNT(DISTINCT p.id) > 0
      `,
      [creatorId]
    );

    if (!rows.length) return res.status(404).json({ error: "Creator profile not found or not eligible" });

    const base = rows[0];

    const { rows: cats } = await db.query(
      `SELECT c.name
         FROM creator_categories cc
         JOIN categories c ON c.id = cc.category_id
        WHERE cc.creator_id = $1
        ORDER BY c.name ASC`,
      [creatorId]
    );
    const categories = cats.map((c) => c.name);

    const { rows: photos } = await db.query(
      `SELECT ARRAY_AGG(url ORDER BY position) AS gallery
         FROM creator_profile_photos WHERE user_id=$1`,
      [creatorId]
    );

    res.json({
      ...base,
      categories,
      gallery: photos?.[0]?.gallery || [],
    });
  } catch (e) {
    console.error("public profile error:", e);
    res.status(500).json({ error: "Failed to fetch profile" });
  }
});

/**
 * Update my creator profile + categories (admin or self)
 */
router.put("/:creatorId", requireAuth, async (req, res) => {
  const creatorId = parseInt(req.params.creatorId, 10);
  if (Number.isNaN(creatorId)) return res.status(400).json({ error: "Invalid id" });

  const isAdmin = req.user?.role === "admin";
  if (!isAdmin && req.user?.id !== creatorId) {
    return res.status(403).json({ error: "Forbidden" });
  }

  const display_name = typeof req.body.display_name === "string" ? req.body.display_name.trim() : null;
  const bio = typeof req.body.bio === "string" ? req.body.bio.trim() : null;

  const rawCats = Array.isArray(req.body.categories) ? req.body.categories : null;
  const toLower = (s) => String(s || "").trim().toLowerCase();
  const parseCategoryInput = (arr) => {
    const names = [];
    const ids = [];
    for (const it of arr) {
      if (typeof it === "string") names.push(it.trim());
      else if (typeof it === "number") ids.push(it);
      else if (it && typeof it === "object") {
        if (typeof it.id === "number") ids.push(it.id);
        else if (typeof it.name === "string") names.push(it.name.trim());
      }
    }
    return { names, ids };
  };

  try {
    await db.query("BEGIN");

    if (display_name !== null || bio !== null) {
      const { rowCount } = await db.query(
        `UPDATE creator_profiles
            SET display_name = COALESCE($1, display_name),
                bio          = COALESCE($2, bio),
                updated_at   = NOW()
          WHERE user_id = $3`,
        [display_name, bio, creatorId]
      );

      if (rowCount === 0) {
        await db.query(
          `INSERT INTO creator_profiles (user_id, display_name, bio, profile_image, featured, is_profile_complete, created_at, updated_at)
           VALUES ($1, $2, $3, NULL, FALSE, FALSE, NOW(), NOW())`,
          [creatorId, display_name, bio]
        );
      }
    }

    if (rawCats) {
      const { names, ids } = parseCategoryInput(rawCats);
      let allIds = ids.slice();

      if (names.length) {
        const { rows } = await db.query(
          `SELECT id, name FROM categories WHERE active = TRUE AND lower(name) = ANY($1::text[])`,
          [names.map(toLower)]
        );
        const foundLower = rows.map((r) => r.name.toLowerCase());
        const missing = names.filter((n) => !foundLower.includes(n.toLowerCase()));

        if (missing.length) {
          await db.query("ROLLBACK");
          return res.status(400).json({ error: "Unknown categories", details: { missing } });
        }

        allIds = allIds.concat(rows.map((r) => r.id));
      }

      await db.query(`DELETE FROM creator_categories WHERE creator_id=$1`, [creatorId]);
      if (allIds.length) {
        const values = allIds.map((_, i) => `($1,$${i + 2})`).join(",");
        await db.query(
          `INSERT INTO creator_categories (creator_id, category_id) VALUES ${values}`,
          [creatorId, ...allIds]
        );
      }
    }

    const { rows: prof } = await db.query(
      `SELECT user_id AS creator_id, display_name, bio, profile_image
         FROM creator_profiles WHERE user_id=$1 LIMIT 1`,
      [creatorId]
    );

    const { rows: cats } = await db.query(
      `SELECT c.name
         FROM creator_categories cc
         JOIN categories c ON c.id = cc.category_id
        WHERE cc.creator_id = $1
        ORDER BY c.name ASC`,
      [creatorId]
    );

    await db.query("COMMIT");

    return res.json({
      ...(prof[0] || { creator_id: creatorId, display_name, bio, profile_image: null }),
      categories: cats.map((c) => c.name),
    });
  } catch (e) {
    try { await db.query("ROLLBACK"); } catch {}
    console.error("update creator error:", e);
    return res.status(500).json({ error: "Could not update creator" });
  }
});

/**
 * Set my categories
 */
router.post("/me/categories", requireAuth, async (req, res) => {
  const userId = req.user.id;
  const { category_ids } = req.body || {};
  const ids = Array.isArray(category_ids) ? category_ids.map((n) => parseInt(n, 10)).filter(Boolean) : [];

  try {
    await db.query("BEGIN");
    await db.query(`DELETE FROM creator_categories WHERE creator_id=$1`, [userId]);

    if (ids.length) {
      const values = ids.map((_, i) => `($1,$${i + 2})`).join(",");
      await db.query(`INSERT INTO creator_categories (creator_id, category_id) VALUES ${values}`, [userId, ...ids]);
    }
    await db.query("COMMIT");

    res.json({ success: true, category_ids: ids });
  } catch (e) {
    await db.query("ROLLBACK");
    console.error("set categories error:", e);
    res.status(500).json({ error: "Failed to set categories" });
  }
});

/**
 * ADMIN: Set/unset featured creator
 */
router.patch("/:creatorId/featured", requireAuth, requireAdmin, async (req, res) => {
  const creatorId = parseInt(req.params.creatorId, 10);
  const { featured } = req.body || {};
  const flag = !!featured;

  try {
    const { rows } = await db.query(
      `UPDATE creator_profiles
          SET featured=$1, updated_at=NOW()
        WHERE user_id=$2
        RETURNING user_id, display_name, bio, profile_image, featured`,
      [flag, creatorId]
    );
    if (!rows.length) return res.status(404).json({ error: "Creator profile not found" });

    try {
      await db.query(
        `INSERT INTO admin_actions (admin_id, action, target_type, target_id, payload_json)
         VALUES ($1,$2,$3,$4,$5)`,
        [req.user.id, flag ? "feature_creator" : "unfeature_creator", "user", creatorId, JSON.stringify({ featured: flag })]
      );
    } catch {}

    res.json({ success: true, profile: rows[0] });
  } catch (e) {
    console.error("set featured error:", e);
    res.status(500).json({ error: "Failed to update featured flag" });
  }
});

/**
 * PUBLIC: Creator card (front/back) — eligible only
 */
router.get("/:creatorId/card", async (req, res) => {
  const creatorId = parseInt(req.params.creatorId, 10);

  try {
    const enabledClause = await usersEnabledClause();

    const { rows: prof } = await db.query(
      `
      SELECT
        cp.user_id AS creator_id,
        cp.display_name,
        cp.bio,
        cp.profile_image,
        cp.featured,
        COALESCE(AVG(r.rating),0)::numeric(3,2) AS average_rating,
        COUNT(DISTINCT p.id)::int               AS products_count
      FROM creator_profiles cp
      JOIN users u
        ON u.id = cp.user_id
      LEFT JOIN reviews  r
        ON r.creator_id = cp.user_id
      LEFT JOIN products p
        ON p.user_id = cp.user_id
       AND p.active  = TRUE
      WHERE cp.user_id = $1
        AND ${enabledClause}
        AND u.role = 'creator'
        AND cp.is_profile_complete = TRUE
        AND cp.is_active = TRUE
      GROUP BY cp.user_id, cp.display_name, cp.bio, cp.profile_image, cp.featured
      HAVING COUNT(DISTINCT p.id) > 0
      `,
      [creatorId]
    );
    if (!prof.length) return res.status(404).json({ error: "Creator profile not found or not eligible" });

    const p = prof[0];

    // categories: include slug if present, else derive from name
    const slugExists = await hasColumn("categories", "slug");

    const { rows: cats } = await db.query(
      `
      SELECT ${slugExists ? "c.id, c.name, c.slug" : "c.id, c.name, lower(regexp_replace(c.name,'\\s+','-','g')) AS slug"}
      FROM creator_categories cc
      JOIN categories c ON c.id = cc.category_id
      WHERE cc.creator_id = $1
      ORDER BY c.name ASC
      `,
      [creatorId]
    );

    const { rows: photoAgg } = await db.query(
      `SELECT ARRAY_AGG(url ORDER BY position) AS gallery
         FROM creator_profile_photos WHERE user_id=$1`,
      [creatorId]
    );
    const gallery = (photoAgg?.[0]?.gallery || []).slice(0, 4);

    const { rows: prods } = await db.query(
      `
      SELECT id, title, product_type, price
      FROM (
        SELECT *,
               ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY created_at DESC) rn
        FROM products
      ) t
      WHERE user_id = $1 AND active = TRUE AND rn <= 4
      `,
      [creatorId]
    );

    const card = {
      creator_id: p.creator_id,
      front: {
        display_name: p.display_name,
        bio: p.bio,
        profile_image: p.profile_image,
        categories: cats,
        average_rating: p.average_rating,
        products_count: p.products_count,
        featured: p.featured,
        products_preview: prods,
      },
      back: { gallery },
      links: { profile: `/creators/${p.creator_id}` },
    };

    res.json(card);
  } catch (e) {
    console.error("creator card error:", e);
    res.status(500).json({ error: "Failed to fetch creator" });
  }
});

/**
 * PUBLIC: Explore creators (eligible only)
 * Works whether or not categories.slug or users.enabled exist.
 */
router.get("/", async (req, res) => {
  const limit = Math.min(parseInt(req.query.limit || "24", 10), 60);
  const offset = parseInt(req.query.offset || "0", 10);
  const q = (req.query.q || "").trim();
  const categoryId = parseInt(req.query.categoryId || req.query.category_id || "", 10);

  const params = [];
  const enabledClause = await usersEnabledClause();
  const where = [
    enabledClause,                // conditional users.enabled
    "u.role = 'creator'",
    "cp.is_profile_complete = TRUE",
    "cp.is_active = TRUE",
  ];

  if (q) {
    params.push(`%${q}%`);
    where.push(`(cp.display_name ILIKE $${params.length} OR cp.bio ILIKE $${params.length})`);
  }

  if (!isNaN(categoryId)) {
    params.push(categoryId);
    where.push(`EXISTS (
      SELECT 1 FROM creator_categories cc
      WHERE cc.creator_id = cp.user_id AND cc.category_id = $${params.length}
    )`);
  }

  const whereSql = `WHERE ${where.join(" AND ")}`;

  try {
    const { rows: profiles } = await db.query(
      `
      SELECT
        cp.user_id AS creator_id,
        cp.display_name,
        cp.bio,
        cp.profile_image,
        cp.featured,
        COALESCE(AVG(r.rating),0)::numeric(3,2) AS average_rating,
        COUNT(DISTINCT p.id)::int               AS products_count
      FROM creator_profiles cp
      JOIN users u
        ON u.id = cp.user_id
      LEFT JOIN reviews  r
        ON r.creator_id = cp.user_id
      LEFT JOIN products p
        ON p.user_id = cp.user_id
       AND p.active  = TRUE
      ${whereSql}
      GROUP BY cp.user_id, cp.display_name, cp.bio, cp.profile_image, cp.featured
      HAVING COUNT(DISTINCT p.id) > 0
      ORDER BY average_rating DESC NULLS LAST, products_count DESC, cp.display_name ASC
      LIMIT $${params.length + 1} OFFSET $${params.length + 2}
      `,
      [...params, limit, offset]
    );

    if (!profiles.length) {
      return res.json({ creators: [] });
    }

    const creatorIds = profiles.map((p) => p.creator_id);

    // Categories per creator (slug conditional)
    const slugExists = await hasColumn("categories", "slug");

    let categoriesByCreator = {};
    if (creatorIds.length) {
      const { rows: categories } = await db.query(
        `
        SELECT
          cc.creator_id,
          JSON_AGG(
            JSON_BUILD_OBJECT(
              'id', c.id,
              'name', c.name,
              'slug', ${slugExists ? "c.slug" : "lower(regexp_replace(c.name,'\\s+','-','g'))"}
            )
            ORDER BY c.name
          ) AS categories
        FROM creator_categories cc
        JOIN categories c ON c.id = cc.category_id
        WHERE cc.creator_id = ANY($1::int[])
        GROUP BY cc.creator_id
        `,
        [creatorIds]
      );
      categoriesByCreator = Object.fromEntries(categories.map((c) => [c.creator_id, c.categories || []]));
    }

    // Photos per creator
    let photosByCreator = {};
    if (creatorIds.length) {
      const { rows: photos } = await db.query(
        `
        SELECT user_id AS creator_id, ARRAY_AGG(url ORDER BY position) AS gallery
        FROM creator_profile_photos
        WHERE user_id = ANY($1::int[])
        GROUP BY user_id
        `,
        [creatorIds]
      );
      photosByCreator = Object.fromEntries(photos.map((p) => [p.creator_id, p.gallery || []]));
    }

    const out = profiles.map((p) => ({
      creator_id: p.creator_id,
      display_name: p.display_name,
      bio: p.bio,
      profile_image: p.profile_image,
      gallery: photosByCreator[p.creator_id] || [],
      average_rating: p.average_rating,
      products_count: p.products_count,
      categories: categoriesByCreator[p.creator_id] || [],
    }));

    res.json({ creators: out });
  } catch (e) {
    console.error("list creators error:", e);
    res.status(500).json({ error: "Failed to fetch creators" });
  }
});
/**
 * PUBLIC: Featured creators (eligible only)
 * - u.enabled = TRUE
 * - u.role = 'creator'
 * - cp.is_profile_complete = TRUE
 * - cp.is_active = TRUE
 * - cp.featured = TRUE
 * - ≥1 active product
 */
router.get("/featured", async (req, res) => {
  const limit = Math.min(parseInt(req.query.limit || "12", 10), 24);

  try {
    const { rows: profiles } = await db.query(
      `
      SELECT
        cp.user_id AS creator_id,
        cp.display_name,
        cp.bio,
        cp.profile_image,
        cp.featured,
        COALESCE(AVG(r.rating),0)::numeric(3,2) AS average_rating,
        COUNT(DISTINCT p.id)::int               AS products_count
      FROM creator_profiles cp
      JOIN users u
        ON u.id = cp.user_id
      LEFT JOIN reviews  r
        ON r.creator_id = cp.user_id
      LEFT JOIN products p
        ON p.user_id = cp.user_id
       AND p.active  = TRUE
      WHERE u.enabled = TRUE
        AND u.role = 'creator'
        AND cp.is_profile_complete = TRUE
        AND cp.is_active = TRUE
        AND cp.featured = TRUE
      GROUP BY cp.user_id, cp.display_name, cp.bio, cp.profile_image, cp.featured
      HAVING COUNT(DISTINCT p.id) > 0
      ORDER BY average_rating DESC NULLS LAST, products_count DESC, cp.display_name ASC
      LIMIT $1
      `,
      [limit]
    );

    if (profiles.length === 0) return res.json({ creators: [] });

    const creatorIds = profiles.map((p) => p.creator_id);

    // categories (slug-safe)
    const slugExists = await hasColumn("categories", "slug");
    const catExpr = slugExists ? "c.slug" : "lower(regexp_replace(c.name,'\\s+','-','g'))";
    const { rows: categories } = await db.query(
      `
      SELECT
        cc.creator_id,
        JSON_AGG(
          JSON_BUILD_OBJECT('id', c.id, 'name', c.name, 'slug', ${catExpr})
          ORDER BY c.name
        ) AS categories
      FROM creator_categories cc
      JOIN categories c ON c.id = cc.category_id
      WHERE cc.creator_id = ANY($1::int[])
      GROUP BY cc.creator_id
      `,
      [creatorIds]
    );
    const catsByCreator = Object.fromEntries(categories.map((r) => [r.creator_id, r.categories || []]));

    // gallery (first 4)
    const { rows: photos } = await db.query(
      `
      SELECT user_id AS creator_id, ARRAY_AGG(url ORDER BY position) AS gallery
      FROM creator_profile_photos
      WHERE user_id = ANY($1::int[])
      GROUP BY user_id
      `,
      [creatorIds]
    );
    const photosByCreator = Object.fromEntries(photos.map((r) => [r.creator_id, (r.gallery || []).slice(0, 4)]));

    const out = profiles.map((p) => ({
      creator_id: p.creator_id,
      display_name: p.display_name,
      bio: p.bio,
      profile_image: p.profile_image,
      average_rating: p.average_rating,
      products_count: p.products_count,
      categories: catsByCreator[p.creator_id] || [],
      gallery: photosByCreator[p.creator_id] || [],
    }));

    res.json({ creators: out });
  } catch (e) {
    console.error("featured creators error:", e);
    res.status(500).json({ error: "Failed to fetch featured creators" });
  }
});

module.exports = router;


===== FILE: sliptail-backend\routes\downloads.js =====

// routes/downloads.js
const express = require("express");
const path = require("path");
const fs = require("fs");
const db = require("../db");
const { requireAuth } = require("../middleware/auth");

const router = express.Router();
const uploadDir = path.join(__dirname, "..", "public", "uploads");

// --- helpers -------------------------------------------------------------

async function getPurchasedFile(userId, productId) {
  // must be a 'purchase' product & the user must have a PAID order for it
  const { rows } = await db.query(
    `SELECT p.filename, p.product_type, o.id AS order_id
       FROM products p
       JOIN orders   o ON o.product_id = p.id
      WHERE p.id = $1
        AND p.product_type = 'purchase'
        AND o.buyer_id = $2
        AND o.status = 'paid'
      LIMIT 1`,
    [productId, userId]
  );
  const row = rows[0];
  if (!row) return { error: "No access or not a purchase product", code: 403 };
  if (!row.filename) return { error: "File not found on server", code: 404 };

  const fullPath = path.join(uploadDir, row.filename);
  if (!fs.existsSync(fullPath)) return { error: "File missing on disk", code: 404 };

  return { orderId: row.order_id, filename: row.filename, fullPath };
}

async function recordDownload(orderId, productId) {
  // Keeps a counter & timestamp per (order, product). Safe to no-op if table absent.
  try {
    await db.query(
      `INSERT INTO download_access(order_id, product_id, downloads, last_download_at)
       VALUES ($1,$2,1,NOW())
       ON CONFLICT (order_id, product_id)
       DO UPDATE SET downloads = download_access.downloads + 1,
                     last_download_at = NOW()`,
      [orderId, productId]
    );
  } catch (e) {
    // don't fail the response just because analytics failed
    console.warn("download_access update skipped:", e.message);
  }
}

// --- routes: purchases ---------------------------------------------------

// 👀 View inline (PDF/image/video displayed in browser)
router.get("/view/:productId", requireAuth, async (req, res) => {
  const productId = parseInt(req.params.productId, 10);
  const userId = req.user.id;

  const result = await getPurchasedFile(userId, productId);
  if (result.error) return res.status(result.code).json({ error: result.error });

  await recordDownload(result.orderId, productId);

  // Let the browser try to display it inline
  res.setHeader("Content-Disposition", `inline; filename="${result.filename}"`);
  return res.sendFile(result.fullPath);
});

// ⬇️ Download as attachment (forces “Save As…”)
router.get("/file/:productId", requireAuth, async (req, res) => {
  const productId = parseInt(req.params.productId, 10);
  const userId = req.user.id;

  const result = await getPurchasedFile(userId, productId);
  if (result.error) return res.status(result.code).json({ error: result.error });

  await recordDownload(result.orderId, productId);

  return res.download(result.fullPath, result.filename);
});

// --- routes: requests (delivered files) ---------------------------------
// If your request flow stores the creator’s delivery on custom_requests.attachment_path
// and sets status='delivered', the buyer can grab it here.
router.get("/request/:requestId", requireAuth, async (req, res) => {
  const requestId = parseInt(req.params.requestId, 10);
  const userId = req.user.id;

  try {
    const { rows } = await db.query(
      `SELECT cr.attachment_path, cr.status, cr.buyer_id
         FROM custom_requests cr
        WHERE cr.id = $1`,
      [requestId]
    );
    const r = rows[0];
    if (!r) return res.status(404).json({ error: "Request not found" });

    // only the buyer can download, and only after delivered
    if (r.buyer_id !== userId) return res.status(403).json({ error: "Not your request" });
    if (r.status !== "delivered") return res.status(403).json({ error: "Not delivered yet" });

    if (!r.attachment_path) return res.status(404).json({ error: "No delivery file" });

    const fullPath = path.join(uploadDir, r.attachment_path);
    if (!fs.existsSync(fullPath)) return res.status(404).json({ error: "File missing on disk" });

    return res.download(fullPath, path.basename(r.attachment_path));
  } catch (e) {
    console.error(e);
    return res.status(500).json({ error: "Download failed" });
  }
});

module.exports = router;

===== FILE: sliptail-backend\routes\email.js =====

const express = require("express");
const crypto = require("crypto");
const db = require("../db");
const { requireAuth } = require("../middleware/auth");
const { enqueueAndSend } = require("../utils/emailQueue");
const { validate } = require("../middleware/validate");
const { sendVerifyEmail } = require("../validators/schemas");
const { strictLimiter } = require("../middleware/rateLimit");

const router = express.Router();

// Safe fallbacks so links don’t end up with "undefined"
const { APP_URL, FRONTEND_URL } = process.env;
const BASE_URL = (APP_URL || "http://localhost:5000").replace(/\/$/, "");
const FRONTEND_BASE = (FRONTEND_URL || "").replace(/\/$/, "");

/**
 * POST /api/email/verify/send
 * - logged-in user requests a fresh verification link
 */
router.post("/verify/send", requireAuth, strictLimiter, validate(sendVerifyEmail), async (req, res) => {
  const userId = req.user.id;

  try {
    // If already verified, short-circuit
    const { rows: u } = await db.query(
      `SELECT email, email_verified_at FROM users WHERE id=$1`,
      [userId]
    );
    const user = u[0];
    if (!user) return res.status(404).json({ error: "User not found" });
    if (user.email_verified_at) return res.json({ alreadyVerified: true });

    // Invalidate previous unconsumed verify tokens (optional but nice)
    await db.query(
      `UPDATE user_tokens
          SET consumed_at = NOW()
        WHERE user_id = $1 AND token_type='email_verify' AND consumed_at IS NULL`,
      [userId]
    );

    // Create token (24h)
    const token = crypto.randomBytes(32).toString("hex");
    const expires = new Date(Date.now() + 1000 * 60 * 60 * 24);

    await db.query(
      `INSERT INTO user_tokens (user_id, token, token_type, expires_at)
       VALUES ($1,$2,'email_verify',$3)`,
      [userId, token, expires]
    );

    const verifyUrl = `${BASE_URL}/api/email/verify/${token}`;
    const html = `
      <h2>Verify your email</h2>
      <p>Click the link below to verify your email address:</p>
      <p><a href="${verifyUrl}">${verifyUrl}</a></p>
      <p>This link expires in 24 hours.</p>
    `;

    await enqueueAndSend({
      to: user.email,
      subject: "Verify your email",
      html,
      category: "email_verify",
    });

    res.json({ success: true });
  } catch (e) {
    console.error("send verify error:", e);
    res.status(500).json({ error: "Failed to send verification email" });
  }
});

/**
 * GET /api/email/verify/:token
 * - consumes token and marks user verified
 * - on success: optional redirect to FRONTEND_URL/verified?success=1
 */
router.get("/verify/:token", async (req, res) => {
  const token = req.params.token;

  try {
    const { rows } = await db.query(
      `SELECT user_id, expires_at, consumed_at
         FROM user_tokens
        WHERE token=$1 AND token_type='email_verify'`,
      [token]
    );
    const t = rows[0];
    if (!t) return res.status(400).json({ error: "Invalid token" });
    if (t.consumed_at) return res.status(400).json({ error: "Token already used" });
    if (new Date(t.expires_at) < new Date()) return res.status(400).json({ error: "Token expired" });

    await db.query("BEGIN");
    await db.query(`UPDATE users SET email_verified_at=NOW() WHERE id=$1`, [t.user_id]);
    await db.query(`UPDATE user_tokens SET consumed_at=NOW() WHERE token=$1`, [token]);
    await db.query("COMMIT");

    if (FRONTEND_BASE) {
      return res.redirect(`${FRONTEND_BASE}/verified?success=1`);
    }
    return res.json({ success: true, message: "Email verified" });
  } catch (e) {
    await db.query("ROLLBACK").catch(() => {});
    console.error("verify error:", e);
    res.status(500).json({ error: "Verification failed" });
  }
});

module.exports = router;

===== FILE: sliptail-backend\routes\home.js =====

const express = require("express");
const db = require("../db");

const router = express.Router();

/**
 * GET /api/home/featured
 * - Returns a list of featured creators with profile summary + categories + a few products
 * Query: ?limit=12
 */
router.get("/featured", async (req, res) => {
  const limit = Math.min(parseInt(req.query.limit || "12", 10), 50);

  try {
    // Get featured profiles
    const { rows: profiles } = await db.query(
      `SELECT cp.user_id AS creator_id,
              cp.display_name,
              cp.bio,
              cp.profile_image,
              cp.gallery,
              COALESCE(AVG(r.rating),0)::numeric(3,2) AS average_rating,
              COUNT(DISTINCT p.id)::int               AS products_count
         FROM creator_profiles cp
         LEFT JOIN reviews r  ON r.creator_id = cp.user_id
         LEFT JOIN products p ON p.user_id    = cp.user_id
        WHERE cp.featured = TRUE
        GROUP BY cp.user_id, cp.display_name, cp.bio, cp.profile_image, cp.gallery
        ORDER BY cp.user_id DESC
        LIMIT $1`,
      [limit]
    );

    // Get categories per creator
    const creatorIds = profiles.map(p => p.creator_id);
    let categoriesByCreator = {};
    if (creatorIds.length) {
      const { rows: cats } = await db.query(
        `SELECT cc.creator_id, c.id, c.name, c.slug
           FROM creator_categories cc
           JOIN categories c ON c.id = cc.category_id
          WHERE cc.creator_id = ANY($1::int[])`,
        [creatorIds]
      );
      for (const row of cats) {
        categoriesByCreator[row.creator_id] = categoriesByCreator[row.creator_id] || [];
        categoriesByCreator[row.creator_id].push({ id: row.id, name: row.name, slug: row.slug });
      }
    }

    // Grab up to 4 products per creator (simple preview)
    let productsByCreator = {};
    if (creatorIds.length) {
      const { rows: prods } = await db.query(
        `SELECT p.user_id AS creator_id, p.id, p.title, p.product_type, p.price
           FROM (
                SELECT *,
                       ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY created_at DESC) AS rn
                  FROM products
           ) p
          WHERE p.user_id = ANY($1::int[])
            AND p.rn <= 4`,
        [creatorIds]
      );
      for (const row of prods) {
        productsByCreator[row.creator_id] = productsByCreator[row.creator_id] || [];
        productsByCreator[row.creator_id].push(row);
      }
    }

    // Assemble payload
    const out = profiles.map(p => ({
      creator_id: p.creator_id,
      display_name: p.display_name,
      bio: p.bio,
      profile_image: p.profile_image,
      gallery: typeof p.gallery === "string" ? JSON.parse(p.gallery) : p.gallery,
      average_rating: p.average_rating,
      products_count: p.products_count,
      categories: categoriesByCreator[p.creator_id] || [],
      products_preview: productsByCreator[p.creator_id] || []
    }));

    res.json({ featured: out });
  } catch (e) {
    console.error("featured creators error:", e);
    res.status(500).json({ error: "Failed to fetch featured creators" });
  }
});

module.exports = router;

===== FILE: sliptail-backend\routes\me.js =====

const express = require("express");
const db = require("../db");
const { requireAuth } = require("../middleware/auth");

// Read from Stripe only as a fallback (DB first for speed/reliability)
const Stripe = require("stripe");
const stripe = Stripe(process.env.STRIPE_SECRET_KEY || "");

const router = express.Router();

/**
 * Helper: fetch Stripe flags from DB (stripe_connect), falling back to Stripe API if needed.
 */
async function getStripeConnectionState(db, userId) {
  const uid = String(userId);

  // 1) Try DB first (authoritative snapshot written by /api/stripe-connect/sync & webhook)
  try {
    const r = await db.query(
      `
      SELECT details_submitted, charges_enabled, payouts_enabled
      FROM stripe_connect
      WHERE user_id::text = $1
      LIMIT 1
      `,
      [uid]
    );
    if (r.rows[0]) {
      const { details_submitted = false, charges_enabled = false, payouts_enabled = false } = r.rows[0];
      return {
        details_submitted: !!details_submitted,
        charges_enabled: !!charges_enabled,
        payouts_enabled: !!payouts_enabled,
        present: true,
      };
    }
  } catch (e) {
    // table may not exist yet in some envs; ignore and fall back
    // console.warn("[creator-status] stripe_connect read warn:", e.message || e);
  }

  // 2) Fallback: try live Stripe (only if we have an account id)
  try {
    const { rows: [u] = [] } = await db.query(
      `SELECT stripe_account_id FROM users WHERE id::text = $1 LIMIT 1`,
      [uid]
    );
    const acctId = u?.stripe_account_id;
    if (!acctId) {
      return { details_submitted: false, charges_enabled: false, payouts_enabled: false, present: false };
    }
    const acct = await stripe.accounts.retrieve(acctId);
    return {
      details_submitted: !!acct?.details_submitted,
      charges_enabled: !!acct?.charges_enabled,
      payouts_enabled: !!acct?.payouts_enabled,
      present: true,
    };
  } catch (e) {
    // Stripe failure shouldn't break the endpoint
    console.warn("[creator-status] Stripe retrieve failed:", e.message || e);
    return { details_submitted: false, charges_enabled: false, payouts_enabled: false, present: false };
  }
}

/**
 * GET /api/me/creator-status
 * Returns:
 *  {
 *    profileComplete: boolean,
 *    stripeConnected: boolean,
 *    hasPublishedProduct: boolean,
 *    isActive: boolean
 *  }
 */
router.get("/creator-status", requireAuth, async (req, res) => {
  const userId = req.user.id;
  const uid = String(userId);

  try {
    // Profile status (be tolerant about schema)
    let profileComplete = false;
    let isActive = false;
    try {
      const { rows: [cp] = [] } = await db.query(
        `
        SELECT
          -- prefer explicit flags if you have them
          COALESCE(is_profile_complete, FALSE) AS is_profile_complete,
          COALESCE(is_active, FALSE)           AS is_active
        FROM creator_profiles
        WHERE user_id::text = $1
        LIMIT 1
        `,
        [uid]
      );
      if (cp) {
        profileComplete = !!cp.is_profile_complete;
        isActive = !!cp.is_active;
      }
    } catch (e) {
      // creator_profiles might not exist yet; leave defaults
      // console.warn("[creator-status] creator_profiles read warn:", e.message || e);
    }

    // Products: count published/active
    let hasPublishedProduct = false;
    try {
      const { rows: [row] = [] } = await db.query(
        `
        SELECT COUNT(*)::int AS cnt
        FROM products
        WHERE user_id::text = $1 AND active = TRUE
        `,
        [uid]
      );
      hasPublishedProduct = (row?.cnt || 0) > 0;
    } catch (e) {
      // products table might not be present in some envs
      // console.warn("[creator-status] products read warn:", e.message || e);
    }

    // Stripe connection (DB first, Stripe fallback)
    const s = await getStripeConnectionState(db, uid);
    const stripeConnected = !!(s.details_submitted && s.charges_enabled && s.payouts_enabled);

    // Respond with your existing shape
    return res.json({
      profileComplete,
      stripeConnected,
      hasPublishedProduct,
      isActive, // if you prefer a computed status: (profileComplete && stripeConnected && hasPublishedProduct)
    });
  } catch (e) {
    console.error("creator-status error:", e);
    return res.status(500).json({ error: "Failed to compute creator status" });
  }
});

module.exports = router;


===== FILE: sliptail-backend\routes\memberships.js =====

// routes/memberships.js
const express = require("express");
const db = require("../db");
const { requireAuth } = require("../middleware/auth");
const { sendIfUserPref } = require("../utils/notify");

const router = express.Router();

/**
 * POST /api/memberships/subscribe
 * Body: { creator_id, product_id }
 * - Simulates a subscription purchase:
 *   - creates/updates a memberships row with status='active'
 *   - sets current_period_end = now + 1 month (MVP)
 * - Prevent subscribing to yourself
 * - Enforces one active membership per (buyer -> creator)
 */
router.post("/subscribe", requireAuth, async (req, res) => {
  const buyerId = req.user.id;
  const { creator_id, product_id } = req.body;

  if (!creator_id || !product_id) {
    return res.status(400).json({ error: "creator_id and product_id are required" });
  }
  if (Number(creator_id) === buyerId) {
    return res.status(400).json({ error: "You cannot subscribe to yourself" });
  }

  try {
    // validate product belongs to creator and is a membership product
    const { rows: prodRows } = await db.query(
      `SELECT id, user_id AS creator_id, product_type, price
         FROM products
        WHERE id=$1`,
      [product_id]
    );
    const p = prodRows[0];
    if (!p) return res.status(404).json({ error: "Product not found" });
    if (p.creator_id !== Number(creator_id)) {
      return res.status(400).json({ error: "Product does not belong to this creator" });
    }
    if (p.product_type !== "membership") {
      return res.status(400).json({ error: "Product is not a membership" });
    }

    // Simulate an initial 1-month period
    const { rows } = await db.query(
      `INSERT INTO memberships (buyer_id, creator_id, product_id, status, cancel_at_period_end, current_period_end, started_at)
       VALUES ($1,$2,$3,'active',FALSE, NOW() + INTERVAL '1 month', NOW())
       ON CONFLICT (buyer_id, creator_id)
       DO UPDATE SET status='active',
                     cancel_at_period_end=FALSE,
                     product_id=EXCLUDED.product_id,
                     current_period_end = GREATEST(memberships.current_period_end, NOW()) + INTERVAL '1 month'
       RETURNING *`,
      [buyerId, creator_id, product_id]
    );

    res.status(201).json({ success: true, membership: rows[0] });
    // buyer: confirmation
    sendIfUserPref(buyerId, "notify_purchase", {
      subject: "Your membership is active",
      html: `<p>Your membership is active. Enjoy the content!</p>`,
      category: "membership_purchase"
    }).catch(console.error);

      // creator: sale notice
    sendIfUserPref(creator_id, "notify_product_sale", {
      subject: "New membership subscriber",
      html: `<p>You have a new/renewed subscriber.</p>`,
      category: "creator_sale"
    }).catch(console.error);
  } 
  
  catch (e) {
    console.error("subscribe error:", e);
    res.status(500).json({ error: "Could not start membership" });
  }
});

/**
 * POST /api/memberships/:id/cancel
 * - Marks cancel_at_period_end = TRUE
 * - Keeps access until current_period_end
 */
router.post("/:id/cancel", requireAuth, async (req, res) => {
  const id = parseInt(req.params.id, 10);
  const userId = req.user.id;

  try {
    // must be the owner
    const { rows: own } = await db.query(
      `SELECT * FROM memberships WHERE id=$1 AND buyer_id=$2`,
      [id, userId]
    );
    if (!own.length) return res.status(404).json({ error: "Membership not found" });

    const { rows } = await db.query(
      `UPDATE memberships
          SET cancel_at_period_end = TRUE
        WHERE id = $1
        RETURNING *`,
      [id]
    );
    res.json({ success: true, membership: rows[0] });
  } catch (e) {
    console.error("cancel error:", e);
    res.status(500).json({ error: "Could not cancel membership" });
  }
});

/**
 * GET /api/memberships/mine
 * - Lists my memberships with access flags
 */
router.get("/mine", requireAuth, async (req, res) => {
  const userId = req.user.id;
  try {
    const { rows } = await db.query(
      `SELECT m.*,
              (m.status IN ('active','trialing') AND NOW() <= m.current_period_end) AS has_access
         FROM memberships m
        WHERE m.buyer_id = $1
        ORDER BY m.current_period_end DESC`,
      [userId]
    );
    res.json({ memberships: rows });
  } catch (e) {
    console.error("mine error:", e);
    res.status(500).json({ error: "Could not fetch memberships" });
  }
});

/**
 * Helper endpoint (optional) to check access to a creator's feed
 * GET /api/memberships/access/:creatorId
 */
router.get("/access/:creatorId", requireAuth, async (req, res) => {
  const creatorId = parseInt(req.params.creatorId, 10);
  const userId = req.user.id;
  try {
    const { rows } = await db.query(
      `SELECT 1
         FROM memberships
        WHERE buyer_id=$1 AND creator_id=$2
          AND status IN ('active','trialing')
          AND NOW() <= current_period_end
        LIMIT 1`,
      [userId, creatorId]
    );
    res.json({ has_access: !!rows.length });
  } catch (e) {
    console.error("access error:", e);
    res.status(500).json({ error: "Access check failed" });
  }
});

module.exports = router;

===== FILE: sliptail-backend\routes\notifications.js =====

const express = require("express");
const db = require("../db");
const { requireAuth } = require("../middleware/auth");
const router = express.Router();

/**
 * List my notifications (newest first)
 * GET /api/notifications?limit=20&offset=0&unread_only=true
 */
router.get("/", requireAuth, async (req, res) => {
  const limit = Math.min(parseInt(req.query.limit || "20", 10), 100);
  const offset = Math.max(parseInt(req.query.offset || "0", 10), 0);
  const unreadOnly = req.query.unread_only === "true";

  const where = [`user_id = $1`];
  const params = [req.user.id, limit, offset];

  if (unreadOnly) {
    where.push(`read_at IS NULL`);
  }

  const { rows } = await db.query(
    `SELECT id, type, title, body, metadata, read_at, created_at
       FROM notifications
      WHERE ${where.join(" AND ")}
      ORDER BY created_at DESC
      LIMIT $2 OFFSET $3`,
    params
  );

  // Count unread for badge
  const { rows: countRows } = await db.query(
    `SELECT COUNT(*)::int AS unread FROM notifications WHERE user_id=$1 AND read_at IS NULL`,
    [req.user.id]
  );

  res.json({ notifications: rows, unread: countRows[0].unread });
});

/**
 * Mark one notification as read
 */
router.post("/:id/read", requireAuth, async (req, res) => {
  const id = parseInt(req.params.id, 10);
  const { rows } = await db.query(
    `UPDATE notifications
        SET read_at = NOW()
      WHERE id=$1 AND user_id=$2 AND read_at IS NULL
      RETURNING id, read_at`,
    [id, req.user.id]
  );
  if (!rows.length) return res.status(404).json({ error: "Not found" });
  res.json({ success: true, id, read_at: rows[0].read_at });
});

/**
 * Mark all as read
 */
router.post("/read-all", requireAuth, async (req, res) => {
  await db.query(
    `UPDATE notifications SET read_at = NOW()
      WHERE user_id=$1 AND read_at IS NULL`,
    [req.user.id]
  );
  res.json({ success: true });
});

module.exports = router;

===== FILE: sliptail-backend\routes\orders.js =====

const express = require("express");
const db = require("../db");
const { requireAuth } = require("../middleware/auth");
const { notifyPurchase } = require("../utils/notify");

const router = express.Router();

function linkify(product) {
  if (!product) return null;
  const id = product.id;
  return {
    ...product,
    view_url: `/api/downloads/view/${id}`,
    download_url: `/api/downloads/file/${id}`
  };
}

/**
 * POST /api/orders/create
 * Body: { product_id }
 * - uses JWT for buyer_id
 * - price is taken from DB (not from client)
 * - only allows 'purchase' products in this route (memberships/requests later)
 * - prevents buying your own product
 * - creates order with status='pending' (mark paid via /:id/mark-paid for now)
 */
router.post("/create", requireAuth, async (req, res) => {
  const buyerId = req.user.id;
  const { product_id } = req.body;

  if (!product_id) return res.status(400).json({ error: "product_id is required" });

  try {
    // 1) fetch product & basic validation
    const { rows: prodRows } = await db.query(
      `SELECT id, user_id AS creator_id, price, product_type
         FROM products
        WHERE id = $1`,
      [product_id]
    );
    const product = prodRows[0];
    if (!product) return res.status(404).json({ error: "Product not found" });

    if (product.creator_id === buyerId) {
      return res.status(400).json({ error: "You cannot buy your own product" });
    }

    if (product.product_type !== "purchase") {
      return res.status(400).json({ error: "This endpoint is for one-time purchases only" });
    }

    // 2) amount from DB price (cents) – allow null/0 if free
    const amount = Number(product.price ?? 0);
    if (Number.isNaN(amount) || amount < 0) {
      return res.status(400).json({ error: "Invalid product price" });
    }

    // 3) create order (pending). Later: Stripe PI/Checkout → webhook marks 'paid'
    const { rows: orderRows } = await db.query(
      `INSERT INTO orders (buyer_id, product_id, amount, status, created_at)
       VALUES ($1, $2, $3, 'pending', NOW())
       RETURNING *`,
      [buyerId, product_id, amount]
    );

    res.status(201).json({ success: true, order: orderRows[0] });
  } catch (err) {
    console.error("Order create error:", err);
    res.status(500).json({ error: "Failed to create order" });
  }
});

/**
 * GET /api/orders
 * (Alias of /mine kept for backwards compatibility with earlier frontend.)
 * Returns simplified list with consistent amount_cents field.
 */
router.get("/", requireAuth, async (req, res) => {
  const userId = req.user.id;
  try {
    const { rows } = await db.query(
      `SELECT o.id,
              COALESCE(o.amount_cents, (o.amount*100)::bigint, 0) AS amount_cents,
              o.status,
              o.created_at,
              o.product_id
         FROM orders o
        WHERE o.buyer_id = $1
        ORDER BY o.created_at DESC`,
      [userId]
    );
    res.json(rows);
  } catch (e) {
    console.error("Orders root list error:", e);
    res.status(500).json({ error: "Failed to fetch orders" });
  }
});

/**
 * POST /api/orders/:id/mark-paid
 * - TEMP helper to simulate payment success until Stripe is wired.
 * - Only the buyer who owns the order can mark it paid (for testing).
 */
router.post("/:id/mark-paid", requireAuth, async (req, res) => {
  const orderId = parseInt(req.params.id, 10);
  const userId = req.user.id;

  try {
    const { rows: owned } = await db.query(
      `SELECT id FROM orders WHERE id=$1 AND buyer_id=$2`,
      [orderId, userId]
    );
    if (!owned.length) return res.status(403).json({ error: "Not your order" });

    const { rows } = await db.query(
      `UPDATE orders
          SET status='paid'
        WHERE id=$1
        RETURNING *`,
      [orderId]
    );
    res.json({ success: true, order: rows[0] });
    // send buyer receipt + creator sale notice
notifyPurchase({ orderId }).catch(console.error);
  } 
    catch (err) {
    console.error("Mark paid error:", err);
    res.status(500).json({ error: "Failed to mark order paid" });
  }
});

/**
 * GET /api/orders/mine
 * - Lists current user's orders with product info + secure links
 */
router.get("/mine", requireAuth, async (req, res) => {
  const userId = req.user.id;

  try {
    const { rows } = await db.query(
      `SELECT o.*, 
              json_build_object(
                'id', p.id,
                'user_id', p.user_id,
                'title', p.title,
                'description', p.description,
                'filename', p.filename,
                'product_type', p.product_type,
                'price', p.price,
                'created_at', p.created_at
              ) AS product
         FROM orders o
         JOIN products p ON p.id = o.product_id
        WHERE o.buyer_id = $1
        ORDER BY o.created_at DESC`,
      [userId]
    );

    const withLinks = rows.map(r => ({
      ...r,
      product: linkify(r.product)
    }));

    res.json({ orders: withLinks });
  } catch (err) {
    console.error("Orders mine error:", err);
    res.status(500).json({ error: "Failed to fetch orders" });
  }
});

/**
 * GET /api/orders/:id
 * - Fetch a single order (only if you own it)
 */
router.get("/:id", requireAuth, async (req, res) => {
  const orderId = parseInt(req.params.id, 10);
  const userId = req.user.id;

  try {
    const { rows } = await db.query(
      `SELECT o.*, 
              json_build_object(
                'id', p.id,
                'user_id', p.user_id,
                'title', p.title,
                'description', p.description,
                'filename', p.filename,
                'product_type', p.product_type,
                'price', p.price,
                'created_at', p.created_at
              ) AS product
         FROM orders o
         JOIN products p ON p.id = o.product_id
        WHERE o.id = $1 AND o.buyer_id = $2
        LIMIT 1`,
      [orderId, userId]
    );
    if (!rows.length) return res.status(404).json({ error: "Order not found" });

    const order = rows[0];
    order.product = linkify(order.product);
    res.json(order);
  } catch (err) {
    console.error("Get order error:", err);
    res.status(500).json({ error: "Failed to fetch order" });
  }
});

module.exports = router;

===== FILE: sliptail-backend\routes\posts.js =====

const express = require("express");
const db = require("../db");
const { requireAuth, requireCreator } = require("../middleware/auth");
const { notifyPostToMembers } = require("../utils/notify");

const router = express.Router();

/**
 * POST /api/posts
 * Body: { title, body, media_path }
 * - Creator creates a post for their members
 */
router.post("/", requireAuth, requireCreator, async (req, res) => {
  const creatorId = req.user.id;
  const { title, body, media_path } = req.body || {};
  try {
    const { rows } = await db.query(
      `INSERT INTO posts (creator_id, title, body, media_path)
       VALUES ($1,$2,$3,$4)
       RETURNING *`,
      [creatorId, title || null, body || null, media_path || null]
    );
    res.status(201).json({ post: rows[0] }); 
  // fire-and-forget: notify all active members of this creator
    notifyPostToMembers({
      creatorId,
      postId: rows[0].id,
      title: rows[0].title
      }).catch(console.error);
  }
      catch (e) {
    console.error("create post error:", e);
    res.status(500).json({ error: "Could not create post" });
  }
});

/**
 * GET /api/posts/:creatorId
 * - Members-only: must have active access to the creator
 */
router.get("/:creatorId", requireAuth, async (req, res) => {
  const creatorId = parseInt(req.params.creatorId, 10);
  const userId = req.user.id;

  try {
    // membership access check
    const { rows: access } = await db.query(
      `SELECT 1
         FROM memberships
        WHERE buyer_id=$1 AND creator_id=$2
          AND status IN ('active','trialing')
          AND NOW() <= current_period_end
        LIMIT 1`,
      [userId, creatorId]
    );
    if (!access.length) {
      return res.status(403).json({ error: "Membership required" });
    }

    const { rows } = await db.query(
      `SELECT * FROM posts
        WHERE creator_id=$1
        ORDER BY created_at DESC`,
      [creatorId]
    );
    res.json({ posts: rows });
  } catch (e) {
    console.error("get posts error:", e);
    res.status(500).json({ error: "Could not fetch posts" });
  }
});

module.exports = router;

===== FILE: sliptail-backend\routes\products.js =====

const express = require("express"); 
const router = express.Router();
const multer = require("multer");
const ffmpeg = require("fluent-ffmpeg");
const path = require("path");
const fs = require("fs");
const db = require("../db");
const { requireAuth } = require("../middleware/auth"); // no requireCreator
const { validate } = require("../middleware/validate");
const { productCreateFile, productCreateNoFile, productUpdate } = require("../validators/schemas");
const { standardLimiter } = require("../middleware/rateLimit");
const { recomputeCreatorActive } = require("../services/creatorStatus");
const jwt = require("jsonwebtoken"); // ⬅️ add JWT for cookie refresh

/* --------------------------- helpers & setup --------------------------- */

function linkify(product) {
  const id = String(product.id);
  const hasFile = product.filename != null && product.filename !== "";
  return {
    ...product,
    id,
    ...(hasFile
      ? {
          view_url: `/api/downloads/view/${id}`,
          download_url: `/api/downloads/file/${id}`,
        }
      : {}),
  };
}

function toProductDTO(row) {
  return {
    id: String(row.id),
    creatorId: String(row.user_id),
    title: row.title,
    description: row.description ?? null,
    price: typeof row.price === "number" ? row.price : Number(row.price) || 0,
    productType: row.product_type,
  };
}

// 📁 Ensure upload folder exists
const uploadDir = path.join(__dirname, "..", "public", "uploads");
if (!fs.existsSync(uploadDir)) fs.mkdirSync(uploadDir, { recursive: true });

// 📦 Multer config
const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, uploadDir),
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname);
    cb(null, "raw-" + Date.now() + ext);
  },
});

const allowed = new Set([
  "application/pdf",
  "application/epub+zip",
  "image/png",
  "image/jpeg",
  "image/webp",
  "video/mp4",
  "video/quicktime",
  "video/x-msvideo",
  "text/plain",
]);

const upload = multer({
  storage,
  limits: { fileSize: 2500 * 1024 * 1024 }, // 2.5GB
  fileFilter: (req, file, cb) =>
    allowed.has(file.mimetype) ? cb(null, true) : cb(new Error("Unsupported file type")),
});

// Compare using ::text so it works for INT ids or UUID/text ids
const WHERE_ID_TEXT = "id::text = $1";
const WHERE_USERID_TEXT = "user_id::text = $1";

async function assertOwner(productIdRaw, userId) {
  const pid = String(productIdRaw || "").trim();
  const { rows } = await db.query(`SELECT user_id FROM products WHERE ${WHERE_ID_TEXT}`, [pid]);
  if (!rows[0]) return { error: "Product not found", code: 404 };
  if (String(rows[0].user_id) !== String(userId)) return { error: "You do not own this product", code: 403 };
  return { ok: true };
}

const isVideo = (mimeType) => mimeType.startsWith("video/");

// Optional best-effort Stripe sync (lazy)
let syncStripeForUser = null;
try {
  ({ syncStripeForUser } = require("../services/stripeConnect"));
} catch (_) {}

/* ---------------- DB introspection helpers (avoid schema mismatches) --------------- */

async function hasColumn(table, column) {
  const { rows } = await db.query(
    `SELECT 1 FROM information_schema.columns
     WHERE table_schema='public' AND table_name=$1 AND column_name=$2
     LIMIT 1`,
    [table, column]
  );
  return rows.length > 0;
}

/** Build a safe INSERT for products that:
 *  - coerces user_id via subselect to the real users.id type
 *  - includes only columns that exist
 *  - supports with/without filename
 *  - sets active=TRUE immediately if the column exists
 */
async function insertProduct({
  userIdText,
  title,
  description,
  product_type,
  price_cents,
  filename = null,
}) {
  const cols = ["user_id", "title", "description", "product_type", "price"];
  const vals = [
    `(SELECT id FROM users WHERE id::text = $1)`,
    "$2",
    "$3",
    "$4",
    "$5",
  ];
  const params = [userIdText, title, description || null, product_type, Number(price_cents) || 0];

  const haveFilename = filename != null;
  const productsHasFilename = await hasColumn("products", "filename");
  const productsHasActive = await hasColumn("products", "active");
  const productsHasCreated = await hasColumn("products", "created_at");
  const productsHasUpdated = await hasColumn("products", "updated_at");

  if (haveFilename && productsHasFilename) {
    cols.push("filename");
    vals.push("$" + params.push(filename));
  }
  if (productsHasActive) {
    cols.push("active");
    vals.push("TRUE");
  }
  if (productsHasCreated) {
    cols.push("created_at");
    vals.push("NOW()");
  }
  if (productsHasUpdated) {
    cols.push("updated_at");
    vals.push("NOW()");
  }

  const sql = `INSERT INTO products (${cols.join(", ")}) VALUES (${vals.join(", ")}) RETURNING *`;
  const { rows } = await db.query(sql, params);
  return rows[0];
}

/* -------------------- SAFE READINESS (never throws) -------------------- */

async function ensureCreationReadinessSafe(dbConn, userId, recomputeFn) {
  const out = { ok: false, missing: [], status: undefined, error: undefined };
  try {
    let status = await recomputeFn(dbConn, userId);

    if (status && !status.stripeConnected && typeof syncStripeForUser === "function") {
      try {
        await syncStripeForUser(dbConn, userId);
      } catch (e) {
        console.warn("lazy stripe sync failed:", e?.message || e);
      }
      try {
        status = await recomputeFn(dbConn, userId);
      } catch (_) {}
    }

    out.status = status || null;
    if (!status?.profileComplete) out.missing.push("Complete your profile");
    if (!status?.stripeConnected) out.missing.push("Connect your Stripe account");
    out.ok = out.missing.length === 0;
    return out;
  } catch (e) {
    out.error = e?.message || String(e);
    if (!out.missing.length) out.missing.push("Complete your profile", "Connect your Stripe account");
    return out;
  }
}

/* -------------------- creator activation helpers (auto) -------------------- */

// Ensure a creator_profiles row exists (schema-aware)
async function ensureCreatorProfileRow(userId) {
  const hasUpdatedAt = await hasColumn("creator_profiles", "updated_at");
  const cols = ["user_id", "is_active"];
  const vals = ["$1", "FALSE"];
  const params = [String(userId)];
  if (hasUpdatedAt) {
    cols.push("updated_at");
    vals.push("NOW()");
  }
  await db.query(
    `INSERT INTO creator_profiles (${cols.join(", ")})
     VALUES (${vals.join(", ")})
     ON CONFLICT (user_id) DO NOTHING`,
    params
  );
}

// Set creator_profiles.is_active based on “has ≥1 published product” (schema-aware)
async function setActiveFromPublished(userId) {
  const { rows } = await db.query(
    `SELECT EXISTS(
       SELECT 1 FROM products WHERE user_id::text=$1 AND active=TRUE
     ) AS any_pub`,
    [String(userId)]
  );
  const anyPub = !!rows?.[0]?.any_pub;

  await ensureCreatorProfileRow(userId);
  const hasUpdatedAt = await hasColumn("creator_profiles", "updated_at");
  const sets = ["is_active = $2"];
  if (hasUpdatedAt) sets.push("updated_at = NOW()");

  await db.query(
    `UPDATE creator_profiles
        SET ${sets.join(", ")}
      WHERE user_id::text=$1`,
    [String(userId), anyPub]
  );

  return anyPub;
}

// ⬇️ Promote role to creator, refresh JWT cookie, and sync creator_profiles.is_active.
//    Errors are swallowed (don’t break the create flow).
async function promoteAndRefreshAuth(userId, res) {
  try {
    await db.query(
      `UPDATE users SET role='creator', updated_at=NOW()
       WHERE id=$1 AND (role IS NULL OR role <> 'creator')`,
      [userId]
    );

    // pull fresh user row
    const { rows } = await db.query(`SELECT id, email, role, email_verified_at FROM users WHERE id=$1 LIMIT 1`, [userId]);
    if (rows.length) {
      const u = rows[0];
      const token = jwt.sign(
        {
          id: u.id,
          email: u.email,
          role: u.role || "user",
          email_verified_at: u.email_verified_at,
        },
        process.env.JWT_SECRET,
        { expiresIn: "7d" }
      );
      res.cookie("token", token, {
        httpOnly: true,
        sameSite: "lax",
        secure: process.env.NODE_ENV !== "development",
        maxAge: 7 * 24 * 60 * 60 * 1000,
        path: "/",
      });
    }
  } catch (e) {
    console.warn("promote/refresh cookie failed:", e?.message || e);
  }

  try {
    await setActiveFromPublished(userId);
  } catch (e) {
    console.warn("setActiveFromPublished failed:", e?.message || e);
  }
}

/* -------------------------------- routes -------------------------------- */

// GET /api/products -> list all products
router.get("/", async (req, res, next) => {
  try {
    const result = await db.query(
      "SELECT id, user_id, title, description, filename, product_type, price FROM products ORDER BY created_at DESC"
    );
    const items = result.rows.map((row) => ({
      id: String(row.id),
      creatorId: String(row.user_id),
      title: row.title,
      description: row.description ?? null,
      price: Number(row.price) ?? 0,
      productType: row.product_type,
    }));
    res.json(items);
  } catch (err) {
    next(err);
  }
});

/* ------------------------ CREATE (with file) ------------------------ */
router.post(
  "/upload",
  requireAuth,
  standardLimiter,
  upload.single("file"),
  validate(productCreateFile),
  async (req, res) => {
    const inputPath = req.file.path;
    const mimeType = req.file.mimetype;

    const user_id = String(req.user.id || "").trim();
    const { title, description, product_type } = req.body;

    const priceRaw = req.body.price ?? req.body.price_cents ?? 0;
    const priceNum = Number(priceRaw);
    if (Number.isNaN(priceNum)) return res.status(400).json({ error: "Price must be a number" });

    if (!["purchase", "membership", "request"].includes(product_type)) {
      return res.status(400).json({ error: "Invalid product_type" });
    }

    const ready = await ensureCreationReadinessSafe(db, user_id, recomputeCreatorActive);
    if (!ready.ok) {
      return res.status(403).json({
        error: "Finish profile and connect Stripe before creating a product.",
        missing: ready.missing,
        ...(ready.error ? { detail: ready.error } : {}),
      });
    }

    const finalizeCreate = async (filename) => {
      try {
        const created = await insertProduct({
          userIdText: user_id,
          title,
          description,
          product_type,
          price_cents: priceNum,
          filename,
        });

        // ⬅️ do auth promotion + cookie + is_active sync BEFORE responding,
        //     so the navbar can flip instantly without a hard refresh.
        await promoteAndRefreshAuth(req.user.id, res);

        res.json({ success: true, product: linkify(created) });
      } catch (err) {
        console.error("DB insert error (upload):", err.message || err, err.detail || "");
        res.status(500).json({ error: "Database insert failed" });
      }
    };

    if (isVideo(mimeType)) {
      const outputFilename = `video-${Date.now()}.mp4`;
      const outputPath = path.join(uploadDir, outputFilename);

      ffmpeg(inputPath)
        .output(outputPath)
        .on("end", () => {
          try {
            fs.unlinkSync(inputPath);
          } catch {}
          finalizeCreate(outputFilename);
        })
        .on("error", (err) => {
          console.error("FFmpeg error:", err.message || err);
          res.status(500).json({ error: "Video conversion failed" });
        })
        .run();
    } else {
      const finalName = `file-${Date.now()}${path.extname(req.file.originalname)}`;
      const finalPath = path.join(uploadDir, finalName);
      fs.rename(inputPath, finalPath, (err) => {
        if (err) {
          console.error("Rename error:", err.message || err);
          return res.status(500).json({ error: "File save failed" });
        }
        finalizeCreate(finalName);
      });
    }
  }
);

/* ------------------------ CREATE (no file) ------------------------ */
router.post(
  "/new",
  requireAuth,
  standardLimiter,
  validate(productCreateNoFile),
  async (req, res) => {
    const user_id = String(req.user.id || "").trim();
    const { title, description, product_type } = req.body;

    const priceRaw = req.body.price ?? req.body.price_cents ?? 0;
    const priceNum = Number(priceRaw);
    if (Number.isNaN(priceNum)) return res.status(400).json({ error: "Price must be a number" });

    if (!["purchase", "membership", "request"].includes(product_type)) {
      return res.status(400).json({ error: "Invalid product_type" });
    }

    const ready = await ensureCreationReadinessSafe(db, user_id, recomputeCreatorActive);
    if (!ready.ok) {
      return res.status(403).json({
        error: "Finish profile and connect Stripe before creating a product.",
        missing: ready.missing,
        ...(ready.error ? { detail: ready.error } : {}),
      });
    }

    try {
      const created = await insertProduct({
        userIdText: user_id,
        title,
        description,
        product_type,
        price_cents: priceNum,
        filename: null,
      });

      // ⬅️ same: set role/cookie + is_active before responding
      await promoteAndRefreshAuth(req.user.id, res);

      res.status(201).json({ product: linkify(created) });
    } catch (err) {
      console.error("Create product error:", err.message || err, err.detail || "");
      res.status(500).json({ error: "Could not create product" });
    }
  }
);

// GET /api/products/user/:userId
router.get("/user/:userId", async (req, res) => {
  const userIdRaw = String(req.params.userId || "").trim();

  try {
    const result = await db.query(
      `SELECT * FROM products WHERE ${WHERE_USERID_TEXT} ORDER BY created_at DESC`,
      [userIdRaw]
    );
    res.json({ products: result.rows.map(linkify) });
  } catch (err) {
    console.error("Fetch error:", err.message || err);
    res.status(500).json({ error: "Failed to fetch products" });
  }
});

// GET /api/products/:id
router.get("/:id", async (req, res) => {
  const rawId = String(req.params.id || "").trim();
  if (!rawId) return res.status(400).json({ error: "Invalid product id" });

  try {
    const result = await db.query(`SELECT * FROM products WHERE ${WHERE_ID_TEXT}`, [rawId]);
    if (result.rows.length === 0) {
      return res.status(404).json({ error: "Product not found" });
    }
    res.json(linkify(result.rows[0]));
  } catch (err) {
    console.error("Product fetch error:", err.message || err);
    res.status(500).json({ error: "Error fetching product" });
  }
});

/* ------------------------------ DELETE ------------------------------ */
router.delete("/:id", requireAuth, async (req, res) => {
  const rawId = String(req.params.id || "").trim();

  const ownership = await assertOwner(rawId, req.user.id);
  if (ownership.error) return res.status(ownership.code).json({ error: ownership.error });

  try {
    const { rows: pre } = await db.query(
      `SELECT id, filename, active FROM products WHERE ${WHERE_ID_TEXT}`,
      [rawId]
    );
    if (!pre.length) return res.status(404).json({ error: "Product not found" });
    const oldName = pre[0].filename;
    const wasActive = pre[0].active === true;

    await db.query("BEGIN");
    const { rows } = await db.query(
      `DELETE FROM products WHERE ${WHERE_ID_TEXT} RETURNING *`,
      [rawId]
    );
    await db.query("COMMIT");

    if (!rows.length) return res.status(404).json({ error: "Product not found" });
    const deleted = rows[0];

    if (oldName) {
      const fp = path.join(uploadDir, oldName);
      if (fs.existsSync(fp)) {
        try {
          fs.unlinkSync(fp);
        } catch (e) {
          console.warn("Could not delete file:", e.message);
        }
      }
    }

    if (wasActive) {
      await setActiveFromPublished(req.user.id).catch((e) =>
        console.warn("delete -> setActiveFromPublished failed:", e?.message || e)
      );
    }

    return res.json({ success: true, deleted });
  } catch (err) {
    try {
      await db.query("ROLLBACK");
    } catch {}
    console.error("Delete product error:", err.message || err);
    return res.status(500).json({ error: "Failed to delete product" });
  }
});

/* ------------------------------ UPDATE META ------------------------------ */
router.put("/:id", requireAuth, standardLimiter, validate(productUpdate), async (req, res) => {
  const productId = parseInt(req.params.id, 10);

  let { title, description, product_type, price } = req.body;

  if (typeof title === "string") title = title.trim();
  else title = undefined;
  if (typeof description === "string") description = description.trim();
  else description = undefined;

  if (typeof product_type !== "string") product_type = undefined;
  else if (!["purchase", "membership", "request"].includes(product_type)) {
    return res.status(400).json({ error: "Invalid product_type" });
  }

  if (price !== undefined) {
    if (typeof price === "string") {
      if (price.trim() === "") {
        price = undefined;
      } else {
        const parsed = Number(price);
        if (!Number.isFinite(parsed)) return res.status(400).json({ error: "Price must be a number" });
        price = Math.trunc(parsed);
      }
    } else if (typeof price === "number") {
      if (!Number.isFinite(price)) return res.status(400).json({ error: "Price must be a number" });
      price = Math.trunc(price);
    } else {
      price = undefined;
    }
  }

  if (product_type) {
    const { rows: sold } = await db.query(
      "SELECT 1 FROM orders WHERE product_id=$1 AND status='paid' LIMIT 1",
      [productId]
    );
    if (sold.length) {
      return res.status(400).json({ error: "Cannot change product_type after sales exist" });
    }
  }

  const ownership = await assertOwner(productId, req.user.id);
  if (ownership.error) return res.status(ownership.code).json({ error: ownership.error });

  const sets = [];
  const vals = [];
  let i = 1;

  if (title !== undefined) {
    sets.push(`title = $${i++}`);
    vals.push(title);
  }
  if (description !== undefined) {
    sets.push(`description = $${i++}`);
    vals.push(description || null);
  }
  if (product_type !== undefined) {
    sets.push(`product_type = $${i++}`);
    vals.push(product_type);
  }
  if (price !== undefined) {
    sets.push(`price = $${i++}`);
    vals.push(price);
  }

  if (sets.length === 0) return res.status(400).json({ error: "No valid fields to update" });

  if (await hasColumn("products", "updated_at")) sets.push("updated_at = NOW()");

  vals.push(productId);

  try {
    const { rows } = await db.query(
      `UPDATE products SET ${sets.join(", ")} WHERE id = $${i} RETURNING *`,
      vals
    );
    if (!rows.length) return res.status(404).json({ error: "Product not found" });
    return res.json({ success: true, product: linkify(rows[0]) });
  } catch (err) {
    const detail = err?.detail || err?.message || "Could not update product";
    console.error("Update product error:", err);
    return res.status(500).json({ error: detail });
  }
});

/* ------------------------------ UPDATE FILE ------------------------------ */
router.put("/:id/file", requireAuth, upload.single("file"), async (req, res) => {
  const rawId = String(req.params.id || "").trim();
  if (!req.file) return res.status(400).json({ error: "No file uploaded" });

  const ownership = await assertOwner(rawId, req.user.id);
  if (ownership.error) return res.status(ownership.code).json({ error: ownership.error });

  const { rows: prevRows } = await db.query(`SELECT filename FROM products WHERE ${WHERE_ID_TEXT}`, [rawId]);
  const oldName = prevRows[0]?.filename || null;

  const inputPath = req.file.path;
  const mimeType = req.file.mimetype;

  const saveNewFilename = async (newName) => {
    try {
      const sets = ["filename = $1"];
      if (await hasColumn("products", "updated_at")) sets.push("updated_at = NOW()");
      const updated = await db.query(
        `UPDATE products SET ${sets.join(", ")} WHERE ${WHERE_ID_TEXT} RETURNING *`,
        [newName, rawId]
      );

      if (oldName && oldName !== newName) {
        const oldPath = path.join(uploadDir, oldName);
        if (fs.existsSync(oldPath)) {
          try {
            fs.unlinkSync(oldPath);
          } catch (e) {
            console.warn("Delete old file failed:", e.message);
          }
        }
      }

      res.json({ success: true, product: linkify(updated.rows[0]) });
    } catch (err) {
      console.error("File update DB error:", err.message || err);
      res.status(500).json({ error: "Failed to update product file" });
    }
  };

  if (mimeType.startsWith("video/")) {
    const outputFilename = `video-${Date.now()}.mp4`;
    const outputPath = path.join(uploadDir, outputFilename);
    ffmpeg(inputPath)
      .output(outputPath)
      .on("end", () => {
        try {
          fs.unlinkSync(inputPath);
        } catch {}
        saveNewFilename(outputFilename);
      })
      .on("error", () => res.status(500).json({ error: "Video conversion failed" }))
      .run();
  } else {
    const finalName = `file-${Date.now()}${path.extname(req.file.originalname)}`;
    const finalPath = path.join(uploadDir, finalName);
    fs.rename(inputPath, finalPath, (err) => {
      if (err) return res.status(500).json({ error: "File save failed" });
      saveNewFilename(finalName);
    });
  }
});

/* -------------------- publish/unpublish -------------------- */
// You can still manually publish/unpublish; new items default to active on create if column exists.

router.post("/:id/publish", requireAuth, async (req, res) => {
  const rawId = String(req.params.id || "").trim();
  const userId = req.user.id;

  const ownership = await assertOwner(rawId, userId);
  if (ownership.error) return res.status(ownership.code).json({ error: ownership.error });

  const ready = await ensureCreationReadinessSafe(db, userId, recomputeCreatorActive);
  if (!ready.ok) {
    return res.status(403).json({
      error: "Finish profile and connect Stripe before publishing.",
      missing: ready.missing,
      ...(ready.error ? { detail: ready.error } : {}),
    });
  }

  try {
    const sets = ["active = TRUE"];
    if (await hasColumn("products", "updated_at")) sets.push("updated_at = NOW()");
    const { rows } = await db.query(
      `UPDATE products SET ${sets.join(", ")} WHERE ${WHERE_ID_TEXT} RETURNING *`,
      [rawId]
    );
    if (!rows.length) return res.status(404).json({ error: "Product not found" });

    // Promote & activate + refresh cookie
    await promoteAndRefreshAuth(userId, res);

    res.json({ success: true, product: linkify(rows[0]) });
  } catch (e) {
    console.error("Publish product error:", e.message || e);
    res.status(500).json({ error: "Failed to publish product" });
  }
});

router.post("/:id/unpublish", requireAuth, async (req, res) => {
  const rawId = String(req.params.id || "").trim();
  const userId = req.user.id;

  const ownership = await assertOwner(rawId, userId);
  if (ownership.error) return res.status(ownership.code).json({ error: ownership.error });

  try {
    const sets = ["active = FALSE"];
    if (await hasColumn("products", "updated_at")) sets.push("updated_at = NOW()");
    const { rows } = await db.query(
      `UPDATE products SET ${sets.join(", ")} WHERE ${WHERE_ID_TEXT} RETURNING *`,
      [rawId]
    );
    if (!rows.length) return res.status(404).json({ error: "Product not found" });

    // Keep creator_profiles.is_active in sync
    await setActiveFromPublished(userId);

    res.json({ success: true, product: linkify(rows[0]) });
  } catch (e) {
    console.error("Unpublish product error:", e.message || e);
    res.status(500).json({ error: "Failed to unpublish product" });
  }
});

module.exports = router;


===== FILE: sliptail-backend\routes\requests.js =====

const express = require("express");
const path = require("path");
const fs = require("fs");
const multer = require("multer");
const db = require("../db");
const { requireAuth, requireCreator } = require("../middleware/auth");
const { notifyCreatorNewRequest, notifyRequestDelivered } = require("../utils/notify");
const { validate } = require("../middleware/validate");
const { requestCreate, requestDecision, requestDeliver } = require("../validators/schemas");
const { strictLimiter, standardLimiter } = require("../middleware/rateLimit");

const router = express.Router();

/* ---------- Upload setup (must be defined before routes use it) ---------- */

// store attachments in the same uploads folder you already use
const uploadDir = path.join(__dirname, "..", "public", "uploads");
if (!fs.existsSync(uploadDir)) fs.mkdirSync(uploadDir, { recursive: true });

const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, uploadDir),
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname || "");
    cb(null, `req-${Date.now()}${ext}`);
  },
});

const allowed = new Set([
  "application/pdf", "application/epub+zip",
  "image/png", "image/jpeg", "image/webp",
  "video/mp4", "video/quicktime", "video/x-msvideo",
  "text/plain"
]);

const upload = multer({
  storage,
  limits: { fileSize: 2500 * 1024 * 1024 }, // 2.5GB max
  fileFilter: (req, file, cb) => {
    if (!allowed.has(file.mimetype)) {
      return cb(new Error("Unsupported file type"));
    }
    cb(null, true);
  }
});

/* --------------------------- Helper functions --------------------------- */

// Ensure a product is a 'request' product that belongs to creator_id
async function getRequestProduct(productId, creatorId) {
  const { rows } = await db.query(
    `SELECT id, user_id AS creator_id, product_type, price
       FROM products
      WHERE id = $1`,
    [productId]
  );
  const p = rows[0];
  if (!p) return { error: "Product not found", code: 404 };
  if (p.creator_id !== creatorId) return { error: "Product does not belong to this creator", code: 400 };
  if (p.product_type !== "request") return { error: "Product is not a request type", code: 400 };
  return { ok: true, product: p };
}

/* -------------------------------- Routes -------------------------------- */

/**
 * BUYER creates a request for a specific creator + request product
 * Body fields:
 *  - creator_id (int)  -> the seller receiving the request
 *  - product_id (int)  -> the creator's product with product_type='request'
 *  - message (text)    -> buyer's details
 * Optional file field: "attachment"
 *
 * Creates:
 *  - orders row (status='pending', amount from product price)
 *  - custom_requests row (status='pending', with optional attachment_path)
 *
 * Later, Stripe webhook will set orders.status='paid'.
 */
router.post(
  "/create",
  requireAuth,
  strictLimiter,                   // sensitive (creates an order)
  upload.single("attachment"),
  validate(requestCreate),
  async (req, res) => {
    const buyerId = req.user.id;
    const { creator_id, product_id, message } = req.body;

    // basic checks
    if (Number(creator_id) === buyerId) {
      return res.status(400).json({ error: "You cannot request your own product" });
    }

    // attachment path if provided (store only basename)
    const attachment_path = req.file ? path.basename(req.file.path) : null;

    try {
      // 1) validate that product_id is a request product of this creator
      const v = await getRequestProduct(Number(product_id), Number(creator_id));
      if (v.error) return res.status(v.code).json({ error: v.error });

      const amount = Number(v.product.price ?? 0);
      if (Number.isNaN(amount) || amount < 0) {
        return res.status(400).json({ error: "Invalid product price" });
      }

      // 2) Do both writes atomically
      await db.query("BEGIN");

      // create order (pending)
      const { rows: orderRows } = await db.query(
        `INSERT INTO orders (buyer_id, product_id, amount, status, created_at)
         VALUES ($1, $2, $3, 'pending', NOW())
         RETURNING *`,
        [buyerId, product_id, amount]
      );
      const order = orderRows[0];

      // create custom_requests (pending)
      const { rows: reqRows } = await db.query(
        `INSERT INTO custom_requests (order_id, buyer_id, creator_id, details, attachment_path, status, created_at)
         VALUES ($1, $2, $3, $4, $5, 'pending', NOW())
         RETURNING *`,
        [order.id, buyerId, creator_id, message || null, attachment_path]
      );
      const request = reqRows[0];

      await db.query("COMMIT");

      // respond to client
      res.status(201).json({ success: true, order, request });

      // 3) fire-and-forget email notify (correct id reference)
      notifyCreatorNewRequest({ requestId: request.id }).catch(console.error);
    } catch (err) {
      // rollback if we started a tx
      try { await db.query("ROLLBACK"); } catch {}
      console.error("Create request error:", err);
      res.status(500).json({ error: "Failed to create request" });
    }
  }
);

/**
 * (Alt) POST /api/requests
 * Body (multipart/form-data): { orderId, details?, attachment? }
 * Used by older frontend that already has an order (paid or pending for request type).
 * If the order/product is not a request product, rejects.
 */
router.post(
  "/",
  requireAuth,
  strictLimiter,
  upload.single("attachment"),
  async (req, res) => {
    const buyerId = req.user.id;
    const orderId = parseInt(String(req.body.orderId || req.body.order_id || "").trim(), 10);
    const details = (req.body.details || req.body.message || "").toString();
    if (!orderId) return res.status(400).json({ ok: false, error: "orderId required" });

    try {
      const { rows } = await db.query(
        `SELECT o.id AS order_id, o.buyer_id, o.product_id, o.status,
                p.product_type, p.user_id AS creator_id
           FROM orders o
           JOIN products p ON p.id = o.product_id
          WHERE o.id=$1 AND o.buyer_id=$2
          LIMIT 1`,
        [orderId, buyerId]
      );
      const row = rows[0];
      if (!row) return res.status(404).json({ ok: false, error: "Order not found" });
      if (row.product_type !== "request") return res.status(400).json({ ok: false, error: "Not a request order" });

      const attachment_path = req.file ? path.basename(req.file.path) : null;

      const { rows: existing } = await db.query(
        `SELECT id FROM custom_requests WHERE order_id=$1 AND buyer_id=$2`,
        [orderId, buyerId]
      );

      let requestId;
      if (existing.length) {
        const { rows: upd } = await db.query(
          `UPDATE custom_requests
              SET details = COALESCE($3, details),
                  attachment_path = COALESCE($4, attachment_path)
            WHERE id=$1
          RETURNING id` ,
          [existing[0].id, orderId, details || null, attachment_path]
        );
        requestId = upd[0].id;
      } else {
        const { rows: ins } = await db.query(
          `INSERT INTO custom_requests (order_id, buyer_id, creator_id, details, attachment_path, status, created_at)
           VALUES ($1,$2,$3,$4,$5,'pending',NOW())
           RETURNING id`,
          [orderId, buyerId, row.creator_id, details || null, attachment_path]
        );
        requestId = ins[0].id;
      }

      // Only notify creator if this is a new request (no existing)
      if (!existing.length) {
        notifyCreatorNewRequest({ requestId }).catch(console.error);
      }
      return res.status(201).json({ ok: true, requestId });
    } catch (e) {
      console.error("legacy POST /requests error:", e);
      return res.status(500).json({ ok: false, error: "Failed" });
    }
  }
);

/**
 * CREATOR inbox: list requests for me (optionally filter by status)
 * Query: ?status=pending|accepted|declined|delivered
 */
router.get("/inbox", requireAuth, requireCreator, async (req, res) => {
  const creatorId = req.user.id;
  const { status } = req.query;

  try {
    const params = [creatorId];
    let where = `cr.creator_id = $1`;
    if (status) {
      params.push(status);
      where += ` AND cr.status = $2`;
    }

    const { rows } = await db.query(
      `SELECT cr.*, o.status AS order_status, o.amount,
              u.email AS buyer_email, u.username AS buyer_username
         FROM custom_requests cr
         JOIN orders o ON o.id = cr.order_id
         JOIN users u  ON u.id = cr.buyer_id
        WHERE ${where}
        ORDER BY cr.created_at DESC`,
      params
    );

    res.json({ requests: rows });
  } catch (err) {
    console.error("Inbox error:", err);
    res.status(500).json({ error: "Failed to fetch requests" });
  }
});

/**
 * BUYER view: list my requests
 */
router.get("/mine", requireAuth, async (req, res) => {
  const buyerId = req.user.id;
  try {
    const { rows } = await db.query(
      `SELECT cr.*, o.status AS order_status, o.amount
         FROM custom_requests cr
         JOIN orders o ON o.id = cr.order_id
        WHERE cr.buyer_id = $1
        ORDER BY cr.created_at DESC`,
      [buyerId]
    );
    res.json({ requests: rows });
  } catch (err) {
    console.error("My requests error:", err);
    res.status(500).json({ error: "Failed to fetch my requests" });
  }
});

/**
 * CREATOR accepts or declines a request
 * Body: { action: "accept" | "decline" }
 */
router.patch(
  "/:id/decision",
  requireAuth, requireCreator,
  standardLimiter,
  validate(requestDecision),
  async (req, res) => {
    const creatorId = req.user.id;
    const requestId = parseInt(req.params.id, 10);
    const { action } = req.body;

    try {
      // must be this creator's request
      const { rows } = await db.query(
        `SELECT id, status FROM custom_requests WHERE id=$1 AND creator_id=$2`,
        [requestId, creatorId]
      );
      const r = rows[0];
      if (!r) return res.status(404).json({ error: "Request not found" });
      if (r.status !== "pending") return res.status(400).json({ error: "Request is not pending" });

      const newStatus = action === "accept" ? "accepted" : "declined";
      const { rows: upd } = await db.query(
        `UPDATE custom_requests SET status=$1 WHERE id=$2 RETURNING *`,
        [newStatus, requestId]
      );

      res.json({ success: true, request: upd[0] });
    } catch (err) {
      console.error("Decision error:", err);
      res.status(500).json({ error: "Failed to update request" });
    }
  }
);

/**
 * CREATOR delivers a file (only after payment)
 * File field: "file"
 * - checks order is paid
 * - sets custom_requests.status='delivered' and stores attachment_path
 */
router.post(
  "/:id/deliver",
  requireAuth, requireCreator,
  standardLimiter,
  upload.single("file"),
  validate(requestDeliver),
  async (req, res) => {
    const creatorId = req.user.id;
    const requestId = parseInt(req.params.id, 10);

    if (!req.file) return res.status(400).json({ error: "No file uploaded" });

    try {
      // find the request and its order
      const { rows } = await db.query(
        `SELECT cr.id, cr.creator_id, cr.status, cr.order_id, o.status AS order_status
           FROM custom_requests cr
           JOIN orders o ON o.id = cr.order_id
          WHERE cr.id = $1 AND cr.creator_id = $2`,
        [requestId, creatorId]
      );
      const r = rows[0];
      if (!r) return res.status(404).json({ error: "Request not found" });

      // only allow delivery after payment
      if (r.order_status !== "paid") {
        return res.status(400).json({ error: "Order is not paid yet" });
      }

      const newPath = path.basename(req.file.path);
      const { rows: upd } = await db.query(
        `UPDATE custom_requests
            SET attachment_path = $1,
                status = 'delivered'
          WHERE id = $2
          RETURNING *`,
        [newPath, requestId]
      );

      res.json({ success: true, request: upd[0] });

      // notify the buyer that the request was delivered
      notifyRequestDelivered({ requestId }).catch(console.error);
    } catch (err) {
      console.error("Deliver error:", err);
      res.status(500).json({ error: "Failed to deliver file" });
    }
  }
);

/**
 * BUYER downloads the delivered file
 * - only buyer can download
 * - only when status='delivered'
 * Note: purchases download is in routes/downloads.js
 */
router.get("/:id/download", requireAuth, async (req, res) => {
  const requestId = parseInt(req.params.id, 10);
  const userId = req.user.id;

  try {
    const { rows } = await db.query(
      `SELECT attachment_path, status, buyer_id
         FROM custom_requests
        WHERE id = $1`,
      [requestId]
    );
    const r = rows[0];
    if (!r) return res.status(404).json({ error: "Request not found" });
    if (r.buyer_id !== userId) return res.status(403).json({ error: "Not your request" });
    if (r.status !== "delivered") return res.status(403).json({ error: "Not delivered yet" });
    if (!r.attachment_path) return res.status(404).json({ error: "No delivery file" });

    const fullPath = path.join(uploadDir, r.attachment_path);
    if (!fs.existsSync(fullPath)) return res.status(404).json({ error: "File missing on disk" });

    return res.download(fullPath, path.basename(r.attachment_path));
  } catch (e) {
    console.error(e);
    return res.status(500).json({ error: "Download failed" });
  }
});

/* -------------------------- NEW: create-from-session -------------------------- */
/**
 * POST /api/requests/create-from-session
 * Body (multipart/form-data): { session_id: string, message?: string, attachment?: file('attachment') }
 * - Finds the PAID order for the current buyer by stripe_checkout_session_id
 * - Ensures the product is a 'request'
 * - Upserts a row in custom_requests linked to that order
 */
router.post(
  "/create-from-session",
  requireAuth,
  strictLimiter,
  upload.single("attachment"),
  async (req, res) => {
    try {
      const buyerId = req.user.id;
      const sessionId = String(req.body.session_id || "").trim();
      const message = (req.body.message || "").toString();
      if (!sessionId) return res.status(400).json({ error: "session_id is required" });

      // Find the buyer's PAID order by session id
      const { rows } = await db.query(
        `SELECT o.id AS order_id,
                o.buyer_id,
                o.product_id,
                o.status AS order_status,
                p.user_id AS creator_id,
                p.product_type
           FROM orders o
           JOIN products p ON p.id = o.product_id
          WHERE o.buyer_id = $1
            AND o.stripe_checkout_session_id = $2
          LIMIT 1`,
        [buyerId, sessionId]
      );

      const row = rows[0];
      if (!row) return res.status(404).json({ error: "Order not found for this session" });
      if (row.order_status !== "paid") return res.status(400).json({ error: "Order is not paid yet" });
      if (row.product_type !== "request") return res.status(400).json({ error: "Not a request-type product" });

      const attachment_path = req.file ? path.basename(req.file.path) : null;

      // Upsert custom_request for (order_id, buyer_id)
      const existing = await db.query(
        `SELECT id FROM custom_requests WHERE order_id=$1 AND buyer_id=$2`,
        [row.order_id, buyerId]
      );

      let request;
      if (existing.rows.length) {
        const { rows: upd } = await db.query(
          `UPDATE custom_requests
              SET details = COALESCE($3, details),
                  attachment_path = COALESCE($4, attachment_path)
            WHERE id = $1
          RETURNING *`,
          [existing.rows[0].id, row.order_id, message || null, attachment_path]
        );
        request = upd[0];
      } else {
        const { rows: ins } = await db.query(
          `INSERT INTO custom_requests (order_id, buyer_id, creator_id, details, attachment_path, status, created_at)
           VALUES ($1,$2,$3,$4,$5,'pending',NOW())
           RETURNING *`,
          [row.order_id, buyerId, row.creator_id, message || null, attachment_path]
        );
        request = ins[0];
      }

      return res.status(201).json({ success: true, request });
    } catch (e) {
      console.error("create-from-session error:", e);
      return res.status(500).json({ error: "Failed to create request" });
    }
  }
);

module.exports = router;

===== FILE: sliptail-backend\routes\reviews.js =====

const express = require("express");
const db = require("../db");
const { requireAuth, requireAdmin } = require("../middleware/auth");

const router = express.Router();

// ---------- helpers ----------
async function hasEligibility(buyerId, creatorId, productId) {
  // (A) Paid purchase of this creator's product (optionally same product_id)
  const paidPurchase = await db.query(
    `
    SELECT 1
      FROM orders o
      JOIN products p ON p.id = o.product_id
     WHERE o.buyer_id = $1
       AND p.user_id  = $2
       AND o.status   = 'paid'
       ${productId ? "AND p.id = $3" : ""}
     LIMIT 1
    `,
    productId ? [buyerId, creatorId, productId] : [buyerId, creatorId]
  );

  if (paidPurchase.rows.length) return true;

  // (B) Delivered request with this creator
  const deliveredReq = await db.query(
    `
    SELECT 1
      FROM custom_requests cr
     WHERE cr.buyer_id   = $1
       AND cr.creator_id = $2
       AND cr.status     = 'delivered'
     LIMIT 1
    `,
    [buyerId, creatorId]
  );
  if (deliveredReq.rows.length) return true;

  // (C) Active membership with access now
  const activeMember = await db.query(
    `
    SELECT 1
      FROM memberships m
     WHERE m.buyer_id  = $1
       AND m.creator_id= $2
       AND m.status IN ('active','trialing')
       AND NOW() <= m.current_period_end
     LIMIT 1
    `,
    [buyerId, creatorId]
  );
  if (activeMember.rows.length) return true;

  return false;
}

function sanitizeRating(n) {
  const r = parseInt(n, 10);
  if (Number.isNaN(r) || r < 1 || r > 5) return null;
  return r;
}

// ---------- routes ----------

/**
 * POST /api/reviews
 * Body: { creator_id, rating (1-5), comment?, product_id? }
 * - Only logged-in users
 * - Cannot review yourself
 * - Must have eligibility (paid purchase / delivered request / active membership)
 * - If user already reviewed this creator, we update their existing review (MVP)
 */
router.post("/", requireAuth, async (req, res) => {
  const buyerId = req.user.id;
  const { creator_id, rating, comment, product_id } = req.body || {};
  const creatorId = parseInt(creator_id, 10);
  const productId = product_id ? parseInt(product_id, 10) : null;

  if (!creatorId) return res.status(400).json({ error: "creator_id is required" });
  const r = sanitizeRating(rating);
  if (!r) return res.status(400).json({ error: "rating must be an integer between 1 and 5" });
  if (creatorId === buyerId) return res.status(400).json({ error: "You cannot review yourself" });

  try {
    const eligible = await hasEligibility(buyerId, creatorId, productId || undefined);
    if (!eligible) return res.status(403).json({ error: "Not eligible to review this creator" });

    // If an existing review by this buyer for this creator exists, update it; else insert
    const { rows: existing } = await db.query(
      `SELECT id FROM reviews WHERE buyer_id=$1 AND creator_id=$2 LIMIT 1`,
      [buyerId, creatorId]
    );

    if (existing.length) {
      const { rows } = await db.query(
        `UPDATE reviews
            SET rating=$1,
                comment=$2,
                product_id=$3,
                updated_at=NOW()
          WHERE id=$4
          RETURNING *`,
        [r, comment ?? null, productId, existing[0].id]
      );
      return res.json({ review: rows[0], updated: true });
    } else {
      const { rows } = await db.query(
        `INSERT INTO reviews (product_id, creator_id, buyer_id, rating, comment, created_at)
         VALUES ($1,$2,$3,$4,$5,NOW())
         RETURNING *`,
        [productId, creatorId, buyerId, r, comment ?? null]
      );
      return res.status(201).json({ review: rows[0], created: true });
    }
  } catch (e) {
    console.error("create review error:", e);
    res.status(500).json({ error: "Failed to submit review" });
  }
});

/**
 * PATCH /api/reviews/:id
 * Body: { rating?, comment? }
 * - Only the author (buyer) can edit their review
 */
router.patch("/:id", requireAuth, async (req, res) => {
  const id = parseInt(req.params.id, 10);
  const buyerId = req.user.id;
  const r = req.body.rating != null ? sanitizeRating(req.body.rating) : null;
  const comment = req.body.comment ?? null;

  if (req.body.rating != null && !r) {
    return res.status(400).json({ error: "rating must be 1..5" });
  }

  try {
    const { rows: owned } = await db.query(
      `SELECT id FROM reviews WHERE id=$1 AND buyer_id=$2`,
      [id, buyerId]
    );
    if (!owned.length) return res.status(403).json({ error: "Not your review" });

    const { rows } = await db.query(
      `UPDATE reviews
          SET rating = COALESCE($1, rating),
              comment = COALESCE($2, comment),
              updated_at = NOW()
        WHERE id=$3
        RETURNING *`,
      [r, comment, id]
    );

    res.json({ review: rows[0] });
  } catch (e) {
    console.error("edit review error:", e);
    res.status(500).json({ error: "Failed to edit review" });
  }
});

/**
 * DELETE /api/reviews/:id
 * - The author or an admin can delete
 */
router.delete("/:id", requireAuth, async (req, res) => {
  const id = parseInt(req.params.id, 10);
  const userId = req.user.id;
  const isAdmin = req.user.role === "admin";

  try {
    const { rows: rev } = await db.query(
      `SELECT id, buyer_id FROM reviews WHERE id=$1`,
      [id]
    );
    if (!rev.length) return res.status(404).json({ error: "Review not found" });

    if (!isAdmin && rev[0].buyer_id !== userId) {
      return res.status(403).json({ error: "Not allowed" });
    }

    await db.query(`DELETE FROM reviews WHERE id=$1`, [id]);
    res.json({ success: true });
  } catch (e) {
    console.error("delete review error:", e);
    res.status(500).json({ error: "Failed to delete review" });
  }
});

/**
 * PUBLIC: list reviews for a creator (paginated)
 * GET /api/reviews/creator/:creatorId?limit=20&offset=0
 */
router.get("/creator/:creatorId", async (req, res) => {
  const creatorId = parseInt(req.params.creatorId, 10);
  const limit = Math.min(parseInt(req.query.limit || "20", 10), 100);
  const offset = Math.max(parseInt(req.query.offset || "0", 10), 0);

  try {
    const { rows } = await db.query(
      `SELECT r.*, u.username AS buyer_username
         FROM reviews r
         JOIN users u ON u.id = r.buyer_id
        WHERE r.creator_id = $1
        ORDER BY r.created_at DESC
        LIMIT $2 OFFSET $3`,
      [creatorId, limit, offset]
    );

    // also return a quick summary
    const { rows: summary } = await db.query(
      `SELECT
          COUNT(*)::int                         AS total,
          COALESCE(AVG(rating),0)::numeric(3,2) AS average,
          COALESCE(SUM(CASE WHEN rating=5 THEN 1 ELSE 0 END),0)::int AS star5,
          COALESCE(SUM(CASE WHEN rating=4 THEN 1 ELSE 0 END),0)::int AS star4,
          COALESCE(SUM(CASE WHEN rating=3 THEN 1 ELSE 0 END),0)::int AS star3,
          COALESCE(SUM(CASE WHEN rating=2 THEN 1 ELSE 0 END),0)::int AS star2,
          COALESCE(SUM(CASE WHEN rating=1 THEN 1 ELSE 0 END),0)::int AS star1
        FROM reviews
       WHERE creator_id=$1`,
      [creatorId]
    );

    res.json({ reviews: rows, summary: summary[0] });
  } catch (e) {
    console.error("list reviews error:", e);
    res.status(500).json({ error: "Failed to fetch reviews" });
  }
});

/**
 * PUBLIC: review summary only (avg + counts)
 * GET /api/reviews/summary/:creatorId
 */
router.get("/summary/:creatorId", async (req, res) => {
  const creatorId = parseInt(req.params.creatorId, 10);
  try {
    const { rows } = await db.query(
      `SELECT
          COUNT(*)::int                         AS total,
          COALESCE(AVG(rating),0)::numeric(3,2) AS average,
          COALESCE(SUM(CASE WHEN rating=5 THEN 1 ELSE 0 END),0)::int AS star5,
          COALESCE(SUM(CASE WHEN rating=4 THEN 1 ELSE 0 END),0)::int AS star4,
          COALESCE(SUM(CASE WHEN rating=3 THEN 1 ELSE 0 END),0)::int AS star3,
          COALESCE(SUM(CASE WHEN rating=2 THEN 1 ELSE 0 END),0)::int AS star2,
          COALESCE(SUM(CASE WHEN rating=1 THEN 1 ELSE 0 END),0)::int AS star1
        FROM reviews
       WHERE creator_id=$1`,
      [creatorId]
    );
    res.json(rows[0]);
  } catch (e) {
    console.error("summary error:", e);
    res.status(500).json({ error: "Failed to fetch review summary" });
  }
});

module.exports = router;

===== FILE: sliptail-backend\routes\settings.js =====

const express = require("express");
const db = require("../db");
const { requireAuth } = require("../middleware/auth");

const router = express.Router();

/**
 * GET my notification prefs
 */
router.get("/notifications", requireAuth, async (req, res) => {
  const { rows } = await db.query(
    `SELECT
       notify_post,
       notify_membership_expiring,
       notify_purchase,
       notify_request_completed,
       notify_new_request,
       notify_product_sale
     FROM users WHERE id=$1`,
    [req.user.id]
  );
  if (!rows.length) return res.status(404).json({ error: "User not found" });
  res.json(rows[0]);
});

/**
 * PUT update some/all notification toggles
 * Body: any subset of the boolean fields above
 */
router.put("/notifications", requireAuth, async (req, res) => {
  const allowed = [
    "notify_post",
    "notify_membership_expiring",
    "notify_purchase",
    "notify_request_completed",
    "notify_new_request",
    "notify_product_sale",
  ];
  const updates = [];
  const params = [req.user.id];
  let idx = 2;

  for (const key of allowed) {
    if (key in req.body && typeof req.body[key] === "boolean") {
      updates.push(`${key} = $${idx++}`);
      params.push(req.body[key]);
    }
  }

  if (!updates.length) {
    return res.status(400).json({ error: "No valid fields to update" });
  }

  const sql = `UPDATE users SET ${updates.join(", ")} WHERE id=$1 RETURNING
    notify_post,
    notify_membership_expiring,
    notify_purchase,
    notify_request_completed,
    notify_new_request,
    notify_product_sale`;

  const { rows } = await db.query(sql, params);
  res.json(rows[0]);
});

module.exports = router;

===== FILE: sliptail-backend\routes\stripe.js =====

const express = require("express");
const router = express.Router();
const Stripe = require("stripe");
const db = require("../db");
require("dotenv").config();

const stripe = Stripe(process.env.STRIPE_SECRET_KEY);

// Create or reuse a creator’s Stripe Connect account
router.post("/connect", async (req, res) => {
  const { userId } = req.body;

  try {
    // 1. Get the creator from the DB
    const result = await db.query("SELECT * FROM users WHERE id = $1", [userId]);
    const user = result.rows[0];

    // 2. If they already have a Stripe account, return success
    if (user.stripe_account_id) {
      return res.json({ message: "Stripe account already set up" });
    }

    // 3. Create new Stripe Connect account
    const account = await stripe.accounts.create({
      type: "standard",
    });

    // 4. Save account ID to the database
    await db.query("UPDATE users SET stripe_account_id = $1 WHERE id = $2", [
      account.id,
      userId,
    ]);

    // 5. Generate the onboarding link
    const accountLink = await stripe.accountLinks.create({
      account: account.id,
      refresh_url: "http://localhost:5000/stripe-refresh",
      return_url: "http://localhost:5000/stripe-success",
      type: "account_onboarding",
    });

    res.json({ url: accountLink.url });
  } catch (err) {
    console.error("Stripe Connect error:", err);
    res.status(500).json({ error: "Stripe connection failed" });
  }
});

module.exports = router;

===== FILE: sliptail-backend\routes\stripeCheckout.js =====

// routes/stripeCheckout.js
const express = require("express");
const Stripe = require("stripe");
const db = require("../db");
const { requireAuth } = require("../middleware/auth");
const { validate } = require("../middleware/validate");
const { checkoutSession } = require("../validators/schemas");
const { strictLimiter } = require("../middleware/rateLimit");

const router = express.Router();
const stripe = Stripe(process.env.STRIPE_SECRET_KEY);

// 4% fee in basis points (default 400 bps)
const PLATFORM_FEE_BPS = parseInt(process.env.PLATFORM_FEE_BPS || "400", 10);

// NOTE: products.price is integer **cents** in your DB. Do NOT multiply by 100 again.

// Success/cancel fallback URLs (frontend can override in body)
const FRONTEND = (process.env.FRONTEND_URL || "http://localhost:3000").replace(/\/$/, "");

// Helper that respects client-provided URLs and only appends the session if absent
function ensureSuccessUrl(rawUrl, fallbackPath = "/checkout/success") {
  const base = rawUrl || `${FRONTEND}${fallbackPath}`;
  if (base.includes("{CHECKOUT_SESSION_ID}")) return base; // client already provided a template
  const sep = base.includes("?") ? "&" : "?";
  return `${base}${sep}session_id={CHECKOUT_SESSION_ID}`;
}
function ensureCancelUrl(rawUrl, fallbackPath = "/checkout/cancel") {
  return rawUrl || `${FRONTEND}${fallbackPath}`;
}

/**
 * POST /api/stripe-checkout/create-session
 * body: { product_id: number, mode: "payment"|"subscription", success_url?, cancel_url? }
 */
router.post(
  "/create-session",
  requireAuth,
  strictLimiter,
  validate(checkoutSession),
  async (req, res) => {
    const buyerId = req.user.id;
    const {
      product_id,
      mode, // "payment" for purchase/request, "subscription" for membership
      success_url,
      cancel_url,
    } = req.body || {};

    // 1) Load product and creator’s connect account
    const { rows } = await db.query(
      `
      SELECT
        p.id,
        p.title,
        p.product_type,       -- e.g. 'download' | 'request' | 'membership' (adapt to your enum)
        p.price,              -- integer cents
        p.user_id AS creator_id,
        u.stripe_account_id
      FROM products p
      JOIN users u ON u.id = p.user_id
      WHERE p.id = $1
      `,
      [product_id]
    );
    const p = rows[0];
    if (!p) return res.status(404).json({ error: "Product not found" });

    if (!p.stripe_account_id) {
      return res.status(400).json({ error: "Creator has not completed Stripe onboarding" });
    }

    // Compute cents from DB value (already cents)
    const amountCents = Number(p.price);
    if (!Number.isFinite(amountCents) || amountCents <= 0) {
      return res.status(400).json({ error: "Invalid price" });
    }

    const feeAmount = Math.floor((amountCents * PLATFORM_FEE_BPS) / 10000); // bps of price

    // Respect client URLs and append session id only if needed
    const successUrl = ensureSuccessUrl(success_url);
    const cancelUrl = ensureCancelUrl(cancel_url);

    // Derive an action label used by webhook/finalizer routing
    // - payment + product_type 'request' -> 'request'
    // - payment otherwise -> 'purchase'
    // - subscription -> 'membership'
    const productType = String(p.product_type || "").toLowerCase();
    const action =
      mode === "subscription"
        ? "membership"
        : productType === "request"
        ? "request"
        : "purchase";

    // Defensive: prevent obvious mode/type mismatch
    if (mode === "subscription" && productType === "download") {
      return res.status(400).json({ error: "This product is not a subscription" });
    }

    // Common metadata we want to see again in webhooks/finalizer
    const baseMetadata = {
      action,                         // "purchase" | "request" | "membership"
      product_id: String(p.id),
      product_type: String(p.product_type || ""),
      creator_id: String(p.creator_id),
      buyer_id: String(buyerId),
    };

    // Optional client-provided idempotency key
    const clientKey = req.get("x-idempotency-key");

    let session;

    if (mode === "payment") {
      // ────────────────────────────────────────────────────────────────────────────
      // ONE-TIME: Create a PENDING order now; mark it PAID in webhook/finalizer
      // ────────────────────────────────────────────────────────────────────────────

      // DB matches your schema: amount_cents integer NOT NULL
      const { rows: ord } = await db.query(
        `
        INSERT INTO public.orders
          (buyer_id, product_id, amount_cents, status, created_at)
        VALUES
          ($1, $2, $3, 'pending', NOW())
        RETURNING id
        `,
        [buyerId, p.id, amountCents]
      );
      const orderId = ord[0].id;

      const payload = {
        mode: "payment",
        line_items: [
          {
            price_data: {
              currency: "usd",
              product_data: { name: p.title || p.product_type || "Item" },
              unit_amount: amountCents, // cents
            },
            quantity: 1,
          },
        ],
        payment_intent_data: {
          application_fee_amount: feeAmount,
          transfer_data: { destination: p.stripe_account_id },
          metadata: { ...baseMetadata, order_id: String(orderId) },
        },
        metadata: { ...baseMetadata, order_id: String(orderId) },
        success_url: successUrl, // -> /checkout/success?...session_id={CHECKOUT_SESSION_ID}
        cancel_url: cancelUrl,
      };

      // Use client key if provided; else a stable order-based key
      const idempotencyKey = clientKey || `co_${orderId}`;

      session = await stripe.checkout.sessions.create(payload, { idempotencyKey });

      // Stash session id on the order (useful for support and request form)
      await db.query(
        `UPDATE public.orders SET stripe_checkout_session_id = $1 WHERE id = $2`,
        [session.id, orderId]
      );
    } else if (mode === "subscription") {
      // ────────────────────────────────────────────────────────────────────────────
      // SUBSCRIPTION: No orders row now; webhook/finalizer will upsert membership
      // ────────────────────────────────────────────────────────────────────────────

      const feePercent = PLATFORM_FEE_BPS / 100.0; // 400 -> 4.0%

      const payload = {
        mode: "subscription",
        line_items: [
          {
            price_data: {
              currency: "usd",
              product_data: { name: p.title || "Membership" },
              recurring: { interval: "month" },
              unit_amount: amountCents, // cents
            },
            quantity: 1,
          },
        ],
        subscription_data: {
          application_fee_percent: feePercent,
          transfer_data: { destination: p.stripe_account_id },
          metadata: baseMetadata,
        },
        metadata: baseMetadata,
        success_url: successUrl, // -> /checkout/success?...session_id={CHECKOUT_SESSION_ID}
        cancel_url: cancelUrl,
      };

      // If you want multiple concurrent subs to same product, provide unique X-Idempotency-Key from client
      const idempotencyKey = clientKey || `sub_${buyerId}_${p.id}`;
      session = await stripe.checkout.sessions.create(payload, { idempotencyKey });
    } else {
      return res.status(400).json({ error: "mode must be 'payment' or 'subscription'" });
    }

    return res.json({ url: session.url, id: session.id });
  }
);

/**
 * GET /api/stripe-checkout/finalize?session_id=cs_...
 * Auth required (ensures the session belongs to this buyer).
 * Provides a resilient fallback in case webhooks were delayed or not yet configured.
 * Response shape consumed by frontend success page:
 *  { ok:true, type:"purchase"|"membership"|"request", creatorDisplayName:string, orderId:number|null }
 */
router.get("/finalize", requireAuth, async (req, res) => {
  const sessionId = String(req.query.session_id || req.query.sessionId || "").trim();
  if (!sessionId) return res.status(400).json({ ok: false, error: "session_id is required" });

  try {
    // Retrieve checkout session + expand to reduce round-trips
    const session = await stripe.checkout.sessions.retrieve(sessionId, {
      expand: ["payment_intent", "subscription"],
    });

    if (!session) return res.status(404).json({ ok: false, error: "Session not found" });

    const meta = session.metadata || {};
    const action = (meta.action || "").toLowerCase();
    const buyerIdMeta = meta.buyer_id && parseInt(meta.buyer_id, 10);
    if (buyerIdMeta && buyerIdMeta !== req.user.id) {
      return res.status(403).json({ ok: false, error: "Not your session" });
    }

    // Helper: fetch creator display name by product id
    async function getCreatorInfo(productId) {
      if (!productId) return { display_name: "Creator", product_type: null };
      const { rows } = await db.query(
        `SELECT cp.display_name, p.product_type
           FROM products p
      LEFT JOIN creator_profiles cp ON cp.user_id = p.user_id
          WHERE p.id = $1
          LIMIT 1`,
        [productId]
      );
      return rows[0] || { display_name: "Creator", product_type: null };
    }

    if (session.mode === "payment") {
      // Attempt to mark the related order paid (mirrors webhook logic) if payment succeeded.
      const paid = session.payment_status === "paid" || session.status === "complete";
      const orderId = meta.order_id ? parseInt(meta.order_id, 10) : null;
      let finalOrderId = orderId;

      if (paid && orderId) {
        await db.query(
          `UPDATE public.orders
              SET status='paid',
                  stripe_payment_intent_id = COALESCE(stripe_payment_intent_id, $1),
                  stripe_checkout_session_id = COALESCE(stripe_checkout_session_id, $2)
            WHERE id=$3 AND status <> 'paid'`,
          [session.payment_intent || null, session.id, orderId]
        );
      }

      // Fallback: if we somehow never created the pending order (edge), create it now.
      if (paid && !finalOrderId) {
        const productId = meta.product_id ? parseInt(meta.product_id, 10) : null;
        if (productId) {
          const amount = Number.isFinite(session.amount_total) ? Number(session.amount_total) : 0;
            const { rows } = await db.query(
              `INSERT INTO public.orders (buyer_id, product_id, amount_cents, stripe_payment_intent_id, status, created_at, stripe_checkout_session_id)
               VALUES ($1,$2,$3,$4,'paid',NOW(),$5)
               RETURNING id`,
              [req.user.id, productId, amount, session.payment_intent || null, session.id]
            );
            finalOrderId = rows[0].id;
        }
      }

      const productId = meta.product_id ? parseInt(meta.product_id, 10) : null;
      const { display_name, product_type } = await getCreatorInfo(productId);
      const respType = action || (product_type === "request" ? "request" : "purchase");
      return res.json({ ok: true, type: respType, creatorDisplayName: display_name || "Creator", orderId: finalOrderId });
    }

    if (session.mode === "subscription") {
      // Ensure we have customer saved
      if (session.customer) {
        await db.query(
          `UPDATE users SET stripe_customer_id=$1 WHERE id=$2 AND (stripe_customer_id IS NULL OR stripe_customer_id <> $1)` ,
          [session.customer, req.user.id]
        );
      }

      // Upsert membership (mirrors webhook) if subscription object + metadata present
      const subscription = session.subscription && typeof session.subscription === "object" ? session.subscription : null;
      let subObj = subscription;
      if (!subObj && typeof session.subscription === "string") {
        try { subObj = await stripe.subscriptions.retrieve(session.subscription); } catch(_) {}
      }
      if (subObj && subObj.metadata) {
        const m = subObj.metadata;
        const buyerId = m.buyer_id && parseInt(m.buyer_id, 10);
        const creatorId = m.creator_id && parseInt(m.creator_id, 10);
        const productId = m.product_id && parseInt(m.product_id, 10);
        if (buyerId && creatorId && productId && buyerId === req.user.id) {
          const currentPeriodEnd = new Date((subObj.current_period_end || 0) * 1000);
          await db.query(
            `INSERT INTO memberships (buyer_id, creator_id, product_id, stripe_subscription_id, status, current_period_end, created_at)
             VALUES ($1,$2,$3,$4,$5,$6,NOW())
             ON CONFLICT (stripe_subscription_id) DO UPDATE
               SET status=EXCLUDED.status,
                   current_period_end=EXCLUDED.current_period_end`,
            [buyerId, creatorId, productId, subObj.id, subObj.status, currentPeriodEnd]
          );
          const { display_name } = await getCreatorInfo(productId);
          return res.json({ ok: true, type: "membership", creatorDisplayName: display_name || "Creator", orderId: null });
        }
      }
      return res.json({ ok: true, type: "membership", creatorDisplayName: "Creator", orderId: null });
    }

    return res.status(400).json({ ok: false, error: "Unsupported session mode" });
  } catch (e) {
    console.error("Finalize error:", e);
    return res.status(500).json({ ok: false, error: "Failed to finalize session" });
  }
});

module.exports = router;


===== FILE: sliptail-backend\routes\stripeConnect.js =====

// routes/stripeconnect.js
const express = require("express");
const Stripe = require("stripe");
const db = require("../db");
const { requireAuth } = require("../middleware/auth");
const { recomputeCreatorActive } = require("../services/creatorStatus");

const router = express.Router();

if (!process.env.STRIPE_SECRET_KEY) {
  console.warn("[stripeconnect] STRIPE_SECRET_KEY is not set. Stripe endpoints will fail.");
}
const stripe = Stripe(process.env.STRIPE_SECRET_KEY || "");

// Prefer FRONTEND_URL; fall back to APP_URL; default to local Next dev URL
const FRONTEND_BASE = (
  process.env.FRONTEND_URL ||
  process.env.APP_URL ||
  "http://localhost:3000"
).replace(/\/$/, "");

// Optional: set this if you add the webhook below
const WEBHOOK_SECRET = process.env.STRIPE_WEBHOOK_SECRET || "";

/* ----------------------------- helpers ----------------------------- */

/** Best-effort create; if your table already exists with a different shape, we handle it dynamically below. */
async function ensureStripeConnectTable() {
  await db
    .query(`
      CREATE TABLE IF NOT EXISTS stripe_connect (
        user_id TEXT PRIMARY KEY,
        stripe_account_id TEXT,
        details_submitted BOOLEAN DEFAULT FALSE,
        charges_enabled   BOOLEAN DEFAULT FALSE,
        payouts_enabled   BOOLEAN DEFAULT FALSE,
        connected_at      TIMESTAMP NULL,
        updated_at        TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `)
    .catch(() => {
      // If an older table exists (e.g., user_id INT, account_id TEXT), that's OK — we adapt at runtime.
    });
}

/** Inspect existing stripe_connect schema (supports legacy: account_id + integer user_id). */
async function detectStripeConnectSchema() {
  const { rows } = await db.query(`
    SELECT column_name, data_type
    FROM information_schema.columns
    WHERE table_schema='public' AND table_name='stripe_connect'
  `);

  const hasStripeAccountId = rows.some(r => r.column_name === "stripe_account_id");
  const hasAccountId       = rows.some(r => r.column_name === "account_id");
  const accountCol         = hasStripeAccountId ? "stripe_account_id" : (hasAccountId ? "account_id" : null);

  const userCol = rows.find(r => r.column_name === "user_id");
  const userIsInteger = !!userCol && /integer/.test(userCol.data_type);

  const hasConnectedAt = rows.some(r => r.column_name === "connected_at");

  if (!accountCol) {
    throw new Error("stripe_connect table must have either 'stripe_account_id' or 'account_id' column");
  }

  return { accountCol, userIsInteger, hasConnectedAt };
}

/**
 * Persist Stripe Account flags to DB and mirror to other tables (schema-adaptive).
 * - Upserts into `stripe_connect` (works with account_id or stripe_account_id; user_id INT or TEXT)
 * - UPSERT-mirrors to `creator_profiles.stripe_charges_enabled` when that column exists
 * - We do NOT decide users.stripe_connected here; you already flip it when account_id is created.
 */
async function upsertStripeState(userId, acct) {
  const uid = String(userId);
  const accountId = acct?.id || null;
  const details_submitted = !!acct?.details_submitted;
  const charges_enabled   = !!acct?.charges_enabled;
  const payouts_enabled   = !!acct?.payouts_enabled;

  await ensureStripeConnectTable();

  // Detect actual schema and build a compatible upsert
  const { accountCol, userIsInteger, hasConnectedAt } = await detectStripeConnectSchema();

  // user_id casting
  const userParam = userIsInteger ? "CAST($1 AS integer)" : "$1";

  // columns + values
  const insertCols = [
    "user_id",
    accountCol,
    "details_submitted",
    "charges_enabled",
    "payouts_enabled",
    ...(hasConnectedAt ? ["connected_at"] : []),
    "updated_at",
  ];

  const insertValsSql = [
    userParam, "$2", "$3", "$4", "$5",
    ...(hasConnectedAt ? ["CASE WHEN $3 = TRUE THEN NOW() ELSE NULL END"] : []),
    "NOW()",
  ];

  // conflict updates
  const setPairs = [
    `${accountCol} = COALESCE(EXCLUDED.${accountCol}, stripe_connect.${accountCol})`,
    `details_submitted = EXCLUDED.details_submitted`,
    `charges_enabled   = EXCLUDED.charges_enabled`,
    `payouts_enabled   = EXCLUDED.payouts_enabled`,
    ...(hasConnectedAt
      ? [
          `connected_at = CASE
                             WHEN EXCLUDED.details_submitted = TRUE
                                  AND stripe_connect.connected_at IS NULL
                             THEN NOW()
                             ELSE stripe_connect.connected_at
                           END`,
        ]
      : []),
    `updated_at        = NOW()`,
  ];

  // perform upsert
  await db.query(
    `
    INSERT INTO stripe_connect (${insertCols.join(", ")})
    VALUES (${insertValsSql.join(", ")})
    ON CONFLICT (user_id) DO UPDATE
      SET ${setPairs.join(", ")}
    `,
    [uid, accountId, details_submitted, charges_enabled, payouts_enabled]
  );

  // Mirror to creator_profiles.stripe_charges_enabled if the column exists; UPSERT so new creators get a row.
  try {
    const { rows: hasCol } = await db.query(
      `
      SELECT 1
        FROM information_schema.columns
       WHERE table_schema='public'
         AND table_name='creator_profiles'
         AND column_name='stripe_charges_enabled'
       LIMIT 1
      `
    );
    if (hasCol.length) {
      await db.query(
        `
        INSERT INTO creator_profiles (user_id, stripe_charges_enabled, updated_at)
        VALUES ($1, $2, NOW())
        ON CONFLICT (user_id) DO UPDATE
          SET stripe_charges_enabled = EXCLUDED.stripe_charges_enabled,
              updated_at = NOW()
        `,
        [uid, charges_enabled]
      );
    }
  } catch (e) {
    if (!/stripe_charges_enabled/.test(String(e.message))) {
      console.warn("creator_profiles upsert warn:", e.message || e);
    }
  }

  return { account_id: accountId, details_submitted, charges_enabled, payouts_enabled };
}

/* ------------------------------ routes ------------------------------ */

/**
 * POST /api/stripe-connect/create-link
 * Creates (or reuses) a Stripe Express account and:
 *   - writes users.stripe_account_id
 *   - flips users.stripe_connected = TRUE (keeps your behavior)
 *   - returns onboarding link (if not finished) or login link (if finished)
 */
router.post("/create-link", requireAuth, async (req, res) => {
  const userId = req.user.id;

  try {
    // 1) Load user & existing account id (if any)
    const { rows } = await db.query(
      `SELECT id, email, stripe_account_id
         FROM users
        WHERE id=$1
        LIMIT 1`,
      [userId]
    );
    const me = rows[0];
    if (!me) return res.status(404).json({ error: "User not found" });

    let accountId = me.stripe_account_id || null;

    // 2) Create Express account if missing
    if (!accountId) {
      const account = await stripe.accounts.create({
        type: "express",
        email: me.email || undefined,
        capabilities: {
          card_payments: { requested: true },
          transfers: { requested: true },
        },
      });

      accountId = account.id;

      // Write both account_id AND stripe_connected=TRUE
      await db.query(
        `UPDATE users
            SET stripe_account_id=$1,
                stripe_connected=TRUE,
                updated_at=NOW()
          WHERE id=$2`,
        [accountId, userId]
      );

      // Seed stripe_connect so /sync can always find it
      try {
        await ensureStripeConnectTable();
        const { accountCol, userIsInteger } = await detectStripeConnectSchema();
        const userParam = userIsInteger ? "CAST($1 AS integer)" : "$1";

        await db.query(
          `
          INSERT INTO stripe_connect (user_id, ${accountCol}, updated_at)
          VALUES (${userParam}, $2, NOW())
          ON CONFLICT (user_id) DO UPDATE
            SET ${accountCol} = EXCLUDED.${accountCol},
                updated_at = NOW()
          `,
          [String(userId), accountId]
        );
      } catch (seedErr) {
        console.warn("[create-link] seed stripe_connect warn:", seedErr.message || seedErr);
      }

      // Optional: initial snapshot (flags likely false until onboarding completes)
      try { await upsertStripeState(userId, account); } catch (_) {}
    }

    // 3) Retrieve the account to decide the flow
    const acct = await stripe.accounts.retrieve(accountId);
    const needsOnboarding = !acct.details_submitted;

    // Persist latest flags
    try { await upsertStripeState(userId, acct); } catch (_) {}

    if (needsOnboarding) {
      const link = await stripe.accountLinks.create({
        account: accountId,
        type: "account_onboarding",
        refresh_url: `${FRONTEND_BASE}/creator/setup?refresh=1`,
        return_url: `${FRONTEND_BASE}/creator/setup?onboarded=1`,
      });
      return res.json({ url: link.url, account_id: accountId, mode: "onboarding" });
    }

    const loginLink = await stripe.accounts.createLoginLink(accountId, {
      redirect_url: `${FRONTEND_BASE}/dashboard`,
    });
    return res.json({ url: loginLink.url, account_id: accountId, mode: "manage" });
  } catch (e) {
    console.error("Stripe Connect create-link error:", e);
    return res.status(500).json({ error: "Failed to create Stripe account link" });
  }
});

/**
 * POST /api/stripe-connect/sync
 * Refreshes from Stripe and persists flags to DB.
 */
router.post("/sync", requireAuth, async (req, res) => {
  const userId = req.user.id;

  try {
    const { rows } = await db.query(
      `SELECT stripe_account_id FROM users WHERE id=$1 LIMIT 1`,
      [userId]
    );
    const accountId = rows[0]?.stripe_account_id;
    if (!accountId) {
      return res.status(400).json({ error: "No connected account on file" });
    }

    const acct = await stripe.accounts.retrieve(accountId);

    const snapshot = await upsertStripeState(userId, acct);

    let creator_status = null;
    try {
      creator_status = await recomputeCreatorActive(db, userId);
    } catch (_statusErr) {}

    return res.json({
      synced: true,
      account_id: snapshot.account_id,
      details_submitted: snapshot.details_submitted,
      charges_enabled: snapshot.charges_enabled,
      payouts_enabled: snapshot.payouts_enabled,
      creator_status,
    });
  } catch (e) {
    console.error("Stripe Connect sync error:", e);
    return res.status(500).json({ error: "Failed to sync Stripe account" });
  }
});

/**
 * GET /api/stripe-connect/status
 */
router.get("/status", requireAuth, async (req, res) => {
  const userId = req.user.id;

  try {
    const { rows } = await db.query(
      `SELECT stripe_account_id FROM users WHERE id=$1`,
      [userId]
    );
    const accountId = rows[0]?.stripe_account_id;
    if (!accountId) {
      return res.json({ has_account: false });
    }

    const acct = await stripe.accounts.retrieve(accountId);
    try { await upsertStripeState(userId, acct); } catch (_) {}

    return res.json({
      has_account: true,
      charges_enabled: !!acct.charges_enabled,
      payouts_enabled: !!acct.payouts_enabled,
      details_submitted: !!acct.details_submitted,
    });
  } catch (e) {
    console.error("Stripe Connect status error:", e);
    return res.status(500).json({ error: "Failed to fetch Stripe account status" });
  }
});

/* ------------ OPTIONAL: webhook to keep stripe_connect in sync ------------- */
// Enable this if you want automatic updates after KYC completes.
// In Stripe Dashboard, point a webhook to /api/stripe-connect/webhook and set STRIPE_WEBHOOK_SECRET.

router.post(
  "/webhook",
  express.raw({ type: "application/json" }),
  async (req, res) => {
    let event;
    try {
      if (!WEBHOOK_SECRET) {
        console.warn("[stripeconnect] No STRIPE_WEBHOOK_SECRET set; using unsafe payload (dev only).");
        event = req.body;
      } else {
        const sig = req.headers["stripe-signature"];
        event = Stripe.webhooks.constructEvent(req.body, sig, WEBHOOK_SECRET);
      }
    } catch (err) {
      console.error("[webhook] signature verification failed:", err.message);
      return res.status(400).send(`Webhook Error: ${err.message}`);
    }

    try {
      if (event.type === "account.updated") {
        const account = event.data.object;

        // Map Stripe acct -> user. Support both account_id/stripe_account_id, and fallback to users table.
        let userId = null;

        try {
          const { accountCol } = await detectStripeConnectSchema();
          const q = `
            SELECT user_id
              FROM stripe_connect
             WHERE ${accountCol} = $1
             LIMIT 1
          `;
          const { rows } = await db.query(q, [account.id]);
          userId = rows?.[0]?.user_id ?? null;
        } catch (_) {}

        if (!userId) {
          const { rows } = await db.query(
            `SELECT id FROM users WHERE stripe_account_id = $1 LIMIT 1`,
            [account.id]
          );
          userId = rows?.[0]?.id ?? null;
        }

        if (userId) {
          await upsertStripeState(userId, account);
          try { await recomputeCreatorActive(db, userId); } catch (_) {}
        }
      }
      res.json({ received: true });
    } catch (err) {
      console.error("[webhook handler] error:", err);
      res.status(500).end();
    }
  }
);

module.exports = router;


===== FILE: sliptail-backend\routes\stripeWebhook.js =====

const Stripe = require("stripe");
const db = require("../db");
const { notifyPurchase } = require("../utils/notify");
const { recomputeCreatorActive } = require("../services/creatorStatus");

const stripe = Stripe(process.env.STRIPE_SECRET_KEY);

// If you use ONE webhook endpoint for everything, keep STRIPE_WEBHOOK_SECRET.
// If you created a *separate* Connect webhook endpoint in Stripe Dashboard, you can
// optionally put its secret in STRIPE_CONNECT_WEBHOOK_SECRET and keep using ?connect=1.
const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET;
const connectEndpointSecret = process.env.STRIPE_CONNECT_WEBHOOK_SECRET;

/* ----------------------------- helpers ----------------------------- */

/** Ensure idempotency table exists (safe to run repeatedly). */
async function ensureWebhookDedupTable() {
  await db.query(`
    CREATE TABLE IF NOT EXISTS processed_webhook_events (
      id TEXT PRIMARY KEY,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );
  `);
}

/** Ensure stripe_connect table (new-column shape). If your table already exists with a legacy shape, we adapt at runtime. */
async function ensureStripeConnectTable() {
  await db
    .query(`
      CREATE TABLE IF NOT EXISTS stripe_connect (
        user_id TEXT PRIMARY KEY,
        stripe_account_id TEXT,
        details_submitted BOOLEAN DEFAULT FALSE,
        charges_enabled   BOOLEAN DEFAULT FALSE,
        payouts_enabled   BOOLEAN DEFAULT FALSE,
        connected_at      TIMESTAMP NULL,
        updated_at        TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `)
    .catch(() => {});
}

/** Detect actual stripe_connect schema to support legacy columns. */
async function detectStripeConnectSchema() {
  const { rows } = await db.query(`
    SELECT column_name, data_type
    FROM information_schema.columns
    WHERE table_schema='public' AND table_name='stripe_connect'
  `);

  const hasStripeAccountId = rows.some(r => r.column_name === "stripe_account_id");
  const hasAccountId = rows.some(r => r.column_name === "account_id");
  const accountCol = hasStripeAccountId ? "stripe_account_id" : (hasAccountId ? "account_id" : null);

  const userCol = rows.find(r => r.column_name === "user_id");
  const userIsInteger = !!userCol && /integer/.test(userCol.data_type);

  const hasConnectedAt = rows.some(r => r.column_name === "connected_at");

  if (!accountCol) {
    throw new Error("stripe_connect table must have either 'stripe_account_id' or 'account_id' column");
  }

  return { accountCol, userIsInteger, hasConnectedAt };
}

/**
 * Persist latest Stripe Connect flags for a user (schema-adaptive):
 * - Upsert into stripe_connect
 * - Best-effort mirror to creator_profiles.stripe_charges_enabled (if column exists)
 * - Best-effort snapshot to users.stripe_* columns (if those exist)
 */
async function upsertStripeState(userId, account) {
  const uid = String(userId);
  const accountId = account?.id || null;
  const details_submitted = !!account?.details_submitted;
  const charges_enabled   = !!account?.charges_enabled;
  const payouts_enabled   = !!account?.payouts_enabled;

  await ensureStripeConnectTable();
  const { accountCol, userIsInteger, hasConnectedAt } = await detectStripeConnectSchema();

  const userParam = userIsInteger ? "CAST($1 AS integer)" : "$1";

  const insertCols = [
    "user_id",
    accountCol,
    "details_submitted",
    "charges_enabled",
    "payouts_enabled",
    ...(hasConnectedAt ? ["connected_at"] : []),
    "updated_at",
  ];

  const insertValsSql = [
    userParam, "$2", "$3", "$4", "$5",
    ...(hasConnectedAt ? ["CASE WHEN $3 = TRUE THEN NOW() ELSE NULL END"] : []),
    "NOW()",
  ];

  const setPairs = [
    `${accountCol} = COALESCE(EXCLUDED.${accountCol}, stripe_connect.${accountCol})`,
    `details_submitted = EXCLUDED.details_submitted`,
    `charges_enabled   = EXCLUDED.charges_enabled`,
    `payouts_enabled   = EXCLUDED.payouts_enabled`,
    ...(hasConnectedAt
      ? [
          `connected_at = CASE
                             WHEN EXCLUDED.details_submitted = TRUE
                                  AND stripe_connect.connected_at IS NULL
                             THEN NOW()
                             ELSE stripe_connect.connected_at
                           END`,
        ]
      : []),
    `updated_at        = NOW()`,
  ];

  await db.query(
    `
    INSERT INTO stripe_connect (${insertCols.join(", ")})
    VALUES (${insertValsSql.join(", ")})
    ON CONFLICT (user_id) DO UPDATE
      SET ${setPairs.join(", ")}
    `,
    [uid, accountId, details_submitted, charges_enabled, payouts_enabled]
  );

  // Mirror to creator_profiles.stripe_charges_enabled if column exists (legacy compatibility)
  try {
    const { rows: hasCol } = await db.query(
      `SELECT 1
         FROM information_schema.columns
        WHERE table_schema='public' AND table_name='creator_profiles' AND column_name='stripe_charges_enabled'
        LIMIT 1`
    );
    if (hasCol.length) {
      await db.query(
        `INSERT INTO creator_profiles (user_id, stripe_charges_enabled, updated_at)
         VALUES ($1, $2, NOW())
         ON CONFLICT (user_id) DO UPDATE
           SET stripe_charges_enabled = EXCLUDED.stripe_charges_enabled,
               updated_at = NOW()`,
        [uid, charges_enabled]
      );
    }
  } catch (e) {
    console.warn("[webhook] mirror to creator_profiles failed:", e.message || e);
  }

  // Snapshot to users.stripe_* if those columns exist
  try {
    const { rows: hasUsersCols } = await db.query(`
      SELECT
        EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='users' AND column_name='stripe_details_submitted') AS has_details,
        EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='users' AND column_name='stripe_charges_enabled')   AS has_charges,
        EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='users' AND column_name='stripe_payouts_enabled')   AS has_payouts
    `);
    const hc = hasUsersCols[0] || {};
    if (hc.has_details || hc.has_charges || hc.has_payouts) {
      const sets = [];
      const vals = [];
      let i = 1;

      if (hc.has_details) { sets.push(`stripe_details_submitted=$${i++}`); vals.push(details_submitted); }
      if (hc.has_charges) { sets.push(`stripe_charges_enabled=$${i++}`);   vals.push(charges_enabled); }
      if (hc.has_payouts) { sets.push(`stripe_payouts_enabled=$${i++}`);   vals.push(payouts_enabled); }

      if (sets.length) {
        vals.push(uid);
        await db.query(
          `UPDATE users SET ${sets.join(", ")}, updated_at=NOW() WHERE id::text=$${i}`,
          vals
        );
      }
    }
  } catch (e) {
    console.warn("[webhook] snapshot to users.stripe_* failed:", e.message || e);
  }

  return { account_id: accountId, details_submitted, charges_enabled, payouts_enabled };
}

/**
 * Ensure an orders row exists and is PAID for a checkout session (mode=payment).
 * Returns the orderId (existing or newly inserted).
 */
async function upsertPaidOrderFromSession(session) {
  const meta = session.metadata || {};
  const sessionId = session.id;
  const paymentIntentId = session.payment_intent || null;
  const amountCents = Number.isFinite(session.amount_total) ? Number(session.amount_total) : 0;

  // Prefer metadata if present (these are set in stripeCheckout.js)
  const orderIdFromMeta = meta.order_id ? parseInt(meta.order_id, 10) : null;
  const buyerId = meta.buyer_id ? parseInt(meta.buyer_id, 10) : null;
  const productId = meta.product_id ? parseInt(meta.product_id, 10) : null;

  // 1) Try to mark an existing pending order as paid and set the session id
  if (orderIdFromMeta) {
    const { rowCount } = await db.query(
      `UPDATE public.orders
          SET status='paid',
              stripe_payment_intent_id=$1,
              stripe_checkout_session_id=COALESCE(stripe_checkout_session_id, $2)
        WHERE id=$3 AND status IN ('pending','created')
      `,
      [paymentIntentId, sessionId, orderIdFromMeta]
    );
    if (rowCount > 0) {
      return orderIdFromMeta;
    }
  }

  // 2) If no existing row, insert a new PAID order (idempotent-ish by session id)
  // Try to find by session id first (if we processed earlier)
  const { rows: existing } = await db.query(
    `SELECT id FROM public.orders WHERE stripe_checkout_session_id = $1 LIMIT 1`,
    [sessionId]
  );
  if (existing.length) {
    return existing[0].id;
  }

  // Insert only if we have the minimal data
  const insertableBuyer = Number.isFinite(buyerId) ? buyerId : null;
  const insertableProduct = Number.isFinite(productId) ? productId : null;
  const insertableAmount = Number.isFinite(amountCents) ? amountCents : 0;

  const { rows: inserted } = await db.query(
    `
    INSERT INTO public.orders
      (buyer_id, product_id, amount_cents, stripe_payment_intent_id, status, created_at, stripe_checkout_session_id)
    VALUES
      ($1, $2, $3, $4, 'paid', NOW(), $5)
    RETURNING id
    `,
    [insertableBuyer, insertableProduct, insertableAmount, paymentIntentId, sessionId]
  );

  return inserted[0].id;
}

/* ----------------------------- handler ----------------------------- */
/**
 * Export a single handler function.
 * index.js must mount it with express.raw(...) already:
 *   app.post("/api/stripe/webhook", express.raw({ type: "application/json" }), stripeWebhook)
 */
module.exports = async function stripeWebhook(req, res) {
  let event;

  // 1) Verify Stripe signature (req.body is a Buffer thanks to express.raw)
  try {
    const sig = req.headers["stripe-signature"];
    const secretToUse =
      (connectEndpointSecret && req.query?.connect === "1")
        ? connectEndpointSecret
        : endpointSecret;

    event = stripe.webhooks.constructEvent(req.body, sig, secretToUse);
  } catch (err) {
    console.error("⚠️  Webhook signature verification failed:", err.message);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  // 2) De-duplicate events (Stripe can retry)
  try {
    await ensureWebhookDedupTable();
    const evId = event.id;
    const { rows } = await db.query(
      `INSERT INTO processed_webhook_events (id)
       VALUES ($1)
       ON CONFLICT (id) DO NOTHING
       RETURNING id`,
      [evId]
    );
    if (!rows.length) {
      // already processed
      return res.status(200).end();
    }
  } catch (e) {
    console.error("Webhook de-dup insert failed (continuing):", e);
    // Proceed anyway; better to process than drop.
  }

  // 3) Handle relevant events
  try {
    switch (event.type) {
      /* ----------------- CONNECT: account state ----------------- */
      case "account.updated": {
        const account = event.data.object; // Stripe account
        const acctId = account.id;

        // Map Stripe account -> our user via stripe_connect (any schema) or users fallback
        let userId = null;
        try {
          const { accountCol } = await detectStripeConnectSchema();
          const { rows } = await db.query(
            `SELECT user_id FROM stripe_connect WHERE ${accountCol} = $1 LIMIT 1`,
            [acctId]
          );
          userId = rows?.[0]?.user_id ?? null;
        } catch (_) {}

        if (!userId) {
          const { rows } = await db.query(
            `SELECT id FROM users WHERE stripe_account_id = $1 LIMIT 1`,
            [acctId]
          );
          userId = rows?.[0]?.id ?? null;
        }

        if (userId) {
          await upsertStripeState(userId, account);
          try { await recomputeCreatorActive(db, userId); } catch (_) {}
        } else {
          // Not necessarily an error: account may not be linked yet.
          console.log("[account.updated] No matching user for account", acctId);
        }
        break;
      }

      /* ----------------- Checkout → Orders / Subscriptions ----------------- */
      case "checkout.session.completed": {
        const session = event.data.object;

        if (session.mode === "payment") {
          // one-time purchase/request
          const orderId = await upsertPaidOrderFromSession(session);
          try {
            await notifyPurchase({ orderId });
          } catch (e) {
            console.warn("notifyPurchase failed (non-fatal):", e);
          }
        }

        if (session.mode === "subscription") {
          const customer = session.customer;
          const buyerId = session.metadata?.buyer_id && parseInt(session.metadata.buyer_id, 10);
          if (customer && buyerId) {
            await db.query(
              `UPDATE users
                 SET stripe_customer_id=$1
               WHERE id=$2 AND (stripe_customer_id IS NULL OR stripe_customer_id <> $1)`,
              [customer, buyerId]
            );
          }
        }
        break;
      }

      case "payment_intent.succeeded": {
        const pi = event.data.object;
        const orderId = pi.metadata?.order_id && parseInt(pi.metadata.order_id, 10);
        const sessionId = pi.metadata?.stripe_checkout_session_id || null; // may or may not exist

        if (orderId) {
          await db.query(
            `UPDATE orders
                SET status='paid',
                    stripe_payment_intent_id=$1,
                    stripe_checkout_session_id = COALESCE(stripe_checkout_session_id, $2)
              WHERE id=$3 AND status <> 'paid'`,
            [pi.id, sessionId, orderId]
          );
          try {
            await notifyPurchase({ orderId });
          } catch (e) {
            console.warn("notifyPurchase failed (non-fatal):", e);
          }
        }
        break;
      }

      /* ----------------- Subscription lifecycle → memberships ----------------- */
      case "customer.subscription.created":
      case "customer.subscription.updated":
      case "customer.subscription.deleted": {
        const sub = event.data.object;
        const status = sub.status; // trialing, active, past_due, canceled, etc.
        const currentPeriodEnd = new Date(sub.current_period_end * 1000);

        const meta = sub.metadata || {};
        const buyerId   = meta.buyer_id && parseInt(meta.buyer_id, 10);
        const creatorId = meta.creator_id && parseInt(meta.creator_id, 10);
        const productId = meta.product_id && parseInt(meta.product_id, 10);

        if (buyerId && creatorId && productId) {
          if (event.type === "customer.subscription.deleted") {
            await db.query(
              `UPDATE memberships
                  SET status='canceled',
                      current_period_end=$1
                WHERE stripe_subscription_id=$2`,
              [currentPeriodEnd, sub.id]
            );
          } else {
            await db.query(
              `INSERT INTO memberships
                 (buyer_id, creator_id, product_id, stripe_subscription_id, status, current_period_end, created_at)
               VALUES ($1,$2,$3,$4,$5,$6,NOW())
               ON CONFLICT (stripe_subscription_id) DO UPDATE
                 SET status=EXCLUDED.status,
                     current_period_end=EXCLUDED.current_period_end`,
              [buyerId, creatorId, productId, sub.id, status, currentPeriodEnd]
            );
          }
        }
        break;
      }

      case "invoice.paid": {
        const invoice = event.data.object;
        const subId = invoice.subscription;
        if (subId) {
          const sub = await stripe.subscriptions.retrieve(subId);
          const status = sub.status;
          const currentPeriodEnd = new Date(sub.current_period_end * 1000);
          await db.query(
            `UPDATE memberships
                SET status=$1,
                    current_period_end=$2
              WHERE stripe_subscription_id=$3`,
            [status, currentPeriodEnd, subId]
          );
        }
        break;
      }

      default:
        // other events are fine to ignore
        break;
    }
  } catch (e) {
    console.error("Webhook handling error:", e);
    // tell Stripe to retry
    return res.status(500).send("webhook handler error");
  }

  // 4) Always ACK
  res.json({ received: true });
};

===== FILE: sliptail-backend\services\creatorStatus.js =====

module.exports.recomputeCreatorActive = async function recomputeCreatorActive(db, userId) {
  const uid = String(userId || "").trim();

  if (!uid) {
    return { isActive: false, profileComplete: false, stripeConnected: false, hasPublishedProduct: false };
  }

  /* ---------- users.stripe_connected (highest priority) ---------- */
  let usersStripeConnected = false;
  try {
    const { rows } = await db.query(
      `
      SELECT
        CASE WHEN EXISTS (
          SELECT 1 FROM information_schema.columns
          WHERE table_schema='public' AND table_name='users' AND column_name='stripe_connected'
        )
        THEN COALESCE(stripe_connected, false) ELSE false END AS stripe_connected
      FROM users
      WHERE id::text=$1
      LIMIT 1
      `,
      [uid]
    );
    usersStripeConnected = !!rows?.[0]?.stripe_connected;
  } catch (_) {}

  /* ---------- profile completeness ---------- */
  const { rows: profRows } = await db.query(
    `
    SELECT
      COALESCE(is_profile_complete, false) AS is_profile_complete,
      display_name, bio, profile_image,
      CASE WHEN to_regclass('public.creator_profile_photos') IS NOT NULL THEN
        (SELECT COUNT(*)::int FROM creator_profile_photos WHERE user_id::text=$1)
      ELSE 0 END AS photos_count,
      CASE WHEN EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_schema='public' AND table_name='creator_profiles' AND column_name='stripe_charges_enabled'
      )
      THEN COALESCE(stripe_charges_enabled, false)
      ELSE false
      END AS stripe_charges_enabled_cp
    FROM creator_profiles
    WHERE user_id::text=$1
    LIMIT 1
    `,
    [uid]
  );

  if (!profRows.length) {
    return { isActive: false, profileComplete: false, stripeConnected: false, hasPublishedProduct: false };
  }

  const p = profRows[0];
  let profileComplete = p.is_profile_complete === true
    ? true
    : (!!p.display_name && !!p.bio && !!p.profile_image && (Number(p.photos_count || 0) >= 4));

  /* ---------- stripe connectivity (priorities) ---------- */
  let stripeConnected = !!usersStripeConnected;

  if (!stripeConnected) stripeConnected = !!p.stripe_charges_enabled_cp;

  if (!stripeConnected) {
    const { rows: sc } = await db.query(
      `
      SELECT COALESCE(charges_enabled,false) AS charges_enabled,
             COALESCE(details_submitted,false) AS details_submitted
      FROM stripe_connect
      WHERE user_id::text=$1
      LIMIT 1
      `,
      [uid]
    );
    if (sc.length) stripeConnected = !!(sc[0].charges_enabled || sc[0].details_submitted);
  }

  if (!stripeConnected) {
    const { rows: u } = await db.query(
      `
      SELECT
        CASE WHEN EXISTS (
          SELECT 1 FROM information_schema.columns
          WHERE table_schema='public' AND table_name='users' AND column_name='stripe_charges_enabled'
        ) THEN COALESCE(stripe_charges_enabled,false) ELSE false END AS charges_enabled,
        CASE WHEN EXISTS (
          SELECT 1 FROM information_schema.columns
          WHERE table_schema='public' AND table_name='users' AND column_name='stripe_details_submitted'
        ) THEN COALESCE(stripe_details_submitted,false) ELSE false END AS details_submitted
      FROM users
      WHERE id::text=$1
      LIMIT 1
      `,
      [uid]
    );
    if (u.length) stripeConnected = !!(u[0].charges_enabled || u[0].details_submitted);
  }

  /* ---------- products: detect active column, then counts ---------- */
  let productsHasActive = false;
  try {
    const { rows: hc } = await db.query(
      `
      SELECT 1 FROM information_schema.columns
      WHERE table_schema='public' AND table_name='products' AND column_name='active'
      LIMIT 1
      `
    );
    productsHasActive = hc.length > 0;
  } catch (_) {}

  let hasPublishedProduct = false;
  let totalProducts = 0;

  if (productsHasActive) {
    const { rows: hp } = await db.query(
      `
      SELECT
        COALESCE(SUM(CASE WHEN active=TRUE THEN 1 ELSE 0 END),0)::int AS published_count,
        COALESCE(COUNT(*),0)::int AS total_count
      FROM products
      WHERE user_id::text=$1
      `,
      [uid]
    );
    hasPublishedProduct = (hp?.[0]?.published_count || 0) > 0;
    totalProducts = hp?.[0]?.total_count || 0;
  } else {
    // No "active" column → treat “has any product” as satisfying the published gate
    const { rows: hp } = await db.query(
      `SELECT COALESCE(COUNT(*),0)::int AS total_count FROM products WHERE user_id::text=$1`,
      [uid]
    );
    totalProducts = hp?.[0]?.total_count || 0;
    hasPublishedProduct = totalProducts > 0;
  }

  /* ---------- final rule ---------- */
  // Your requirement: activate when profile ✓, stripe ✓, and (published OR has ≥1 product)
  const isActive = profileComplete && stripeConnected && (hasPublishedProduct || totalProducts > 0);

  // Persist creator_profiles.is_active
  try {
    await db.query(
      `UPDATE creator_profiles SET is_active=$2, updated_at=NOW() WHERE user_id::text=$1`,
      [uid, isActive]
    );
  } catch (_) {}

  // Flip role → 'creator' once the user owns any product
  if (totalProducts > 0) {
    try {
      await db.query(
        `UPDATE users SET role='creator', updated_at=NOW() WHERE id::text=$1 AND role <> 'creator'`,
        [uid]
      );
    } catch (e) {
      console.warn("[recomputeCreatorActive] role flip failed:", e.message || e);
    }
  }

  return { isActive, profileComplete, stripeConnected, hasPublishedProduct };
};


===== FILE: sliptail-backend\services\stripeConnect.js =====

const Stripe = require("stripe");
const stripe = Stripe(process.env.STRIPE_SECRET_KEY);

/**
 * Pull latest Stripe account flags and persist them.
 * - Writes to stripe_connect table
 * - Best-effort mirror to creator_profiles.stripe_charges_enabled (if exists)
 * Returns { account_id, details_submitted, charges_enabled, payouts_enabled }
 */
async function syncStripeForUser(db, userId) {
  // 1) find account id
  const { rows } = await db.query(
    `SELECT stripe_account_id FROM users WHERE id=$1 LIMIT 1`,
    [userId]
  );
  const accountId = rows[0]?.stripe_account_id;
  if (!accountId) {
    throw new Error("No Stripe account on file");
  }

  // 2) get latest from Stripe
  const acct = await stripe.accounts.retrieve(accountId);
  const details_submitted = !!acct.details_submitted;
  const charges_enabled   = !!acct.charges_enabled;
  const payouts_enabled   = !!acct.payouts_enabled;

  // 3) upsert into stripe_connect
  await db.query(
    `
    INSERT INTO stripe_connect (user_id, account_id, details_submitted, charges_enabled, payouts_enabled, updated_at)
    VALUES ($1, $2, $3, $4, $5, NOW())
    ON CONFLICT (user_id) DO UPDATE
       SET account_id        = EXCLUDED.account_id,
           details_submitted = EXCLUDED.details_submitted,
           charges_enabled   = EXCLUDED.charges_enabled,
           payouts_enabled   = EXCLUDED.payouts_enabled,
           updated_at        = NOW()
    `,
    [userId, accountId, details_submitted, charges_enabled, payouts_enabled]
  );

  // 4) optional mirror to creator_profiles (best-effort; ignore if column missing)
  try {
    await db.query(
      `UPDATE creator_profiles
          SET stripe_charges_enabled = $2,
              updated_at = NOW()
        WHERE user_id=$1`,
      [userId, charges_enabled]
    );
  } catch (_) {
    // If the column doesn't exist, that's fine—we rely on stripe_connect now.
  }

  return {
    account_id: accountId,
    details_submitted,
    charges_enabled,
    payouts_enabled,
  };
}

module.exports = {
  syncStripeForUser,
};

===== FILE: sliptail-backend\utils\emailQueue.js =====

const db = require("../db");
const { sendMail } = require("./mailer");

function renderHtml(template, payload = {}) {
  if (template === "verify_email") {
    const url = payload.verify_url || "#";
    return `<h2>Verify your email</h2><p><a href="${url}">${url}</a></p>`;
  }
  if (template === "reset_password") {
    const url = payload.reset_url || "#";
    return `<h2>Reset your password</h2><p><a href="${url}">${url}</a></p>`;
  }
  return `<pre>${template}</pre><pre>${JSON.stringify(payload, null, 2)}</pre>`;
}

async function enqueueAndSend({ to, subject, template, payload }) {
  let rec;
  try {
    const { rows } = await db.query(
      `INSERT INTO email_queue (to_email, subject, template, payload_json, status, attempts, created_at)
       VALUES ($1,$2,$3,$4,'pending',0,NOW())
       RETURNING *`,
      [to, subject, template || null, JSON.stringify(payload || {})]
    );
    rec = rows[0];

    const html = renderHtml(template, payload);
    await sendMail({ to, subject, html });

    await db.query(
      `UPDATE email_queue SET status='sent', sent_at=NOW(), attempts=attempts+1 WHERE id=$1`,
      [rec.id]
    );
  } catch (e) {
    if (rec) {
      await db.query(
        `UPDATE email_queue SET status='failed', last_error=$2, attempts=attempts+1 WHERE id=$1`,
        [rec.id, e.message || String(e)]
      );
    }
    // Don’t rethrow in signup path if you don’t want to fail; your route already wraps with try/catch.
    throw e;
  }
}

module.exports = { enqueueAndSend };

===== FILE: sliptail-backend\utils\mailer.js =====

const nodemailer = require("nodemailer");

const {
  SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASS, SMTP_FROM
} = process.env;

const transporter = nodemailer.createTransport({
  host: SMTP_HOST,
  port: Number(SMTP_PORT || 587),
  secure: false, // true only for 465
  auth: SMTP_USER ? { user: SMTP_USER, pass: SMTP_PASS } : undefined,
});

async function sendMail({ to, subject, html }) {
  if (!to || !subject || !html) throw new Error("Missing to/subject/html");
  const from = SMTP_FROM || "no-reply@example.com";
  return transporter.sendMail({ from, to, subject, html });
}

module.exports = { sendMail };

===== FILE: sliptail-backend\utils\notify.js =====

const db = require("../db");
const { enqueueAndSend } = require("./emailQueue");

/**
 * Create an in-app notification row (for the website bell).
 * Safe no-op on error (logs only).
 * type examples: 'purchase','product_sale','new_request','request_delivered','membership_post','membership_expiring'
 */
async function notifyInApp(userId, { type, title, body, metadata }) {
  try {
    await db.query(
      `INSERT INTO notifications (user_id, type, title, body, metadata)
       VALUES ($1,$2,$3,$4,$5)`,
      [userId, type, title, body || null, metadata ? JSON.stringify(metadata) : null]
    );
  } catch (e) {
    console.error("notifyInApp error:", e);
  }
}

/**
 * Send email IF the user's toggle allows it.
 * Kept your signature but added optional {text, replyTo}.
 */
async function sendIfUserPref(userId, prefKey, { subject, html, category, text, replyTo }) {
  try {
    const { rows } = await db.query(
      `SELECT email, ${prefKey} AS enabled FROM users WHERE id=$1`,
      [userId]
    );
    const u = rows[0];
    if (!u) return { skipped: "no_user" };
    if (!u.enabled) return { skipped: "pref_off" };
    await enqueueAndSend({ to: u.email, subject, html, category, text, replyTo });
    return { sent: true };
  } catch (e) {
    console.error("sendIfUserPref error:", e);
    return { error: e.message || String(e) };
  }
}

/**
 * Notify all active members when a creator posts to their membership feed.
 * call with: notifyPostToMembers({ creatorId, postId, title })
 */
async function notifyPostToMembers({ creatorId, postId, title }) {
  try {
    const { rows } = await db.query(
      `SELECT m.buyer_id AS user_id
         FROM memberships m
        WHERE m.creator_id = $1
          AND m.status IN ('active','trialing')
          AND NOW() <= m.current_period_end`,
      [creatorId]
    );

    const tasks = rows.map(({ user_id }) =>
      Promise.allSettled([
        sendIfUserPref(user_id, "notify_post", {
          subject: `New post from a creator you follow`,
          html: `<p>A creator you follow just posted: <strong>${title || "New post"}</strong></p>
                 <p>Visit your feed to view it.</p>`,
          category: "membership_post"
        }),
        notifyInApp(user_id, {
          type: "membership_post",
          title: "New post available",
          body: title || "A creator you follow posted new content.",
          metadata: { creator_id: creatorId, post_id: postId }
        })
      ])
    );

    await Promise.allSettled(tasks);
  } catch (e) {
    console.error("notifyPostToMembers error:", e);
  }
}

/**
 * Notify user + creator when a purchase (of any type) is paid.
 * If you mark paid via orders API or Stripe webhook, call this.
 */
async function notifyPurchase({ orderId }) {
  try {
    const { rows } = await db.query(
      `SELECT o.id AS order_id, o.buyer_id, o.amount,
              p.id AS product_id, p.title, p.product_type, p.user_id AS creator_id
         FROM orders o
         JOIN products p ON p.id = o.product_id
        WHERE o.id = $1`,
      [orderId]
    );
    const o = rows[0];
    if (!o) return;

    // fire both email + in-app for buyer
    await Promise.allSettled([
      sendIfUserPref(o.buyer_id, "notify_purchase", {
        subject: `Your ${o.product_type} purchase is confirmed`,
        html: `<p>Thanks! Your purchase of <strong>${o.title || "a product"}</strong> is confirmed.</p>
               <p>You can view/download it from your purchases page.</p>`,
        category: "purchase_receipt"
      }),
      notifyInApp(o.buyer_id, {
        type: "purchase",
        title: "Purchase confirmed",
        body: `Your ${o.product_type} "${o.title || "product"}" is confirmed.`,
        metadata: { order_id: o.order_id, product_id: o.product_id }
      })
    ]);

    // fire both email + in-app for creator
    await Promise.allSettled([
      sendIfUserPref(o.creator_id, "notify_product_sale", {
        subject: `You made a sale 🎉`,
        html: `<p>Your ${o.product_type} "<strong>${o.title || "product"}</strong>" was just purchased.</p>`,
        category: "creator_sale"
      }),
      notifyInApp(o.creator_id, {
        type: "product_sale",
        title: "You made a sale 🎉",
        body: `Your ${o.product_type} "${o.title || "product"}" was purchased.`,
        metadata: { order_id: o.order_id, product_id: o.product_id }
      })
    ]);
  } catch (e) {
    console.error("notifyPurchase error:", e);
  }
}

/**
 * Notify creator when a new request arrives (after user fills request form).
 * Call right after creating the request row.
 */
async function notifyCreatorNewRequest({ requestId }) {
  try {
    const { rows } = await db.query(
      `SELECT cr.id, cr.creator_id
         FROM custom_requests cr
        WHERE cr.id=$1`,
      [requestId]
    );
    const r = rows[0];
    if (!r) return;

    await Promise.allSettled([
      sendIfUserPref(r.creator_id, "notify_new_request", {
        subject: `New request received`,
        html: `<p>You received a new request. Visit your creator dashboard → requests.</p>`,
        category: "new_request"
      }),
      notifyInApp(r.creator_id, {
        type: "new_request",
        title: "New request received",
        body: "A buyer submitted a new request.",
        metadata: { request_id: r.id }
      })
    ]);
  } catch (e) {
    console.error("notifyCreatorNewRequest error:", e);
  }
}

/**
 * Notify buyer when a request is delivered.
 * Call right after setting status='delivered'.
 */
async function notifyRequestDelivered({ requestId }) {
  try {
    const { rows } = await db.query(
      `SELECT cr.id, cr.buyer_id
         FROM custom_requests cr
        WHERE cr.id=$1`,
      [requestId]
    );
    const r = rows[0];
    if (!r) return;

    await Promise.allSettled([
      sendIfUserPref(r.buyer_id, "notify_request_completed", {
        subject: `Your request has been delivered`,
        html: `<p>Your request has been completed. You can download the delivery from your requests page.</p>`,
        category: "request_delivered"
      }),
      notifyInApp(r.buyer_id, {
        type: "request_delivered",
        title: "Your request has been delivered",
        body: "Open your requests page to download the file.",
        metadata: { request_id: r.id }
      })
    ]);
  } catch (e) {
    console.error("notifyRequestDelivered error:", e);
  }
}

/**
 * Membership expiring reminder (run by a daily cron or manual job).
 * Notifies users whose membership period ends within N days.
 */
async function notifyMembershipsExpiring({ days = 3 } = {}) {
  try {
    const { rows } = await db.query(
      `SELECT m.id, m.buyer_id, m.creator_id, m.current_period_end,
              cp.display_name
         FROM memberships m
    LEFT JOIN creator_profiles cp ON cp.user_id = m.creator_id
        WHERE m.status IN ('active','trialing')
          AND m.current_period_end BETWEEN NOW() AND NOW() + ($1 || ' days')::interval`,
      [String(days)]
    );

    const tasks = rows.map(m =>
      Promise.allSettled([
        sendIfUserPref(m.buyer_id, "notify_membership_expiring", {
          subject: `Your membership is ending soon`,
          html: `<p>Your membership with <strong>${m.display_name || "a creator"}</strong> ends on <strong>${new Date(m.current_period_end).toLocaleString()}</strong>.</p>
                 <p>Renew to keep access.</p>`,
          category: "membership_expiring"
        }),
        notifyInApp(m.buyer_id, {
          type: "membership_expiring",
          title: "Membership ending soon",
          body: `Ends on ${new Date(m.current_period_end).toLocaleString()}.`,
          metadata: { membership_id: m.id, creator_id: m.creator_id }
        })
      ])
    );

    await Promise.allSettled(tasks);
  } catch (e) {
    console.error("notifyMembershipsExpiring error:", e);
  }
}

module.exports = {
  // generic
  sendIfUserPref,

  // event helpers used by your routes
  notifyPostToMembers,
  notifyPurchase,
  notifyCreatorNewRequest,
  notifyRequestDelivered,
  notifyMembershipsExpiring,
};

===== FILE: sliptail-backend\validators\schemas.js =====

const { z } = require("zod"); 

// Reusable primitives
const id = z.coerce.number().int().positive();
const price = z.coerce.number().finite().min(0).max(1_000_000);

// NEW: absolute URL validator that allows Stripe's {CHECKOUT_SESSION_ID} placeholder
const urlWithCheckoutPlaceholder = z
  .string()
  .trim()
  .min(1)
  .refine((val) => {
    try {
      const test = val.replace("{CHECKOUT_SESSION_ID}", "cs_test_123");
      const u = new URL(test);
      return u.protocol === "http:" || u.protocol === "https:";
    } catch {
      return false;
    }
  }, { message: "Must be an absolute URL (http/https). You may include {CHECKOUT_SESSION_ID}." });

// AUTH
const authSignup = z.object({
  body: z.object({
    email: z.string().email(),
    password: z.string().min(8).max(100),
    username: z.string().min(2).max(50).optional(),
  }),
});

const authLogin = z.object({
  body: z.object({
    email: z.string().email(),
    password: z.string().min(8).max(100),
  }),
});

const sendVerifyEmail = z.object({ body: z.object({}) }); // no body fields

// PRODUCTS
const productCreateFile = z.object({
  body: z.object({
    title: z.string().min(1).max(200),
    description: z.string().max(5000).optional().nullable(),
    product_type: z.enum(["purchase","membership","request"]),
    price: price.optional().nullable(),
  }),
});

const productCreateNoFile = productCreateFile; // same fields without multer file

const productUpdate = z.object({
  params: z.object({ id }),
  body: z.object({
    title: z.string().min(1).max(200).optional(),
    description: z.string().max(5000).optional().nullable(),
    product_type: z.enum(["purchase","membership","request"]).optional(),
    price: price.optional().nullable(),
  }),
});

// ORDERS / CHECKOUT
// UPDATED: accepts productId alias, optional action/quantity, and success/cancel URLs with placeholder
const checkoutSession = z.object({
  body: z.object({
    product_id: id.optional(),
    productId: id.optional(), // alias from some clients
    mode: z.enum(["payment","subscription"]),
    action: z.string().min(1).max(30).transform((s) => s.toLowerCase()).optional(),
    quantity: z.coerce.number().int().min(1).max(100).optional(),
    success_url: urlWithCheckoutPlaceholder.optional(), // was z.string().url()
    cancel_url: urlWithCheckoutPlaceholder.optional(),  // was z.string().url()
  })
  .transform((b) => ({
    ...b,
    // normalize alias -> canonical
    product_id: b.product_id ?? b.productId,
  }))
  .refine((b) => typeof b.product_id === "number" && Number.isFinite(b.product_id), {
    message: "product_id is required",
    path: ["product_id"],
  }),
});

// REQUESTS
const requestCreate = z.object({
  body: z.object({
    creator_id: id,
    product_id: id,
    message: z.string().max(5000).optional().nullable(),
  }),
});

const requestDecision = z.object({
  params: z.object({ id }),
  body: z.object({ action: z.enum(["accept","decline"]) }),
});

const requestDeliver = z.object({
  params: z.object({ id }),
});

// REVIEWS (example)
const reviewCreate = z.object({
  body: z.object({
    product_id: id,
    rating: z.coerce.number().int().min(1).max(5),
    comment: z.string().max(2000).optional().nullable(),
  }),
});

module.exports = {
  authSignup,
  authLogin,
  sendVerifyEmail,
  productCreateFile,
  productCreateNoFile,
  productUpdate,
  checkoutSession,
  requestCreate,
  requestDecision,
  requestDeliver,
  reviewCreate,
};

===== FILE: sliptail-frontend\next-env.d.ts =====

/// <reference types="next" />
/// <reference types="next/image-types/global" />
/// <reference path="./.next/types/routes.d.ts" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


===== FILE: sliptail-frontend\next.config.ts =====

// next.config.ts
import type { NextConfig } from "next";

const API = (process.env.NEXT_PUBLIC_API_URL || "http://localhost:5000").replace(/\/$/, "");

const nextConfig: NextConfig = {
  async rewrites() {
    return [{ source: "/api/:path*", destination: `${API}/api/:path*` }];
  },
  images: {
    remotePatterns: [
      { protocol: "https", hostname: "images.unsplash.com" },
      { protocol: "https", hostname: "i.pravatar.cc" },
      { protocol: "https", hostname: "picsum.photos" },

      // if your backend serves images (creator avatars/gallery) in dev:
      { protocol: "http", hostname: "localhost", port: "5000" },
      { protocol: "http", hostname: "127.0.0.1", port: "5000" },
    ],
    // Alternatively:
    // domains: ["images.unsplash.com", "i.pravatar.cc", "picsum.photos"]
  },
};

export default nextConfig;

===== FILE: sliptail-frontend\package-lock.json =====

{
  "name": "sliptail-frontend",
  "version": "0.1.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "sliptail-frontend",
      "version": "0.1.0",
      "dependencies": {
        "axios": "^1.11.0",
        "next": "15.5.2",
        "react": "19.1.0",
        "react-dom": "19.1.0",
        "swr": "^2.3.6"
      },
      "devDependencies": {
        "@eslint/eslintrc": "^3",
        "@tailwindcss/postcss": "^4",
        "@types/node": "^20",
        "@types/react": "^19",
        "@types/react-dom": "^19",
        "autoprefixer": "^10.4.21",
        "eslint": "^9",
        "eslint-config-next": "15.5.2",
        "postcss": "^8.5.6",
        "tailwindcss": "^4.1.12",
        "typescript": "^5"
      }
    },
    "node_modules/@alloc/quick-lru": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/@alloc/quick-lru/-/quick-lru-5.2.0.tgz",
      "integrity": "sha512-UrcABB+4bUrFABwbluTIBErXwvbsU/V7TZWfmbgJfbkwiBuziS9gxdODUyuiecfdGQ85jglMW6juS3+z5TsKLw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/@emnapi/core": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/@emnapi/core/-/core-1.5.0.tgz",
      "integrity": "sha512-sbP8GzB1WDzacS8fgNPpHlp6C9VZe+SJP3F90W9rLemaQj2PzIuTEl1qDOYQf58YIpyjViI24y9aPWCjEzY2cg==",
      "dev": true,
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "@emnapi/wasi-threads": "1.1.0",
        "tslib": "^2.4.0"
      }
    },
    "node_modules/@emnapi/runtime": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/@emnapi/runtime/-/runtime-1.5.0.tgz",
      "integrity": "sha512-97/BJ3iXHww3djw6hYIfErCZFee7qCtrneuLa20UXFCOTCfBM2cvQHjWJ2EG0s0MtdNwInarqCTz35i4wWXHsQ==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "tslib": "^2.4.0"
      }
    },
    "node_modules/@emnapi/wasi-threads": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@emnapi/wasi-threads/-/wasi-threads-1.1.0.tgz",
      "integrity": "sha512-WI0DdZ8xFSbgMjR1sFsKABJ/C5OnRrjT06JXbZKexJGrDuPTzZdDYfFlsgcCXCyf+suG5QU2e/y1Wo2V/OapLQ==",
      "dev": true,
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "tslib": "^2.4.0"
      }
    },
    "node_modules/@eslint-community/eslint-utils": {
      "version": "4.7.0",
      "resolved": "https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.7.0.tgz",
      "integrity": "sha512-dyybb3AcajC7uha6CvhdVRJqaKyn7w2YKqKyAN37NKYgZT36w+iRb0Dymmc5qEJ549c/S31cMMSFd75bteCpCw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "eslint-visitor-keys": "^3.4.3"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      },
      "peerDependencies": {
        "eslint": "^6.0.0 || ^7.0.0 || >=8.0.0"
      }
    },
    "node_modules/@eslint-community/eslint-utils/node_modules/eslint-visitor-keys": {
      "version": "3.4.3",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.3.tgz",
      "integrity": "sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint-community/regexpp": {
      "version": "4.12.1",
      "resolved": "https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.12.1.tgz",
      "integrity": "sha512-CCZCDJuduB9OUkFkY2IgppNZMi2lBQgD2qzwXkEia16cge2pijY/aXi96CJMquDMn3nJdlPV1A5KrJEXwfLNzQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^12.0.0 || ^14.0.0 || >=16.0.0"
      }
    },
    "node_modules/@eslint/config-array": {
      "version": "0.21.0",
      "resolved": "https://registry.npmjs.org/@eslint/config-array/-/config-array-0.21.0.tgz",
      "integrity": "sha512-ENIdc4iLu0d93HeYirvKmrzshzofPw6VkZRKQGe9Nv46ZnWUzcF1xV01dcvEg/1wXUR61OmmlSfyeyO7EvjLxQ==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@eslint/object-schema": "^2.1.6",
        "debug": "^4.3.1",
        "minimatch": "^3.1.2"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/config-helpers": {
      "version": "0.3.1",
      "resolved": "https://registry.npmjs.org/@eslint/config-helpers/-/config-helpers-0.3.1.tgz",
      "integrity": "sha512-xR93k9WhrDYpXHORXpxVL5oHj3Era7wo6k/Wd8/IsQNnZUTzkGS29lyn3nAT05v6ltUuTFVCCYDEGfy2Or/sPA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/core": {
      "version": "0.15.2",
      "resolved": "https://registry.npmjs.org/@eslint/core/-/core-0.15.2.tgz",
      "integrity": "sha512-78Md3/Rrxh83gCxoUc0EiciuOHsIITzLy53m3d9UyiW8y9Dj2D29FeETqyKA+BRK76tnTp6RXWb3pCay8Oyomg==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@types/json-schema": "^7.0.15"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/eslintrc": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-3.3.1.tgz",
      "integrity": "sha512-gtF186CXhIl1p4pJNGZw8Yc6RlshoePRvE0X91oPGb3vZ8pM3qOS9W9NGPat9LziaBV7XrJWGylNQXkGcnM3IQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ajv": "^6.12.4",
        "debug": "^4.3.2",
        "espree": "^10.0.1",
        "globals": "^14.0.0",
        "ignore": "^5.2.0",
        "import-fresh": "^3.2.1",
        "js-yaml": "^4.1.0",
        "minimatch": "^3.1.2",
        "strip-json-comments": "^3.1.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint/js": {
      "version": "9.34.0",
      "resolved": "https://registry.npmjs.org/@eslint/js/-/js-9.34.0.tgz",
      "integrity": "sha512-EoyvqQnBNsV1CWaEJ559rxXL4c8V92gxirbawSmVUOWXlsRxxQXl6LmCpdUblgxgSkDIqKnhzba2SjRTI/A5Rw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://eslint.org/donate"
      }
    },
    "node_modules/@eslint/object-schema": {
      "version": "2.1.6",
      "resolved": "https://registry.npmjs.org/@eslint/object-schema/-/object-schema-2.1.6.tgz",
      "integrity": "sha512-RBMg5FRL0I0gs51M/guSAj5/e14VQ4tpZnQNWwuDT66P14I43ItmPfIZRhO9fUVIPOAQXU47atlywZ/czoqFPA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/plugin-kit": {
      "version": "0.3.5",
      "resolved": "https://registry.npmjs.org/@eslint/plugin-kit/-/plugin-kit-0.3.5.tgz",
      "integrity": "sha512-Z5kJ+wU3oA7MMIqVR9tyZRtjYPr4OC004Q4Rw7pgOKUOKkJfZ3O24nz3WYfGRpMDNmcOi3TwQOmgm7B7Tpii0w==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@eslint/core": "^0.15.2",
        "levn": "^0.4.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@humanfs/core": {
      "version": "0.19.1",
      "resolved": "https://registry.npmjs.org/@humanfs/core/-/core-0.19.1.tgz",
      "integrity": "sha512-5DyQ4+1JEUzejeK1JGICcideyfUbGixgS9jNgex5nqkW+cY7WZhxBigmieN5Qnw9ZosSNVC9KQKyb+GUaGyKUA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18.0"
      }
    },
    "node_modules/@humanfs/node": {
      "version": "0.16.6",
      "resolved": "https://registry.npmjs.org/@humanfs/node/-/node-0.16.6.tgz",
      "integrity": "sha512-YuI2ZHQL78Q5HbhDiBA1X4LmYdXCKCMQIfw0pw7piHJwyREFebJUvrQN4cMssyES6x+vfUbx1CIpaQUKYdQZOw==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@humanfs/core": "^0.19.1",
        "@humanwhocodes/retry": "^0.3.0"
      },
      "engines": {
        "node": ">=18.18.0"
      }
    },
    "node_modules/@humanfs/node/node_modules/@humanwhocodes/retry": {
      "version": "0.3.1",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/retry/-/retry-0.3.1.tgz",
      "integrity": "sha512-JBxkERygn7Bv/GbN5Rv8Ul6LVknS+5Bp6RgDC/O8gEBU/yeH5Ui5C/OlWrTb6qct7LjjfT6Re2NxB0ln0yYybA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@humanwhocodes/module-importer": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/module-importer/-/module-importer-1.0.1.tgz",
      "integrity": "sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=12.22"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@humanwhocodes/retry": {
      "version": "0.4.3",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/retry/-/retry-0.4.3.tgz",
      "integrity": "sha512-bV0Tgo9K4hfPCek+aMAn81RppFKv2ySDQeMoSZuvTASywNTnVJCArCZE2FWqpvIatKu7VMRLWlR1EazvVhDyhQ==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@img/sharp-darwin-arm64": {
      "version": "0.34.3",
      "resolved": "https://registry.npmjs.org/@img/sharp-darwin-arm64/-/sharp-darwin-arm64-0.34.3.tgz",
      "integrity": "sha512-ryFMfvxxpQRsgZJqBd4wsttYQbCxsJksrv9Lw/v798JcQ8+w84mBWuXwl+TT0WJ/WrYOLaYpwQXi3sA9nTIaIg==",
      "cpu": [
        "arm64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-darwin-arm64": "1.2.0"
      }
    },
    "node_modules/@img/sharp-darwin-x64": {
      "version": "0.34.3",
      "resolved": "https://registry.npmjs.org/@img/sharp-darwin-x64/-/sharp-darwin-x64-0.34.3.tgz",
      "integrity": "sha512-yHpJYynROAj12TA6qil58hmPmAwxKKC7reUqtGLzsOHfP7/rniNGTL8tjWX6L3CTV4+5P4ypcS7Pp+7OB+8ihA==",
      "cpu": [
        "x64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-darwin-x64": "1.2.0"
      }
    },
    "node_modules/@img/sharp-libvips-darwin-arm64": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-darwin-arm64/-/sharp-libvips-darwin-arm64-1.2.0.tgz",
      "integrity": "sha512-sBZmpwmxqwlqG9ueWFXtockhsxefaV6O84BMOrhtg/YqbTaRdqDE7hxraVE3y6gVM4eExmfzW4a8el9ArLeEiQ==",
      "cpu": [
        "arm64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "darwin"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-darwin-x64": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-darwin-x64/-/sharp-libvips-darwin-x64-1.2.0.tgz",
      "integrity": "sha512-M64XVuL94OgiNHa5/m2YvEQI5q2cl9d/wk0qFTDVXcYzi43lxuiFTftMR1tOnFQovVXNZJ5TURSDK2pNe9Yzqg==",
      "cpu": [
        "x64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "darwin"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-arm": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-arm/-/sharp-libvips-linux-arm-1.2.0.tgz",
      "integrity": "sha512-mWd2uWvDtL/nvIzThLq3fr2nnGfyr/XMXlq8ZJ9WMR6PXijHlC3ksp0IpuhK6bougvQrchUAfzRLnbsen0Cqvw==",
      "cpu": [
        "arm"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-arm64": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-arm64/-/sharp-libvips-linux-arm64-1.2.0.tgz",
      "integrity": "sha512-RXwd0CgG+uPRX5YYrkzKyalt2OJYRiJQ8ED/fi1tq9WQW2jsQIn0tqrlR5l5dr/rjqq6AHAxURhj2DVjyQWSOA==",
      "cpu": [
        "arm64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-ppc64": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-ppc64/-/sharp-libvips-linux-ppc64-1.2.0.tgz",
      "integrity": "sha512-Xod/7KaDDHkYu2phxxfeEPXfVXFKx70EAFZ0qyUdOjCcxbjqyJOEUpDe6RIyaunGxT34Anf9ue/wuWOqBW2WcQ==",
      "cpu": [
        "ppc64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-s390x": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-s390x/-/sharp-libvips-linux-s390x-1.2.0.tgz",
      "integrity": "sha512-eMKfzDxLGT8mnmPJTNMcjfO33fLiTDsrMlUVcp6b96ETbnJmd4uvZxVJSKPQfS+odwfVaGifhsB07J1LynFehw==",
      "cpu": [
        "s390x"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-x64": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-x64/-/sharp-libvips-linux-x64-1.2.0.tgz",
      "integrity": "sha512-ZW3FPWIc7K1sH9E3nxIGB3y3dZkpJlMnkk7z5tu1nSkBoCgw2nSRTFHI5pB/3CQaJM0pdzMF3paf9ckKMSE9Tg==",
      "cpu": [
        "x64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linuxmusl-arm64": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linuxmusl-arm64/-/sharp-libvips-linuxmusl-arm64-1.2.0.tgz",
      "integrity": "sha512-UG+LqQJbf5VJ8NWJ5Z3tdIe/HXjuIdo4JeVNADXBFuG7z9zjoegpzzGIyV5zQKi4zaJjnAd2+g2nna8TZvuW9Q==",
      "cpu": [
        "arm64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linuxmusl-x64": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linuxmusl-x64/-/sharp-libvips-linuxmusl-x64-1.2.0.tgz",
      "integrity": "sha512-SRYOLR7CXPgNze8akZwjoGBoN1ThNZoqpOgfnOxmWsklTGVfJiGJoC/Lod7aNMGA1jSsKWM1+HRX43OP6p9+6Q==",
      "cpu": [
        "x64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-linux-arm": {
      "version": "0.34.3",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-arm/-/sharp-linux-arm-0.34.3.tgz",
      "integrity": "sha512-oBK9l+h6KBN0i3dC8rYntLiVfW8D8wH+NPNT3O/WBHeW0OQWCjfWksLUaPidsrDKpJgXp3G3/hkmhptAW0I3+A==",
      "cpu": [
        "arm"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-arm": "1.2.0"
      }
    },
    "node_modules/@img/sharp-linux-arm64": {
      "version": "0.34.3",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-arm64/-/sharp-linux-arm64-0.34.3.tgz",
      "integrity": "sha512-QdrKe3EvQrqwkDrtuTIjI0bu6YEJHTgEeqdzI3uWJOH6G1O8Nl1iEeVYRGdj1h5I21CqxSvQp1Yv7xeU3ZewbA==",
      "cpu": [
        "arm64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-arm64": "1.2.0"
      }
    },
    "node_modules/@img/sharp-linux-ppc64": {
      "version": "0.34.3",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-ppc64/-/sharp-linux-ppc64-0.34.3.tgz",
      "integrity": "sha512-GLtbLQMCNC5nxuImPR2+RgrviwKwVql28FWZIW1zWruy6zLgA5/x2ZXk3mxj58X/tszVF69KK0Is83V8YgWhLA==",
      "cpu": [
        "ppc64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-ppc64": "1.2.0"
      }
    },
    "node_modules/@img/sharp-linux-s390x": {
      "version": "0.34.3",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-s390x/-/sharp-linux-s390x-0.34.3.tgz",
      "integrity": "sha512-3gahT+A6c4cdc2edhsLHmIOXMb17ltffJlxR0aC2VPZfwKoTGZec6u5GrFgdR7ciJSsHT27BD3TIuGcuRT0KmQ==",
      "cpu": [
        "s390x"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-s390x": "1.2.0"
      }
    },
    "node_modules/@img/sharp-linux-x64": {
      "version": "0.34.3",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-x64/-/sharp-linux-x64-0.34.3.tgz",
      "integrity": "sha512-8kYso8d806ypnSq3/Ly0QEw90V5ZoHh10yH0HnrzOCr6DKAPI6QVHvwleqMkVQ0m+fc7EH8ah0BB0QPuWY6zJQ==",
      "cpu": [
        "x64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-x64": "1.2.0"
      }
    },
    "node_modules/@img/sharp-linuxmusl-arm64": {
      "version": "0.34.3",
      "resolved": "https://registry.npmjs.org/@img/sharp-linuxmusl-arm64/-/sharp-linuxmusl-arm64-0.34.3.tgz",
      "integrity": "sha512-vAjbHDlr4izEiXM1OTggpCcPg9tn4YriK5vAjowJsHwdBIdx0fYRsURkxLG2RLm9gyBq66gwtWI8Gx0/ov+JKQ==",
      "cpu": [
        "arm64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linuxmusl-arm64": "1.2.0"
      }
    },
    "node_modules/@img/sharp-linuxmusl-x64": {
      "version": "0.34.3",
      "resolved": "https://registry.npmjs.org/@img/sharp-linuxmusl-x64/-/sharp-linuxmusl-x64-0.34.3.tgz",
      "integrity": "sha512-gCWUn9547K5bwvOn9l5XGAEjVTTRji4aPTqLzGXHvIr6bIDZKNTA34seMPgM0WmSf+RYBH411VavCejp3PkOeQ==",
      "cpu": [
        "x64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linuxmusl-x64": "1.2.0"
      }
    },
    "node_modules/@img/sharp-wasm32": {
      "version": "0.34.3",
      "resolved": "https://registry.npmjs.org/@img/sharp-wasm32/-/sharp-wasm32-0.34.3.tgz",
      "integrity": "sha512-+CyRcpagHMGteySaWos8IbnXcHgfDn7pO2fiC2slJxvNq9gDipYBN42/RagzctVRKgxATmfqOSulgZv5e1RdMg==",
      "cpu": [
        "wasm32"
      ],
      "license": "Apache-2.0 AND LGPL-3.0-or-later AND MIT",
      "optional": true,
      "dependencies": {
        "@emnapi/runtime": "^1.4.4"
      },
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-win32-arm64": {
      "version": "0.34.3",
      "resolved": "https://registry.npmjs.org/@img/sharp-win32-arm64/-/sharp-win32-arm64-0.34.3.tgz",
      "integrity": "sha512-MjnHPnbqMXNC2UgeLJtX4XqoVHHlZNd+nPt1kRPmj63wURegwBhZlApELdtxM2OIZDRv/DFtLcNhVbd1z8GYXQ==",
      "cpu": [
        "arm64"
      ],
      "license": "Apache-2.0 AND LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-win32-ia32": {
      "version": "0.34.3",
      "resolved": "https://registry.npmjs.org/@img/sharp-win32-ia32/-/sharp-win32-ia32-0.34.3.tgz",
      "integrity": "sha512-xuCdhH44WxuXgOM714hn4amodJMZl3OEvf0GVTm0BEyMeA2to+8HEdRPShH0SLYptJY1uBw+SCFP9WVQi1Q/cw==",
      "cpu": [
        "ia32"
      ],
      "license": "Apache-2.0 AND LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-win32-x64": {
      "version": "0.34.3",
      "resolved": "https://registry.npmjs.org/@img/sharp-win32-x64/-/sharp-win32-x64-0.34.3.tgz",
      "integrity": "sha512-OWwz05d++TxzLEv4VnsTz5CmZ6mI6S05sfQGEMrNrQcOEERbX46332IvE7pO/EUiw7jUrrS40z/M7kPyjfl04g==",
      "cpu": [
        "x64"
      ],
      "license": "Apache-2.0 AND LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@isaacs/fs-minipass": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/@isaacs/fs-minipass/-/fs-minipass-4.0.1.tgz",
      "integrity": "sha512-wgm9Ehl2jpeqP3zw/7mo3kRHFp5MEDhqAdwy1fTGkHAwnkGOVsgpvQhL8B5n1qlb01jV3n/bI0ZfZp5lWA1k4w==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "minipass": "^7.0.4"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.13",
      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.0",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/remapping": {
      "version": "2.3.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/remapping/-/remapping-2.3.5.tgz",
      "integrity": "sha512-LI9u/+laYG4Ds1TDKSJW2YPrIlcVYOwi2fUC6xB43lueCjgxV4lffOCZCtYFiH6TNOX+tQKXx97T4IKHbhyHEQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
      "integrity": "sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.30",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.30.tgz",
      "integrity": "sha512-GQ7Nw5G2lTu/BtHTKfXhKHok2WGetd4XYcVKGx00SjAk8GMwgJM3zr6zORiPGuOE+/vkc90KtTosSSvaCjKb2Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.1.0",
        "@jridgewell/sourcemap-codec": "^1.4.14"
      }
    },
    "node_modules/@napi-rs/wasm-runtime": {
      "version": "0.2.12",
      "resolved": "https://registry.npmjs.org/@napi-rs/wasm-runtime/-/wasm-runtime-0.2.12.tgz",
      "integrity": "sha512-ZVWUcfwY4E/yPitQJl481FjFo3K22D6qF0DuFH6Y/nbnE11GY5uguDxZMGXPQ8WQ0128MXQD7TnfHyK4oWoIJQ==",
      "dev": true,
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "@emnapi/core": "^1.4.3",
        "@emnapi/runtime": "^1.4.3",
        "@tybys/wasm-util": "^0.10.0"
      }
    },
    "node_modules/@next/env": {
      "version": "15.5.2",
      "resolved": "https://registry.npmjs.org/@next/env/-/env-15.5.2.tgz",
      "integrity": "sha512-Qe06ew4zt12LeO6N7j8/nULSOe3fMXE4dM6xgpBQNvdzyK1sv5y4oAP3bq4LamrvGCZtmRYnW8URFCeX5nFgGg==",
      "license": "MIT"
    },
    "node_modules/@next/eslint-plugin-next": {
      "version": "15.5.2",
      "resolved": "https://registry.npmjs.org/@next/eslint-plugin-next/-/eslint-plugin-next-15.5.2.tgz",
      "integrity": "sha512-lkLrRVxcftuOsJNhWatf1P2hNVfh98k/omQHrCEPPriUypR6RcS13IvLdIrEvkm9AH2Nu2YpR5vLqBuy6twH3Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fast-glob": "3.3.1"
      }
    },
    "node_modules/@next/swc-darwin-arm64": {
      "version": "15.5.2",
      "resolved": "https://registry.npmjs.org/@next/swc-darwin-arm64/-/swc-darwin-arm64-15.5.2.tgz",
      "integrity": "sha512-8bGt577BXGSd4iqFygmzIfTYizHb0LGWqH+qgIF/2EDxS5JsSdERJKA8WgwDyNBZgTIIA4D8qUtoQHmxIIquoQ==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-darwin-x64": {
      "version": "15.5.2",
      "resolved": "https://registry.npmjs.org/@next/swc-darwin-x64/-/swc-darwin-x64-15.5.2.tgz",
      "integrity": "sha512-2DjnmR6JHK4X+dgTXt5/sOCu/7yPtqpYt8s8hLkHFK3MGkka2snTv3yRMdHvuRtJVkPwCGsvBSwmoQCHatauFQ==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-linux-arm64-gnu": {
      "version": "15.5.2",
      "resolved": "https://registry.npmjs.org/@next/swc-linux-arm64-gnu/-/swc-linux-arm64-gnu-15.5.2.tgz",
      "integrity": "sha512-3j7SWDBS2Wov/L9q0mFJtEvQ5miIqfO4l7d2m9Mo06ddsgUK8gWfHGgbjdFlCp2Ek7MmMQZSxpGFqcC8zGh2AA==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-linux-arm64-musl": {
      "version": "15.5.2",
      "resolved": "https://registry.npmjs.org/@next/swc-linux-arm64-musl/-/swc-linux-arm64-musl-15.5.2.tgz",
      "integrity": "sha512-s6N8k8dF9YGc5T01UPQ08yxsK6fUow5gG1/axWc1HVVBYQBgOjca4oUZF7s4p+kwhkB1bDSGR8QznWrFZ/Rt5g==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-linux-x64-gnu": {
      "version": "15.5.2",
      "resolved": "https://registry.npmjs.org/@next/swc-linux-x64-gnu/-/swc-linux-x64-gnu-15.5.2.tgz",
      "integrity": "sha512-o1RV/KOODQh6dM6ZRJGZbc+MOAHww33Vbs5JC9Mp1gDk8cpEO+cYC/l7rweiEalkSm5/1WGa4zY7xrNwObN4+Q==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-linux-x64-musl": {
      "version": "15.5.2",
      "resolved": "https://registry.npmjs.org/@next/swc-linux-x64-musl/-/swc-linux-x64-musl-15.5.2.tgz",
      "integrity": "sha512-/VUnh7w8RElYZ0IV83nUcP/J4KJ6LLYliiBIri3p3aW2giF+PAVgZb6mk8jbQSB3WlTai8gEmCAr7kptFa1H6g==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-win32-arm64-msvc": {
      "version": "15.5.2",
      "resolved": "https://registry.npmjs.org/@next/swc-win32-arm64-msvc/-/swc-win32-arm64-msvc-15.5.2.tgz",
      "integrity": "sha512-sMPyTvRcNKXseNQ/7qRfVRLa0VhR0esmQ29DD6pqvG71+JdVnESJaHPA8t7bc67KD5spP3+DOCNLhqlEI2ZgQg==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-win32-x64-msvc": {
      "version": "15.5.2",
      "resolved": "https://registry.npmjs.org/@next/swc-win32-x64-msvc/-/swc-win32-x64-msvc-15.5.2.tgz",
      "integrity": "sha512-W5VvyZHnxG/2ukhZF/9Ikdra5fdNftxI6ybeVKYvBPDtyx7x4jPPSNduUkfH5fo3zG0JQ0bPxgy41af2JX5D4Q==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@nodelib/fs.scandir": {
      "version": "2.1.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
      "integrity": "sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "2.0.5",
        "run-parallel": "^1.1.9"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.stat": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz",
      "integrity": "sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.walk": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz",
      "integrity": "sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.scandir": "2.1.5",
        "fastq": "^1.6.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nolyfill/is-core-module": {
      "version": "1.0.39",
      "resolved": "https://registry.npmjs.org/@nolyfill/is-core-module/-/is-core-module-1.0.39.tgz",
      "integrity": "sha512-nn5ozdjYQpUCZlWGuxcJY/KpxkWQs4DcbMCmKojjyrYDEAGy4Ce19NN4v5MduafTwJlbKc99UA8YhSVqq9yPZA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12.4.0"
      }
    },
    "node_modules/@rtsao/scc": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@rtsao/scc/-/scc-1.1.0.tgz",
      "integrity": "sha512-zt6OdqaDoOnJ1ZYsCYGt9YmWzDXl4vQdKTyJev62gFhRGKdx7mcT54V9KIjg+d2wi9EXsPvAPKe7i7WjfVWB8g==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@rushstack/eslint-patch": {
      "version": "1.12.0",
      "resolved": "https://registry.npmjs.org/@rushstack/eslint-patch/-/eslint-patch-1.12.0.tgz",
      "integrity": "sha512-5EwMtOqvJMMa3HbmxLlF74e+3/HhwBTMcvt3nqVJgGCozO6hzIPOBlwm8mGVNR9SN2IJpxSnlxczyDjcn7qIyw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@swc/helpers": {
      "version": "0.5.15",
      "resolved": "https://registry.npmjs.org/@swc/helpers/-/helpers-0.5.15.tgz",
      "integrity": "sha512-JQ5TuMi45Owi4/BIMAJBoSQoOJu12oOk/gADqlcUL9JEdHB8vyjUSsxqeNXnmXHjYKMi2WcYtezGEEhqUI/E2g==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.8.0"
      }
    },
    "node_modules/@tailwindcss/node": {
      "version": "4.1.12",
      "resolved": "https://registry.npmjs.org/@tailwindcss/node/-/node-4.1.12.tgz",
      "integrity": "sha512-3hm9brwvQkZFe++SBt+oLjo4OLDtkvlE8q2WalaD/7QWaeM7KEJbAiY/LJZUaCs7Xa8aUu4xy3uoyX4q54UVdQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/remapping": "^2.3.4",
        "enhanced-resolve": "^5.18.3",
        "jiti": "^2.5.1",
        "lightningcss": "1.30.1",
        "magic-string": "^0.30.17",
        "source-map-js": "^1.2.1",
        "tailwindcss": "4.1.12"
      }
    },
    "node_modules/@tailwindcss/oxide": {
      "version": "4.1.12",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide/-/oxide-4.1.12.tgz",
      "integrity": "sha512-gM5EoKHW/ukmlEtphNwaGx45fGoEmP10v51t9unv55voWh6WrOL19hfuIdo2FjxIaZzw776/BUQg7Pck++cIVw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "dependencies": {
        "detect-libc": "^2.0.4",
        "tar": "^7.4.3"
      },
      "engines": {
        "node": ">= 10"
      },
      "optionalDependencies": {
        "@tailwindcss/oxide-android-arm64": "4.1.12",
        "@tailwindcss/oxide-darwin-arm64": "4.1.12",
        "@tailwindcss/oxide-darwin-x64": "4.1.12",
        "@tailwindcss/oxide-freebsd-x64": "4.1.12",
        "@tailwindcss/oxide-linux-arm-gnueabihf": "4.1.12",
        "@tailwindcss/oxide-linux-arm64-gnu": "4.1.12",
        "@tailwindcss/oxide-linux-arm64-musl": "4.1.12",
        "@tailwindcss/oxide-linux-x64-gnu": "4.1.12",
        "@tailwindcss/oxide-linux-x64-musl": "4.1.12",
        "@tailwindcss/oxide-wasm32-wasi": "4.1.12",
        "@tailwindcss/oxide-win32-arm64-msvc": "4.1.12",
        "@tailwindcss/oxide-win32-x64-msvc": "4.1.12"
      }
    },
    "node_modules/@tailwindcss/oxide-android-arm64": {
      "version": "4.1.12",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-android-arm64/-/oxide-android-arm64-4.1.12.tgz",
      "integrity": "sha512-oNY5pq+1gc4T6QVTsZKwZaGpBb2N1H1fsc1GD4o7yinFySqIuRZ2E4NvGasWc6PhYJwGK2+5YT1f9Tp80zUQZQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-darwin-arm64": {
      "version": "4.1.12",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-darwin-arm64/-/oxide-darwin-arm64-4.1.12.tgz",
      "integrity": "sha512-cq1qmq2HEtDV9HvZlTtrj671mCdGB93bVY6J29mwCyaMYCP/JaUBXxrQQQm7Qn33AXXASPUb2HFZlWiiHWFytw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-darwin-x64": {
      "version": "4.1.12",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-darwin-x64/-/oxide-darwin-x64-4.1.12.tgz",
      "integrity": "sha512-6UCsIeFUcBfpangqlXay9Ffty9XhFH1QuUFn0WV83W8lGdX8cD5/+2ONLluALJD5+yJ7k8mVtwy3zMZmzEfbLg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-freebsd-x64": {
      "version": "4.1.12",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-freebsd-x64/-/oxide-freebsd-x64-4.1.12.tgz",
      "integrity": "sha512-JOH/f7j6+nYXIrHobRYCtoArJdMJh5zy5lr0FV0Qu47MID/vqJAY3r/OElPzx1C/wdT1uS7cPq+xdYYelny1ww==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-arm-gnueabihf": {
      "version": "4.1.12",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-arm-gnueabihf/-/oxide-linux-arm-gnueabihf-4.1.12.tgz",
      "integrity": "sha512-v4Ghvi9AU1SYgGr3/j38PD8PEe6bRfTnNSUE3YCMIRrrNigCFtHZ2TCm8142X8fcSqHBZBceDx+JlFJEfNg5zQ==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-arm64-gnu": {
      "version": "4.1.12",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-arm64-gnu/-/oxide-linux-arm64-gnu-4.1.12.tgz",
      "integrity": "sha512-YP5s1LmetL9UsvVAKusHSyPlzSRqYyRB0f+Kl/xcYQSPLEw/BvGfxzbH+ihUciePDjiXwHh+p+qbSP3SlJw+6g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-arm64-musl": {
      "version": "4.1.12",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-arm64-musl/-/oxide-linux-arm64-musl-4.1.12.tgz",
      "integrity": "sha512-V8pAM3s8gsrXcCv6kCHSuwyb/gPsd863iT+v1PGXC4fSL/OJqsKhfK//v8P+w9ThKIoqNbEnsZqNy+WDnwQqCA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-x64-gnu": {
      "version": "4.1.12",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-x64-gnu/-/oxide-linux-x64-gnu-4.1.12.tgz",
      "integrity": "sha512-xYfqYLjvm2UQ3TZggTGrwxjYaLB62b1Wiysw/YE3Yqbh86sOMoTn0feF98PonP7LtjsWOWcXEbGqDL7zv0uW8Q==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-x64-musl": {
      "version": "4.1.12",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-x64-musl/-/oxide-linux-x64-musl-4.1.12.tgz",
      "integrity": "sha512-ha0pHPamN+fWZY7GCzz5rKunlv9L5R8kdh+YNvP5awe3LtuXb5nRi/H27GeL2U+TdhDOptU7T6Is7mdwh5Ar3A==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-wasm32-wasi": {
      "version": "4.1.12",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-wasm32-wasi/-/oxide-wasm32-wasi-4.1.12.tgz",
      "integrity": "sha512-4tSyu3dW+ktzdEpuk6g49KdEangu3eCYoqPhWNsZgUhyegEda3M9rG0/j1GV/JjVVsj+lG7jWAyrTlLzd/WEBg==",
      "bundleDependencies": [
        "@napi-rs/wasm-runtime",
        "@emnapi/core",
        "@emnapi/runtime",
        "@tybys/wasm-util",
        "@emnapi/wasi-threads",
        "tslib"
      ],
      "cpu": [
        "wasm32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "@emnapi/core": "^1.4.5",
        "@emnapi/runtime": "^1.4.5",
        "@emnapi/wasi-threads": "^1.0.4",
        "@napi-rs/wasm-runtime": "^0.2.12",
        "@tybys/wasm-util": "^0.10.0",
        "tslib": "^2.8.0"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@tailwindcss/oxide-win32-arm64-msvc": {
      "version": "4.1.12",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-win32-arm64-msvc/-/oxide-win32-arm64-msvc-4.1.12.tgz",
      "integrity": "sha512-iGLyD/cVP724+FGtMWslhcFyg4xyYyM+5F4hGvKA7eifPkXHRAUDFaimu53fpNg9X8dfP75pXx/zFt/jlNF+lg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-win32-x64-msvc": {
      "version": "4.1.12",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-win32-x64-msvc/-/oxide-win32-x64-msvc-4.1.12.tgz",
      "integrity": "sha512-NKIh5rzw6CpEodv/++r0hGLlfgT/gFN+5WNdZtvh6wpU2BpGNgdjvj6H2oFc8nCM839QM1YOhjpgbAONUb4IxA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/postcss": {
      "version": "4.1.12",
      "resolved": "https://registry.npmjs.org/@tailwindcss/postcss/-/postcss-4.1.12.tgz",
      "integrity": "sha512-5PpLYhCAwf9SJEeIsSmCDLgyVfdBhdBpzX1OJ87anT9IVR0Z9pjM0FNixCAUAHGnMBGB8K99SwAheXrT0Kh6QQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@alloc/quick-lru": "^5.2.0",
        "@tailwindcss/node": "4.1.12",
        "@tailwindcss/oxide": "4.1.12",
        "postcss": "^8.4.41",
        "tailwindcss": "4.1.12"
      }
    },
    "node_modules/@tybys/wasm-util": {
      "version": "0.10.0",
      "resolved": "https://registry.npmjs.org/@tybys/wasm-util/-/wasm-util-0.10.0.tgz",
      "integrity": "sha512-VyyPYFlOMNylG45GoAe0xDoLwWuowvf92F9kySqzYh8vmYm7D2u4iUJKa1tOUpS70Ku13ASrOkS4ScXFsTaCNQ==",
      "dev": true,
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "tslib": "^2.4.0"
      }
    },
    "node_modules/@types/estree": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.8.tgz",
      "integrity": "sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/json-schema": {
      "version": "7.0.15",
      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz",
      "integrity": "sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/json5": {
      "version": "0.0.29",
      "resolved": "https://registry.npmjs.org/@types/json5/-/json5-0.0.29.tgz",
      "integrity": "sha512-dRLjCWHYg4oaA77cxO64oO+7JwCwnIzkZPdrrC71jQmQtlhM556pwKo5bUzqvZndkVbeFLIIi+9TC40JNF5hNQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/node": {
      "version": "20.19.11",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-20.19.11.tgz",
      "integrity": "sha512-uug3FEEGv0r+jrecvUUpbY8lLisvIjg6AAic6a2bSP5OEOLeJsDSnvhCDov7ipFFMXS3orMpzlmi0ZcuGkBbow==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/react": {
      "version": "19.1.12",
      "resolved": "https://registry.npmjs.org/@types/react/-/react-19.1.12.tgz",
      "integrity": "sha512-cMoR+FoAf/Jyq6+Df2/Z41jISvGZZ2eTlnsaJRptmZ76Caldwy1odD4xTr/gNV9VLj0AWgg/nmkevIyUfIIq5w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "csstype": "^3.0.2"
      }
    },
    "node_modules/@types/react-dom": {
      "version": "19.1.9",
      "resolved": "https://registry.npmjs.org/@types/react-dom/-/react-dom-19.1.9.tgz",
      "integrity": "sha512-qXRuZaOsAdXKFyOhRBg6Lqqc0yay13vN7KrIg4L7N4aaHN68ma9OK3NE1BoDFgFOTfM7zg+3/8+2n8rLUH3OKQ==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "^19.0.0"
      }
    },
    "node_modules/@typescript-eslint/eslint-plugin": {
      "version": "8.41.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-8.41.0.tgz",
      "integrity": "sha512-8fz6oa6wEKZrhXWro/S3n2eRJqlRcIa6SlDh59FXJ5Wp5XRZ8B9ixpJDcjadHq47hMx0u+HW6SNa6LjJQ6NLtw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/regexpp": "^4.10.0",
        "@typescript-eslint/scope-manager": "8.41.0",
        "@typescript-eslint/type-utils": "8.41.0",
        "@typescript-eslint/utils": "8.41.0",
        "@typescript-eslint/visitor-keys": "8.41.0",
        "graphemer": "^1.4.0",
        "ignore": "^7.0.0",
        "natural-compare": "^1.4.0",
        "ts-api-utils": "^2.1.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "@typescript-eslint/parser": "^8.41.0",
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/eslint-plugin/node_modules/ignore": {
      "version": "7.0.5",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-7.0.5.tgz",
      "integrity": "sha512-Hs59xBNfUIunMFgWAbGX5cq6893IbWg4KnrjbYwX3tx0ztorVgTDA6B2sxf8ejHJ4wz8BqGUMYlnzNBer5NvGg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/@typescript-eslint/parser": {
      "version": "8.41.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/parser/-/parser-8.41.0.tgz",
      "integrity": "sha512-gTtSdWX9xiMPA/7MV9STjJOOYtWwIJIYxkQxnSV1U3xcE+mnJSH3f6zI0RYP+ew66WSlZ5ed+h0VCxsvdC1jJg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/scope-manager": "8.41.0",
        "@typescript-eslint/types": "8.41.0",
        "@typescript-eslint/typescript-estree": "8.41.0",
        "@typescript-eslint/visitor-keys": "8.41.0",
        "debug": "^4.3.4"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/project-service": {
      "version": "8.41.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/project-service/-/project-service-8.41.0.tgz",
      "integrity": "sha512-b8V9SdGBQzQdjJ/IO3eDifGpDBJfvrNTp2QD9P2BeqWTGrRibgfgIlBSw6z3b6R7dPzg752tOs4u/7yCLxksSQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/tsconfig-utils": "^8.41.0",
        "@typescript-eslint/types": "^8.41.0",
        "debug": "^4.3.4"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/scope-manager": {
      "version": "8.41.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-8.41.0.tgz",
      "integrity": "sha512-n6m05bXn/Cd6DZDGyrpXrELCPVaTnLdPToyhBoFkLIMznRUQUEQdSp96s/pcWSQdqOhrgR1mzJ+yItK7T+WPMQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "8.41.0",
        "@typescript-eslint/visitor-keys": "8.41.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/tsconfig-utils": {
      "version": "8.41.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/tsconfig-utils/-/tsconfig-utils-8.41.0.tgz",
      "integrity": "sha512-TDhxYFPUYRFxFhuU5hTIJk+auzM/wKvWgoNYOPcOf6i4ReYlOoYN8q1dV5kOTjNQNJgzWN3TUUQMtlLOcUgdUw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/type-utils": {
      "version": "8.41.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/type-utils/-/type-utils-8.41.0.tgz",
      "integrity": "sha512-63qt1h91vg3KsjVVonFJWjgSK7pZHSQFKH6uwqxAH9bBrsyRhO6ONoKyXxyVBzG1lJnFAJcKAcxLS54N1ee1OQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "8.41.0",
        "@typescript-eslint/typescript-estree": "8.41.0",
        "@typescript-eslint/utils": "8.41.0",
        "debug": "^4.3.4",
        "ts-api-utils": "^2.1.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/types": {
      "version": "8.41.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/types/-/types-8.41.0.tgz",
      "integrity": "sha512-9EwxsWdVqh42afLbHP90n2VdHaWU/oWgbH2P0CfcNfdKL7CuKpwMQGjwev56vWu9cSKU7FWSu6r9zck6CVfnag==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree": {
      "version": "8.41.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-8.41.0.tgz",
      "integrity": "sha512-D43UwUYJmGhuwHfY7MtNKRZMmfd8+p/eNSfFe6tH5mbVDto+VQCayeAt35rOx3Cs6wxD16DQtIKw/YXxt5E0UQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/project-service": "8.41.0",
        "@typescript-eslint/tsconfig-utils": "8.41.0",
        "@typescript-eslint/types": "8.41.0",
        "@typescript-eslint/visitor-keys": "8.41.0",
        "debug": "^4.3.4",
        "fast-glob": "^3.3.2",
        "is-glob": "^4.0.3",
        "minimatch": "^9.0.4",
        "semver": "^7.6.0",
        "ts-api-utils": "^2.1.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/brace-expansion": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.2.tgz",
      "integrity": "sha512-Jt0vHyM+jmUBqojB7E1NIYadt0vI0Qxjxd2TErW94wDz+E2LAm5vKMXXwg6ZZBTHPuUlDgQHKXvjGBdfcF1ZDQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/fast-glob": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.3.3.tgz",
      "integrity": "sha512-7MptL8U0cqcFdzIzwOTHoilX9x5BrNqye7Z/LuC7kCMRio1EMSyqRK3BEAUD7sXRq4iT4AzTVuZdhgQ2TCvYLg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "^2.0.2",
        "@nodelib/fs.walk": "^1.2.3",
        "glob-parent": "^5.1.2",
        "merge2": "^1.3.0",
        "micromatch": "^4.0.8"
      },
      "engines": {
        "node": ">=8.6.0"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/minimatch": {
      "version": "9.0.5",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-9.0.5.tgz",
      "integrity": "sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^2.0.1"
      },
      "engines": {
        "node": ">=16 || 14 >=14.17"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/@typescript-eslint/utils": {
      "version": "8.41.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/utils/-/utils-8.41.0.tgz",
      "integrity": "sha512-udbCVstxZ5jiPIXrdH+BZWnPatjlYwJuJkDA4Tbo3WyYLh8NvB+h/bKeSZHDOFKfphsZYJQqaFtLeXEqurQn1A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.7.0",
        "@typescript-eslint/scope-manager": "8.41.0",
        "@typescript-eslint/types": "8.41.0",
        "@typescript-eslint/typescript-estree": "8.41.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/visitor-keys": {
      "version": "8.41.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-8.41.0.tgz",
      "integrity": "sha512-+GeGMebMCy0elMNg67LRNoVnUFPIm37iu5CmHESVx56/9Jsfdpsvbv605DQ81Pi/x11IdKUsS5nzgTYbCQU9fg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "8.41.0",
        "eslint-visitor-keys": "^4.2.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@unrs/resolver-binding-android-arm-eabi": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-android-arm-eabi/-/resolver-binding-android-arm-eabi-1.11.1.tgz",
      "integrity": "sha512-ppLRUgHVaGRWUx0R0Ut06Mjo9gBaBkg3v/8AxusGLhsIotbBLuRk51rAzqLC8gq6NyyAojEXglNjzf6R948DNw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@unrs/resolver-binding-android-arm64": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-android-arm64/-/resolver-binding-android-arm64-1.11.1.tgz",
      "integrity": "sha512-lCxkVtb4wp1v+EoN+HjIG9cIIzPkX5OtM03pQYkG+U5O/wL53LC4QbIeazgiKqluGeVEeBlZahHalCaBvU1a2g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@unrs/resolver-binding-darwin-arm64": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-darwin-arm64/-/resolver-binding-darwin-arm64-1.11.1.tgz",
      "integrity": "sha512-gPVA1UjRu1Y/IsB/dQEsp2V1pm44Of6+LWvbLc9SDk1c2KhhDRDBUkQCYVWe6f26uJb3fOK8saWMgtX8IrMk3g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@unrs/resolver-binding-darwin-x64": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-darwin-x64/-/resolver-binding-darwin-x64-1.11.1.tgz",
      "integrity": "sha512-cFzP7rWKd3lZaCsDze07QX1SC24lO8mPty9vdP+YVa3MGdVgPmFc59317b2ioXtgCMKGiCLxJ4HQs62oz6GfRQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@unrs/resolver-binding-freebsd-x64": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-freebsd-x64/-/resolver-binding-freebsd-x64-1.11.1.tgz",
      "integrity": "sha512-fqtGgak3zX4DCB6PFpsH5+Kmt/8CIi4Bry4rb1ho6Av2QHTREM+47y282Uqiu3ZRF5IQioJQ5qWRV6jduA+iGw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-arm-gnueabihf": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-arm-gnueabihf/-/resolver-binding-linux-arm-gnueabihf-1.11.1.tgz",
      "integrity": "sha512-u92mvlcYtp9MRKmP+ZvMmtPN34+/3lMHlyMj7wXJDeXxuM0Vgzz0+PPJNsro1m3IZPYChIkn944wW8TYgGKFHw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-arm-musleabihf": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-arm-musleabihf/-/resolver-binding-linux-arm-musleabihf-1.11.1.tgz",
      "integrity": "sha512-cINaoY2z7LVCrfHkIcmvj7osTOtm6VVT16b5oQdS4beibX2SYBwgYLmqhBjA1t51CarSaBuX5YNsWLjsqfW5Cw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-arm64-gnu": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-arm64-gnu/-/resolver-binding-linux-arm64-gnu-1.11.1.tgz",
      "integrity": "sha512-34gw7PjDGB9JgePJEmhEqBhWvCiiWCuXsL9hYphDF7crW7UgI05gyBAi6MF58uGcMOiOqSJ2ybEeCvHcq0BCmQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-arm64-musl": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-arm64-musl/-/resolver-binding-linux-arm64-musl-1.11.1.tgz",
      "integrity": "sha512-RyMIx6Uf53hhOtJDIamSbTskA99sPHS96wxVE/bJtePJJtpdKGXO1wY90oRdXuYOGOTuqjT8ACccMc4K6QmT3w==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-ppc64-gnu": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-ppc64-gnu/-/resolver-binding-linux-ppc64-gnu-1.11.1.tgz",
      "integrity": "sha512-D8Vae74A4/a+mZH0FbOkFJL9DSK2R6TFPC9M+jCWYia/q2einCubX10pecpDiTmkJVUH+y8K3BZClycD8nCShA==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-riscv64-gnu": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-riscv64-gnu/-/resolver-binding-linux-riscv64-gnu-1.11.1.tgz",
      "integrity": "sha512-frxL4OrzOWVVsOc96+V3aqTIQl1O2TjgExV4EKgRY09AJ9leZpEg8Ak9phadbuX0BA4k8U5qtvMSQQGGmaJqcQ==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-riscv64-musl": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-riscv64-musl/-/resolver-binding-linux-riscv64-musl-1.11.1.tgz",
      "integrity": "sha512-mJ5vuDaIZ+l/acv01sHoXfpnyrNKOk/3aDoEdLO/Xtn9HuZlDD6jKxHlkN8ZhWyLJsRBxfv9GYM2utQ1SChKew==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-s390x-gnu": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-s390x-gnu/-/resolver-binding-linux-s390x-gnu-1.11.1.tgz",
      "integrity": "sha512-kELo8ebBVtb9sA7rMe1Cph4QHreByhaZ2QEADd9NzIQsYNQpt9UkM9iqr2lhGr5afh885d/cB5QeTXSbZHTYPg==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-x64-gnu": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-x64-gnu/-/resolver-binding-linux-x64-gnu-1.11.1.tgz",
      "integrity": "sha512-C3ZAHugKgovV5YvAMsxhq0gtXuwESUKc5MhEtjBpLoHPLYM+iuwSj3lflFwK3DPm68660rZ7G8BMcwSro7hD5w==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-x64-musl": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-x64-musl/-/resolver-binding-linux-x64-musl-1.11.1.tgz",
      "integrity": "sha512-rV0YSoyhK2nZ4vEswT/QwqzqQXw5I6CjoaYMOX0TqBlWhojUf8P94mvI7nuJTeaCkkds3QE4+zS8Ko+GdXuZtA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-wasm32-wasi": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-wasm32-wasi/-/resolver-binding-wasm32-wasi-1.11.1.tgz",
      "integrity": "sha512-5u4RkfxJm+Ng7IWgkzi3qrFOvLvQYnPBmjmZQ8+szTK/b31fQCnleNl1GgEt7nIsZRIf5PLhPwT0WM+q45x/UQ==",
      "cpu": [
        "wasm32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "@napi-rs/wasm-runtime": "^0.2.11"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@unrs/resolver-binding-win32-arm64-msvc": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-win32-arm64-msvc/-/resolver-binding-win32-arm64-msvc-1.11.1.tgz",
      "integrity": "sha512-nRcz5Il4ln0kMhfL8S3hLkxI85BXs3o8EYoattsJNdsX4YUU89iOkVn7g0VHSRxFuVMdM4Q1jEpIId1Ihim/Uw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@unrs/resolver-binding-win32-ia32-msvc": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-win32-ia32-msvc/-/resolver-binding-win32-ia32-msvc-1.11.1.tgz",
      "integrity": "sha512-DCEI6t5i1NmAZp6pFonpD5m7i6aFrpofcp4LA2i8IIq60Jyo28hamKBxNrZcyOwVOZkgsRp9O2sXWBWP8MnvIQ==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@unrs/resolver-binding-win32-x64-msvc": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-win32-x64-msvc/-/resolver-binding-win32-x64-msvc-1.11.1.tgz",
      "integrity": "sha512-lrW200hZdbfRtztbygyaq/6jP6AKE8qQN2KvPcJ+x7wiD038YtnYtZ82IMNJ69GJibV7bwL3y9FgK+5w/pYt6g==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/acorn": {
      "version": "8.15.0",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.15.0.tgz",
      "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-jsx": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz",
      "integrity": "sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "acorn": "^6.0.0 || ^7.0.0 || ^8.0.0"
      }
    },
    "node_modules/ajv": {
      "version": "6.12.6",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fast-deep-equal": "^3.1.1",
        "fast-json-stable-stringify": "^2.0.0",
        "json-schema-traverse": "^0.4.1",
        "uri-js": "^4.2.2"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/epoberezkin"
      }
    },
    "node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/argparse": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
      "dev": true,
      "license": "Python-2.0"
    },
    "node_modules/aria-query": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/aria-query/-/aria-query-5.3.2.tgz",
      "integrity": "sha512-COROpnaoap1E2F000S62r6A60uHZnmlvomhfyT2DlTcrY1OrBKn2UhH7qn5wTC9zMvD0AY7csdPSNwKP+7WiQw==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/array-buffer-byte-length": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/array-buffer-byte-length/-/array-buffer-byte-length-1.0.2.tgz",
      "integrity": "sha512-LHE+8BuR7RYGDKvnrmcuSq3tDcKv9OFEXQt/HpbZhY7V6h0zlUXutnAD82GiFx9rdieCMjkvtcsPqBwgUl1Iiw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "is-array-buffer": "^3.0.5"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/array-includes": {
      "version": "3.1.9",
      "resolved": "https://registry.npmjs.org/array-includes/-/array-includes-3.1.9.tgz",
      "integrity": "sha512-FmeCCAenzH0KH381SPT5FZmiA/TmpndpcaShhfgEN9eCVjnFBqq3l1xrI42y8+PPLI6hypzou4GXw00WHmPBLQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.4",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.24.0",
        "es-object-atoms": "^1.1.1",
        "get-intrinsic": "^1.3.0",
        "is-string": "^1.1.1",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/array.prototype.findlast": {
      "version": "1.2.5",
      "resolved": "https://registry.npmjs.org/array.prototype.findlast/-/array.prototype.findlast-1.2.5.tgz",
      "integrity": "sha512-CVvd6FHg1Z3POpBLxO6E6zr+rSKEQ9L6rZHAaY7lLfhKsWYUBBOuMs0e9o24oopj6H+geRCX0YJ+TJLBK2eHyQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.7",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.2",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.0.0",
        "es-shim-unscopables": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/array.prototype.findlastindex": {
      "version": "1.2.6",
      "resolved": "https://registry.npmjs.org/array.prototype.findlastindex/-/array.prototype.findlastindex-1.2.6.tgz",
      "integrity": "sha512-F/TKATkzseUExPlfvmwQKGITM3DGTK+vkAsCZoDc5daVygbJBnjEUCbgkAvVFsgfXfX4YIqZ/27G3k3tdXrTxQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.4",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.9",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "es-shim-unscopables": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/array.prototype.flat": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/array.prototype.flat/-/array.prototype.flat-1.3.3.tgz",
      "integrity": "sha512-rwG/ja1neyLqCuGZ5YYrznA62D4mZXg0i1cIskIUKSiqF3Cje9/wXAls9B9s1Wa2fomMsIv8czB8jZcPmxCXFg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.5",
        "es-shim-unscopables": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/array.prototype.flatmap": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/array.prototype.flatmap/-/array.prototype.flatmap-1.3.3.tgz",
      "integrity": "sha512-Y7Wt51eKJSyi80hFrJCePGGNo5ktJCslFuboqJsbf57CCPcm5zztluPlc4/aD8sWsKvlwatezpV4U1efk8kpjg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.5",
        "es-shim-unscopables": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/array.prototype.tosorted": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/array.prototype.tosorted/-/array.prototype.tosorted-1.1.4.tgz",
      "integrity": "sha512-p6Fx8B7b7ZhL/gmUsAy0D15WhvDccw3mnGNbZpi3pmeJdxtWsj2jEaI4Y6oo3XiHfzuSgPwKc04MYt6KgvC/wA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.7",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.3",
        "es-errors": "^1.3.0",
        "es-shim-unscopables": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/arraybuffer.prototype.slice": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/arraybuffer.prototype.slice/-/arraybuffer.prototype.slice-1.0.4.tgz",
      "integrity": "sha512-BNoCY6SXXPQ7gF2opIP4GBE+Xw7U+pHMYKuzjgCN3GwiaIR09UUeKfheyIry77QtrCBlC0KK0q5/TER/tYh3PQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "array-buffer-byte-length": "^1.0.1",
        "call-bind": "^1.0.8",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.5",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "is-array-buffer": "^3.0.4"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/ast-types-flow": {
      "version": "0.0.8",
      "resolved": "https://registry.npmjs.org/ast-types-flow/-/ast-types-flow-0.0.8.tgz",
      "integrity": "sha512-OH/2E5Fg20h2aPrbe+QL8JZQFko0YZaF+j4mnQ7BGhfavO7OpSLa8a0y9sBwomHdSbkhTS8TQNayBfnW5DwbvQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/async-function": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/async-function/-/async-function-1.0.0.tgz",
      "integrity": "sha512-hsU18Ae8CDTR6Kgu9DYf0EbCr/a5iGL0rytQDobUcdpYOKokk8LEjVphnXkDkgpi0wYVsqrXuP0bZxJaTqdgoA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==",
      "license": "MIT"
    },
    "node_modules/autoprefixer": {
      "version": "10.4.21",
      "resolved": "https://registry.npmjs.org/autoprefixer/-/autoprefixer-10.4.21.tgz",
      "integrity": "sha512-O+A6LWV5LDHSJD3LjHYoNi4VLsj/Whi7k6zG12xTYaU4cQ8oxQGckXNX8cRHK5yOZ/ppVHe0ZBXGzSV9jXdVbQ==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/autoprefixer"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "browserslist": "^4.24.4",
        "caniuse-lite": "^1.0.30001702",
        "fraction.js": "^4.3.7",
        "normalize-range": "^0.1.2",
        "picocolors": "^1.1.1",
        "postcss-value-parser": "^4.2.0"
      },
      "bin": {
        "autoprefixer": "bin/autoprefixer"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      },
      "peerDependencies": {
        "postcss": "^8.1.0"
      }
    },
    "node_modules/available-typed-arrays": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/available-typed-arrays/-/available-typed-arrays-1.0.7.tgz",
      "integrity": "sha512-wvUjBtSGN7+7SjNpq/9M2Tg350UZD3q62IFZLbRAR1bSMlCo1ZaeW+BJ+D090e4hIIZLBcTDWe4Mh4jvUDajzQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "possible-typed-array-names": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/axe-core": {
      "version": "4.10.3",
      "resolved": "https://registry.npmjs.org/axe-core/-/axe-core-4.10.3.tgz",
      "integrity": "sha512-Xm7bpRXnDSX2YE2YFfBk2FnF0ep6tmG7xPh8iHee8MIcrgq762Nkce856dYtJYLkuIoYZvGfTs/PbZhideTcEg==",
      "dev": true,
      "license": "MPL-2.0",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/axios": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/axios/-/axios-1.11.0.tgz",
      "integrity": "sha512-1Lx3WLFQWm3ooKDYZD1eXmoGO9fxYQjrycfHFC8P0sCfQVXyROp0p9PFWBehewBOdCwHc+f/b8I0fMto5eSfwA==",
      "license": "MIT",
      "dependencies": {
        "follow-redirects": "^1.15.6",
        "form-data": "^4.0.4",
        "proxy-from-env": "^1.1.0"
      }
    },
    "node_modules/axobject-query": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/axobject-query/-/axobject-query-4.1.0.tgz",
      "integrity": "sha512-qIj0G9wZbMGNLjLmg1PT6v2mE9AH2zlnADJD/2tC6E00hgmhUOfEB6greHPAfLRSufHqROIUTkw6E+M3lH0PTQ==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fill-range": "^7.1.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/browserslist": {
      "version": "4.25.4",
      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.25.4.tgz",
      "integrity": "sha512-4jYpcjabC606xJ3kw2QwGEZKX0Aw7sgQdZCvIK9dhVSPh76BKo+C+btT1RRofH7B+8iNpEbgGNVWiLki5q93yg==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "caniuse-lite": "^1.0.30001737",
        "electron-to-chromium": "^1.5.211",
        "node-releases": "^2.0.19",
        "update-browserslist-db": "^1.1.3"
      },
      "bin": {
        "browserslist": "cli.js"
      },
      "engines": {
        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
      }
    },
    "node_modules/call-bind": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/call-bind/-/call-bind-1.0.8.tgz",
      "integrity": "sha512-oKlSFMcMwpUg2ednkhQ454wfWiU/ul3CkJe/PEHcTKuiX6RpbehUiFMXu13HalGZxfUwCQzZG747YXBn1im9ww==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.0",
        "es-define-property": "^1.0.0",
        "get-intrinsic": "^1.2.4",
        "set-function-length": "^1.2.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/call-bound": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "get-intrinsic": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/callsites": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
      "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/caniuse-lite": {
      "version": "1.0.30001739",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001739.tgz",
      "integrity": "sha512-y+j60d6ulelrNSwpPyrHdl+9mJnQzHBr08xm48Qno0nSk4h3Qojh+ziv2qE6rXf4k3tadF4o1J/1tAbVm1NtnA==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "CC-BY-4.0"
    },
    "node_modules/chalk": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
      "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/chalk?sponsor=1"
      }
    },
    "node_modules/chownr": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/chownr/-/chownr-3.0.0.tgz",
      "integrity": "sha512-+IxzY9BZOQd/XuYPRmrvEVjF/nqj5kgT4kEq7VofrDoM1MxoRjEWkrCC3EtLi59TVawxTAn+orJwFQcrqEN1+g==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/client-only": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/client-only/-/client-only-0.0.1.tgz",
      "integrity": "sha512-IV3Ou0jSMzZrd3pZ48nLkT9DA7Ag1pnPzaiQhpW7c3RbcqqzvzzVu+L8gfqMp/8IM2MQtSiqaCxrrcfu8I8rMA==",
      "license": "MIT"
    },
    "node_modules/color": {
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/color/-/color-4.2.3.tgz",
      "integrity": "sha512-1rXeuUUiGGrykh+CeBdu5Ie7OJwinCgQY0bc7GCRxy5xVHy+moaqkpL/jqQq0MtQOeYcrqEz4abc5f0KtU7W4A==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "color-convert": "^2.0.1",
        "color-string": "^1.9.0"
      },
      "engines": {
        "node": ">=12.5.0"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/color-string": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/color-string/-/color-string-1.9.1.tgz",
      "integrity": "sha512-shrVawQFojnZv6xM40anx4CkoDP+fZsw/ZerEMsW/pyzsRbElpsL/DBVW7q3ExxwusdNXI3lXpuhEZkzs8p5Eg==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "color-name": "^1.0.0",
        "simple-swizzle": "^0.2.2"
      }
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "license": "MIT",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/cross-spawn": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
      "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/csstype": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.1.3.tgz",
      "integrity": "sha512-M1uQkMl8rQK/szD0LNhtqxIPLpimGm8sOBwU7lLnCpSbTyY3yeU1Vc7l4KT5zT4s/yOxHH5O7tIuuLOCnLADRw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/damerau-levenshtein": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/damerau-levenshtein/-/damerau-levenshtein-1.0.8.tgz",
      "integrity": "sha512-sdQSFB7+llfUcQHUQO3+B8ERRj0Oa4w9POWMI/puGtuf7gFywGmkaLCElnudfTiKZV+NvHqL0ifzdrI8Ro7ESA==",
      "dev": true,
      "license": "BSD-2-Clause"
    },
    "node_modules/data-view-buffer": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/data-view-buffer/-/data-view-buffer-1.0.2.tgz",
      "integrity": "sha512-EmKO5V3OLXh1rtK2wgXRansaK1/mtVdTUEiEI0W8RkvgT05kfxaH29PliLnpLP73yYO6142Q72QNa8Wx/A5CqQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "es-errors": "^1.3.0",
        "is-data-view": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/data-view-byte-length": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/data-view-byte-length/-/data-view-byte-length-1.0.2.tgz",
      "integrity": "sha512-tuhGbE6CfTM9+5ANGf+oQb72Ky/0+s3xKUpHvShfiz2RxMFgFPjsXuRLBVMtvMs15awe45SRb83D6wH4ew6wlQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "es-errors": "^1.3.0",
        "is-data-view": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/inspect-js"
      }
    },
    "node_modules/data-view-byte-offset": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/data-view-byte-offset/-/data-view-byte-offset-1.0.1.tgz",
      "integrity": "sha512-BS8PfmtDGnrgYdOonGZQdLZslWIeCGFP9tpan0hi1Co2Zr2NKADsvGYA8XxuG/4UWgJ6Cjtv+YJnB6MM69QGlQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "is-data-view": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/debug": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.1.tgz",
      "integrity": "sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/deep-is": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz",
      "integrity": "sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/define-data-property": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/define-data-property/-/define-data-property-1.1.4.tgz",
      "integrity": "sha512-rBMvIzlpA8v6E+SJZoo++HAYqsLrkg7MSfIinMPFhmkorw7X+dOXVJQs+QT69zGkzMyfDnIMN2Wid1+NbL3T+A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-define-property": "^1.0.0",
        "es-errors": "^1.3.0",
        "gopd": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/define-properties": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/define-properties/-/define-properties-1.2.1.tgz",
      "integrity": "sha512-8QmQKqEASLd5nx0U1B1okLElbUuuttJ/AnYmRXbbbGDWh6uS208EjD4Xqq/I9wK7u0v6O08XhTWnt5XtEbR6Dg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "define-data-property": "^1.0.1",
        "has-property-descriptors": "^1.0.0",
        "object-keys": "^1.1.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/dequal": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/dequal/-/dequal-2.0.3.tgz",
      "integrity": "sha512-0je+qPKHEMohvfRTCEo3CrPG6cAzAYgmzKyxRiYSSDkS6eGJdyVJm7WaYA5ECaAD9wLB2T4EEeymA5aFVcYXCA==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/detect-libc": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/detect-libc/-/detect-libc-2.0.4.tgz",
      "integrity": "sha512-3UDv+G9CsCKO1WKMGw9fwq/SWJYbI0c5Y7LU1AXYoDdbhE2AHQ6N6Nb34sG8Fj7T5APy8qXDCKuuIHd1BR0tVA==",
      "devOptional": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/doctrine": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/doctrine/-/doctrine-2.1.0.tgz",
      "integrity": "sha512-35mSku4ZXK0vfCuHEDAwt55dg2jNajHZ1odvF+8SSr82EsZY4QmXfuWso8oEd8zRhVObSN18aM0CjSdoBX7zIw==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "esutils": "^2.0.2"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/electron-to-chromium": {
      "version": "1.5.211",
      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.211.tgz",
      "integrity": "sha512-IGBvimJkotaLzFnwIVgW9/UD/AOJ2tByUmeOrtqBfACSbAw5b1G0XpvdaieKyc7ULmbwXVx+4e4Be8pOPBrYkw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/emoji-regex": {
      "version": "9.2.2",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/enhanced-resolve": {
      "version": "5.18.3",
      "resolved": "https://registry.npmjs.org/enhanced-resolve/-/enhanced-resolve-5.18.3.tgz",
      "integrity": "sha512-d4lC8xfavMeBjzGr2vECC3fsGXziXZQyJxD868h2M/mBI3PwAuODxAkLkq5HYuvrPYcUtiLzsTo8U3PgX3Ocww==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "graceful-fs": "^4.2.4",
        "tapable": "^2.2.0"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/es-abstract": {
      "version": "1.24.0",
      "resolved": "https://registry.npmjs.org/es-abstract/-/es-abstract-1.24.0.tgz",
      "integrity": "sha512-WSzPgsdLtTcQwm4CROfS5ju2Wa1QQcVeT37jFjYzdFz1r9ahadC8B8/a4qxJxM+09F18iumCdRmlr96ZYkQvEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "array-buffer-byte-length": "^1.0.2",
        "arraybuffer.prototype.slice": "^1.0.4",
        "available-typed-arrays": "^1.0.7",
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.4",
        "data-view-buffer": "^1.0.2",
        "data-view-byte-length": "^1.0.2",
        "data-view-byte-offset": "^1.0.1",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "es-set-tostringtag": "^2.1.0",
        "es-to-primitive": "^1.3.0",
        "function.prototype.name": "^1.1.8",
        "get-intrinsic": "^1.3.0",
        "get-proto": "^1.0.1",
        "get-symbol-description": "^1.1.0",
        "globalthis": "^1.0.4",
        "gopd": "^1.2.0",
        "has-property-descriptors": "^1.0.2",
        "has-proto": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "internal-slot": "^1.1.0",
        "is-array-buffer": "^3.0.5",
        "is-callable": "^1.2.7",
        "is-data-view": "^1.0.2",
        "is-negative-zero": "^2.0.3",
        "is-regex": "^1.2.1",
        "is-set": "^2.0.3",
        "is-shared-array-buffer": "^1.0.4",
        "is-string": "^1.1.1",
        "is-typed-array": "^1.1.15",
        "is-weakref": "^1.1.1",
        "math-intrinsics": "^1.1.0",
        "object-inspect": "^1.13.4",
        "object-keys": "^1.1.1",
        "object.assign": "^4.1.7",
        "own-keys": "^1.0.1",
        "regexp.prototype.flags": "^1.5.4",
        "safe-array-concat": "^1.1.3",
        "safe-push-apply": "^1.0.0",
        "safe-regex-test": "^1.1.0",
        "set-proto": "^1.0.0",
        "stop-iteration-iterator": "^1.1.0",
        "string.prototype.trim": "^1.2.10",
        "string.prototype.trimend": "^1.0.9",
        "string.prototype.trimstart": "^1.0.8",
        "typed-array-buffer": "^1.0.3",
        "typed-array-byte-length": "^1.0.3",
        "typed-array-byte-offset": "^1.0.4",
        "typed-array-length": "^1.0.7",
        "unbox-primitive": "^1.1.0",
        "which-typed-array": "^1.1.19"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-iterator-helpers": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/es-iterator-helpers/-/es-iterator-helpers-1.2.1.tgz",
      "integrity": "sha512-uDn+FE1yrDzyC0pCo961B2IHbdM8y/ACZsKD4dG6WqrjV53BADjwa7D+1aom2rsNVfLyDgU/eigvlJGJ08OQ4w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.3",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.6",
        "es-errors": "^1.3.0",
        "es-set-tostringtag": "^2.0.3",
        "function-bind": "^1.1.2",
        "get-intrinsic": "^1.2.6",
        "globalthis": "^1.0.4",
        "gopd": "^1.2.0",
        "has-property-descriptors": "^1.0.2",
        "has-proto": "^1.2.0",
        "has-symbols": "^1.1.0",
        "internal-slot": "^1.1.0",
        "iterator.prototype": "^1.1.4",
        "safe-array-concat": "^1.1.3"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-set-tostringtag": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz",
      "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-shim-unscopables": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/es-shim-unscopables/-/es-shim-unscopables-1.1.0.tgz",
      "integrity": "sha512-d9T8ucsEhh8Bi1woXCf+TIKDIROLG5WCkxg8geBCbvk22kzwC5G2OnXVMO6FUsvQlgUUXQ2itephWDLqDzbeCw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-to-primitive": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-to-primitive/-/es-to-primitive-1.3.0.tgz",
      "integrity": "sha512-w+5mJ3GuFL+NjVtJlvydShqE1eN3h3PbI7/5LAsYJP/2qtuMXjfL2LpHSRqo4b4eSF5K/DH1JXKUAHSB2UW50g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-callable": "^1.2.7",
        "is-date-object": "^1.0.5",
        "is-symbol": "^1.0.4"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/escape-string-regexp": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
      "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/eslint": {
      "version": "9.34.0",
      "resolved": "https://registry.npmjs.org/eslint/-/eslint-9.34.0.tgz",
      "integrity": "sha512-RNCHRX5EwdrESy3Jc9o8ie8Bog+PeYvvSR8sDGoZxNFTvZ4dlxUB3WzQ3bQMztFrSRODGrLLj8g6OFuGY/aiQg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.2.0",
        "@eslint-community/regexpp": "^4.12.1",
        "@eslint/config-array": "^0.21.0",
        "@eslint/config-helpers": "^0.3.1",
        "@eslint/core": "^0.15.2",
        "@eslint/eslintrc": "^3.3.1",
        "@eslint/js": "9.34.0",
        "@eslint/plugin-kit": "^0.3.5",
        "@humanfs/node": "^0.16.6",
        "@humanwhocodes/module-importer": "^1.0.1",
        "@humanwhocodes/retry": "^0.4.2",
        "@types/estree": "^1.0.6",
        "@types/json-schema": "^7.0.15",
        "ajv": "^6.12.4",
        "chalk": "^4.0.0",
        "cross-spawn": "^7.0.6",
        "debug": "^4.3.2",
        "escape-string-regexp": "^4.0.0",
        "eslint-scope": "^8.4.0",
        "eslint-visitor-keys": "^4.2.1",
        "espree": "^10.4.0",
        "esquery": "^1.5.0",
        "esutils": "^2.0.2",
        "fast-deep-equal": "^3.1.3",
        "file-entry-cache": "^8.0.0",
        "find-up": "^5.0.0",
        "glob-parent": "^6.0.2",
        "ignore": "^5.2.0",
        "imurmurhash": "^0.1.4",
        "is-glob": "^4.0.0",
        "json-stable-stringify-without-jsonify": "^1.0.1",
        "lodash.merge": "^4.6.2",
        "minimatch": "^3.1.2",
        "natural-compare": "^1.4.0",
        "optionator": "^0.9.3"
      },
      "bin": {
        "eslint": "bin/eslint.js"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://eslint.org/donate"
      },
      "peerDependencies": {
        "jiti": "*"
      },
      "peerDependenciesMeta": {
        "jiti": {
          "optional": true
        }
      }
    },
    "node_modules/eslint-config-next": {
      "version": "15.5.2",
      "resolved": "https://registry.npmjs.org/eslint-config-next/-/eslint-config-next-15.5.2.tgz",
      "integrity": "sha512-3hPZghsLupMxxZ2ggjIIrat/bPniM2yRpsVPVM40rp8ZMzKWOJp2CGWn7+EzoV2ddkUr5fxNfHpF+wU1hGt/3g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@next/eslint-plugin-next": "15.5.2",
        "@rushstack/eslint-patch": "^1.10.3",
        "@typescript-eslint/eslint-plugin": "^5.4.2 || ^6.0.0 || ^7.0.0 || ^8.0.0",
        "@typescript-eslint/parser": "^5.4.2 || ^6.0.0 || ^7.0.0 || ^8.0.0",
        "eslint-import-resolver-node": "^0.3.6",
        "eslint-import-resolver-typescript": "^3.5.2",
        "eslint-plugin-import": "^2.31.0",
        "eslint-plugin-jsx-a11y": "^6.10.0",
        "eslint-plugin-react": "^7.37.0",
        "eslint-plugin-react-hooks": "^5.0.0"
      },
      "peerDependencies": {
        "eslint": "^7.23.0 || ^8.0.0 || ^9.0.0",
        "typescript": ">=3.3.1"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/eslint-import-resolver-node": {
      "version": "0.3.9",
      "resolved": "https://registry.npmjs.org/eslint-import-resolver-node/-/eslint-import-resolver-node-0.3.9.tgz",
      "integrity": "sha512-WFj2isz22JahUv+B788TlO3N6zL3nNJGU8CcZbPZvVEkBPaJdCV4vy5wyghty5ROFbCRnm132v8BScu5/1BQ8g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "debug": "^3.2.7",
        "is-core-module": "^2.13.0",
        "resolve": "^1.22.4"
      }
    },
    "node_modules/eslint-import-resolver-node/node_modules/debug": {
      "version": "3.2.7",
      "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.7.tgz",
      "integrity": "sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.1"
      }
    },
    "node_modules/eslint-import-resolver-typescript": {
      "version": "3.10.1",
      "resolved": "https://registry.npmjs.org/eslint-import-resolver-typescript/-/eslint-import-resolver-typescript-3.10.1.tgz",
      "integrity": "sha512-A1rHYb06zjMGAxdLSkN2fXPBwuSaQ0iO5M/hdyS0Ajj1VBaRp0sPD3dn1FhME3c/JluGFbwSxyCfqdSbtQLAHQ==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "@nolyfill/is-core-module": "1.0.39",
        "debug": "^4.4.0",
        "get-tsconfig": "^4.10.0",
        "is-bun-module": "^2.0.0",
        "stable-hash": "^0.0.5",
        "tinyglobby": "^0.2.13",
        "unrs-resolver": "^1.6.2"
      },
      "engines": {
        "node": "^14.18.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint-import-resolver-typescript"
      },
      "peerDependencies": {
        "eslint": "*",
        "eslint-plugin-import": "*",
        "eslint-plugin-import-x": "*"
      },
      "peerDependenciesMeta": {
        "eslint-plugin-import": {
          "optional": true
        },
        "eslint-plugin-import-x": {
          "optional": true
        }
      }
    },
    "node_modules/eslint-module-utils": {
      "version": "2.12.1",
      "resolved": "https://registry.npmjs.org/eslint-module-utils/-/eslint-module-utils-2.12.1.tgz",
      "integrity": "sha512-L8jSWTze7K2mTg0vos/RuLRS5soomksDPoJLXIslC7c8Wmut3bx7CPpJijDcBZtxQ5lrbUdM+s0OlNbz0DCDNw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "debug": "^3.2.7"
      },
      "engines": {
        "node": ">=4"
      },
      "peerDependenciesMeta": {
        "eslint": {
          "optional": true
        }
      }
    },
    "node_modules/eslint-module-utils/node_modules/debug": {
      "version": "3.2.7",
      "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.7.tgz",
      "integrity": "sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.1"
      }
    },
    "node_modules/eslint-plugin-import": {
      "version": "2.32.0",
      "resolved": "https://registry.npmjs.org/eslint-plugin-import/-/eslint-plugin-import-2.32.0.tgz",
      "integrity": "sha512-whOE1HFo/qJDyX4SnXzP4N6zOWn79WhnCUY/iDR0mPfQZO8wcYE4JClzI2oZrhBnnMUCBCHZhO6VQyoBU95mZA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@rtsao/scc": "^1.1.0",
        "array-includes": "^3.1.9",
        "array.prototype.findlastindex": "^1.2.6",
        "array.prototype.flat": "^1.3.3",
        "array.prototype.flatmap": "^1.3.3",
        "debug": "^3.2.7",
        "doctrine": "^2.1.0",
        "eslint-import-resolver-node": "^0.3.9",
        "eslint-module-utils": "^2.12.1",
        "hasown": "^2.0.2",
        "is-core-module": "^2.16.1",
        "is-glob": "^4.0.3",
        "minimatch": "^3.1.2",
        "object.fromentries": "^2.0.8",
        "object.groupby": "^1.0.3",
        "object.values": "^1.2.1",
        "semver": "^6.3.1",
        "string.prototype.trimend": "^1.0.9",
        "tsconfig-paths": "^3.15.0"
      },
      "engines": {
        "node": ">=4"
      },
      "peerDependencies": {
        "eslint": "^2 || ^3 || ^4 || ^5 || ^6 || ^7.2.0 || ^8 || ^9"
      }
    },
    "node_modules/eslint-plugin-import/node_modules/debug": {
      "version": "3.2.7",
      "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.7.tgz",
      "integrity": "sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.1"
      }
    },
    "node_modules/eslint-plugin-import/node_modules/semver": {
      "version": "6.3.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/eslint-plugin-jsx-a11y": {
      "version": "6.10.2",
      "resolved": "https://registry.npmjs.org/eslint-plugin-jsx-a11y/-/eslint-plugin-jsx-a11y-6.10.2.tgz",
      "integrity": "sha512-scB3nz4WmG75pV8+3eRUQOHZlNSUhFNq37xnpgRkCCELU3XMvXAxLk1eqWWyE22Ki4Q01Fnsw9BA3cJHDPgn2Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "aria-query": "^5.3.2",
        "array-includes": "^3.1.8",
        "array.prototype.flatmap": "^1.3.2",
        "ast-types-flow": "^0.0.8",
        "axe-core": "^4.10.0",
        "axobject-query": "^4.1.0",
        "damerau-levenshtein": "^1.0.8",
        "emoji-regex": "^9.2.2",
        "hasown": "^2.0.2",
        "jsx-ast-utils": "^3.3.5",
        "language-tags": "^1.0.9",
        "minimatch": "^3.1.2",
        "object.fromentries": "^2.0.8",
        "safe-regex-test": "^1.0.3",
        "string.prototype.includes": "^2.0.1"
      },
      "engines": {
        "node": ">=4.0"
      },
      "peerDependencies": {
        "eslint": "^3 || ^4 || ^5 || ^6 || ^7 || ^8 || ^9"
      }
    },
    "node_modules/eslint-plugin-react": {
      "version": "7.37.5",
      "resolved": "https://registry.npmjs.org/eslint-plugin-react/-/eslint-plugin-react-7.37.5.tgz",
      "integrity": "sha512-Qteup0SqU15kdocexFNAJMvCJEfa2xUKNV4CC1xsVMrIIqEy3SQ/rqyxCWNzfrd3/ldy6HMlD2e0JDVpDg2qIA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "array-includes": "^3.1.8",
        "array.prototype.findlast": "^1.2.5",
        "array.prototype.flatmap": "^1.3.3",
        "array.prototype.tosorted": "^1.1.4",
        "doctrine": "^2.1.0",
        "es-iterator-helpers": "^1.2.1",
        "estraverse": "^5.3.0",
        "hasown": "^2.0.2",
        "jsx-ast-utils": "^2.4.1 || ^3.0.0",
        "minimatch": "^3.1.2",
        "object.entries": "^1.1.9",
        "object.fromentries": "^2.0.8",
        "object.values": "^1.2.1",
        "prop-types": "^15.8.1",
        "resolve": "^2.0.0-next.5",
        "semver": "^6.3.1",
        "string.prototype.matchall": "^4.0.12",
        "string.prototype.repeat": "^1.0.0"
      },
      "engines": {
        "node": ">=4"
      },
      "peerDependencies": {
        "eslint": "^3 || ^4 || ^5 || ^6 || ^7 || ^8 || ^9.7"
      }
    },
    "node_modules/eslint-plugin-react-hooks": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/eslint-plugin-react-hooks/-/eslint-plugin-react-hooks-5.2.0.tgz",
      "integrity": "sha512-+f15FfK64YQwZdJNELETdn5ibXEUQmW1DZL6KXhNnc2heoy/sg9VJJeT7n8TlMWouzWqSWavFkIhHyIbIAEapg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "eslint": "^3.0.0 || ^4.0.0 || ^5.0.0 || ^6.0.0 || ^7.0.0 || ^8.0.0-0 || ^9.0.0"
      }
    },
    "node_modules/eslint-plugin-react/node_modules/resolve": {
      "version": "2.0.0-next.5",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-2.0.0-next.5.tgz",
      "integrity": "sha512-U7WjGVG9sH8tvjW5SmGbQuui75FiyjAX72HX15DwBBwF9dNiQZRQAg9nnPhYy+TUnE0+VcrttuvNI8oSxZcocA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-core-module": "^2.13.0",
        "path-parse": "^1.0.7",
        "supports-preserve-symlinks-flag": "^1.0.0"
      },
      "bin": {
        "resolve": "bin/resolve"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/eslint-plugin-react/node_modules/semver": {
      "version": "6.3.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/eslint-scope": {
      "version": "8.4.0",
      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-8.4.0.tgz",
      "integrity": "sha512-sNXOfKCn74rt8RICKMvJS7XKV/Xk9kA7DyJr8mJik3S7Cwgy3qlkkmyS2uQB3jiJg6VNdZd/pDBJu0nvG2NlTg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "esrecurse": "^4.3.0",
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint-visitor-keys": {
      "version": "4.2.1",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-4.2.1.tgz",
      "integrity": "sha512-Uhdk5sfqcee/9H/rCOJikYz67o0a2Tw2hGRPOG2Y1R2dg7brRe1uG0yaNQDHu+TO/uQPF/5eCapvYSmHUjt7JQ==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/espree": {
      "version": "10.4.0",
      "resolved": "https://registry.npmjs.org/espree/-/espree-10.4.0.tgz",
      "integrity": "sha512-j6PAQ2uUr79PZhBjP5C5fhl8e39FmRnOjsD5lGnWrFU8i2G776tBK7+nP8KuQUTTyAZUwfQqXAgrVH5MbH9CYQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "acorn": "^8.15.0",
        "acorn-jsx": "^5.3.2",
        "eslint-visitor-keys": "^4.2.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/esquery": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.6.0.tgz",
      "integrity": "sha512-ca9pw9fomFcKPvFLXhBKUK90ZvGibiGOvRJNbjljY7s7uq/5YO4BOzcYtJqExdx99rF6aAcnRxHmcUHcz6sQsg==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "estraverse": "^5.1.0"
      },
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/esrecurse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
      "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/estraverse": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
      "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/fast-deep-equal": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-glob": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.3.1.tgz",
      "integrity": "sha512-kNFPyjhh5cKjrUltxs+wFx+ZkbRaxxmZ+X0ZU31SOsxCEtP9VPgtq2teZw1DebupL5GmDaNQ6yKMMVcM41iqDg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "^2.0.2",
        "@nodelib/fs.walk": "^1.2.3",
        "glob-parent": "^5.1.2",
        "merge2": "^1.3.0",
        "micromatch": "^4.0.4"
      },
      "engines": {
        "node": ">=8.6.0"
      }
    },
    "node_modules/fast-glob/node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/fast-json-stable-stringify": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-levenshtein": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
      "integrity": "sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fastq": {
      "version": "1.19.1",
      "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.19.1.tgz",
      "integrity": "sha512-GwLTyxkCXjXbxqIhTsMI2Nui8huMPtnxg7krajPJAjnEG/iiOS7i+zCtWGZR9G0NBKbXKh6X9m9UIsYX/N6vvQ==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "reusify": "^1.0.4"
      }
    },
    "node_modules/file-entry-cache": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-8.0.0.tgz",
      "integrity": "sha512-XXTUwCvisa5oacNGRP9SfNtYBNAMi+RPwBFmblZEF7N7swHYQS6/Zfk7SRwx4D5j3CH211YNRco1DEMNVfZCnQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "flat-cache": "^4.0.0"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/find-up": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
      "integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "locate-path": "^6.0.0",
        "path-exists": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/flat-cache": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-4.0.1.tgz",
      "integrity": "sha512-f7ccFPK3SXFHpx15UIGyRJ/FJQctuKZ0zVuN3frBo4HnK3cay9VEW0R6yPYFHC0AgqhukPzKjq22t5DmAyqGyw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "flatted": "^3.2.9",
        "keyv": "^4.5.4"
      },
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/flatted": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.3.3.tgz",
      "integrity": "sha512-GX+ysw4PBCz0PzosHDepZGANEuFCMLrnRTiEy9McGjmkCQYwRq4A/X786G/fjM/+OjsWSU1ZrY5qyARZmO/uwg==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/follow-redirects": {
      "version": "1.15.11",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.15.11.tgz",
      "integrity": "sha512-deG2P0JfjrTxl50XGCDyfI97ZGVCxIpfKYmfyrQ54n5FO/0gfIES8C/Psl6kWVDolizcaaxZJnTS0QSMxvnsBQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/RubenVerborgh"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=4.0"
      },
      "peerDependenciesMeta": {
        "debug": {
          "optional": true
        }
      }
    },
    "node_modules/for-each": {
      "version": "0.3.5",
      "resolved": "https://registry.npmjs.org/for-each/-/for-each-0.3.5.tgz",
      "integrity": "sha512-dKx12eRCVIzqCxFGplyFKJMPvLEWgmNtUrpTiJIR5u97zEhRG8ySrtboPHZXx7daLxQVrl643cTzbab2tkQjxg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-callable": "^1.2.7"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/form-data": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.4.tgz",
      "integrity": "sha512-KrGhL9Q4zjj0kiUt5OO4Mr/A/jlI2jDYs5eHBpYHPcBEVSiipAvn2Ko2HnPe20rmcuuvMHNdZFp+4IlGTMF0Ow==",
      "license": "MIT",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "es-set-tostringtag": "^2.1.0",
        "hasown": "^2.0.2",
        "mime-types": "^2.1.12"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/fraction.js": {
      "version": "4.3.7",
      "resolved": "https://registry.npmjs.org/fraction.js/-/fraction.js-4.3.7.tgz",
      "integrity": "sha512-ZsDfxO51wGAXREY55a7la9LScWpwv9RxIrYABrlvOFBlH/ShPnrtsXeuUIfXKKOVicNxQ+o8JTbJvjS4M89yew==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "*"
      },
      "funding": {
        "type": "patreon",
        "url": "https://github.com/sponsors/rawify"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/function.prototype.name": {
      "version": "1.1.8",
      "resolved": "https://registry.npmjs.org/function.prototype.name/-/function.prototype.name-1.1.8.tgz",
      "integrity": "sha512-e5iwyodOHhbMr/yNrc7fDYG4qlbIvI5gajyzPnb5TCwyhjApznQh1BMFou9b30SevY43gCJKXycoCBjMbsuW0Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.3",
        "define-properties": "^1.2.1",
        "functions-have-names": "^1.2.3",
        "hasown": "^2.0.2",
        "is-callable": "^1.2.7"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/functions-have-names": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/functions-have-names/-/functions-have-names-1.2.3.tgz",
      "integrity": "sha512-xckBUXyTIqT97tq2x2AMb+g163b5JFysYk0x4qxNFwbfQkmNZoiRHb6sPzI9/QV33WeuvVYBUIiD4NzNIyqaRQ==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/get-symbol-description": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/get-symbol-description/-/get-symbol-description-1.1.0.tgz",
      "integrity": "sha512-w9UMqWwJxHNOvoNzSJ2oPF5wvYcvP7jUvYzhp67yEhTi17ZDBBC1z9pTdGuzjD+EFIqLSYRweZjqfiPzQ06Ebg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-tsconfig": {
      "version": "4.10.1",
      "resolved": "https://registry.npmjs.org/get-tsconfig/-/get-tsconfig-4.10.1.tgz",
      "integrity": "sha512-auHyJ4AgMz7vgS8Hp3N6HXSmlMdUyhSUrfBF16w153rxtLIEOE+HGqaBppczZvnHLqQJfiHotCYpNhl0lUROFQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "resolve-pkg-maps": "^1.0.0"
      },
      "funding": {
        "url": "https://github.com/privatenumber/get-tsconfig?sponsor=1"
      }
    },
    "node_modules/glob-parent": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz",
      "integrity": "sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.3"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/globals": {
      "version": "14.0.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-14.0.0.tgz",
      "integrity": "sha512-oahGvuMGQlPw/ivIYBjVSrWAfWLBeku5tpPE2fOPLi+WHffIWbuh2tCjhyQhTBPMf5E9jDEH4FOmTYgYwbKwtQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/globalthis": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/globalthis/-/globalthis-1.0.4.tgz",
      "integrity": "sha512-DpLKbNU4WylpxJykQujfCcwYWiV/Jhm50Goo0wrVILAv5jOr9d+H+UR3PhSCD2rCCEIg0uc+G+muBTwD54JhDQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "define-properties": "^1.2.1",
        "gopd": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/graceful-fs": {
      "version": "4.2.11",
      "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.11.tgz",
      "integrity": "sha512-RbJ5/jmFcNNCcDV5o9eTnBLJ/HszWV0P73bc+Ff4nS/rJj+YaS6IGyiOL0VoBYX+l1Wrl3k63h/KrH+nhJ0XvQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/graphemer": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/graphemer/-/graphemer-1.4.0.tgz",
      "integrity": "sha512-EtKwoO6kxCL9WO5xipiHTZlSzBm7WLT627TqC/uVRd0HKmq8NXyebnNYxDoBi7wt8eTWrUrKXCOVaFq9x1kgag==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/has-bigints": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-bigints/-/has-bigints-1.1.0.tgz",
      "integrity": "sha512-R3pbpkcIqv2Pm3dUwgjclDRVmWpTJW2DcMzcIhEXEx1oh/CEMObMm3KLmRJOdvhM7o4uQBnwr8pzRK2sJWIqfg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/has-property-descriptors": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-property-descriptors/-/has-property-descriptors-1.0.2.tgz",
      "integrity": "sha512-55JNKuIW+vq4Ke1BjOTjM2YctQIvCT7GFzHwmfZPGo5wnrgkid0YQtnAleFSqumZm4az3n2BS+erby5ipJdgrg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-define-property": "^1.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-proto": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/has-proto/-/has-proto-1.2.0.tgz",
      "integrity": "sha512-KIL7eQPfHQRC8+XluaIw7BHUwwqL19bQn4hzNgdr+1wXoU0KKj6rufu47lhY7KbJR2C6T6+PfyN0Ea7wkSS+qQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-tostringtag": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz",
      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
      "license": "MIT",
      "dependencies": {
        "has-symbols": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/ignore": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz",
      "integrity": "sha512-hsBTNUqQTDwkWtcdYI2i06Y/nUBEsNEDJKjWdigLvegy8kDuJAS8uRlpkkcQpyEXL0Z/pjDy5HBmMjRCJ2gq+g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/import-fresh": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.1.tgz",
      "integrity": "sha512-TR3KfrTZTYLPB6jUjfx6MF9WcWrHL9su5TObK4ZkYgBdWKPOFoSoQIdEuTuR82pmtxH2spWG9h6etwfr1pLBqQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "parent-module": "^1.0.0",
        "resolve-from": "^4.0.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/imurmurhash": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
      "integrity": "sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.8.19"
      }
    },
    "node_modules/internal-slot": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/internal-slot/-/internal-slot-1.1.0.tgz",
      "integrity": "sha512-4gd7VpWNQNB4UKKCFFVcp1AVv+FMOgs9NKzjHKusc8jTMhd5eL1NqQqOpE0KzMds804/yHlglp3uxgluOqAPLw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "hasown": "^2.0.2",
        "side-channel": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/is-array-buffer": {
      "version": "3.0.5",
      "resolved": "https://registry.npmjs.org/is-array-buffer/-/is-array-buffer-3.0.5.tgz",
      "integrity": "sha512-DDfANUiiG2wC1qawP66qlTugJeL5HyzMpfr8lLK+jMQirGzNod0B12cFB/9q838Ru27sBwfw78/rdoU7RERz6A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.3",
        "get-intrinsic": "^1.2.6"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-arrayish": {
      "version": "0.3.2",
      "resolved": "https://registry.npmjs.org/is-arrayish/-/is-arrayish-0.3.2.tgz",
      "integrity": "sha512-eVRqCvVlZbuw3GrM63ovNSNAeA1K16kaR/LRY/92w0zxQ5/1YzwblUX652i4Xs9RwAGjW9d9y6X88t8OaAJfWQ==",
      "license": "MIT",
      "optional": true
    },
    "node_modules/is-async-function": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-async-function/-/is-async-function-2.1.1.tgz",
      "integrity": "sha512-9dgM/cZBnNvjzaMYHVoxxfPj2QXt22Ev7SuuPrs+xav0ukGB0S6d4ydZdEiM48kLx5kDV+QBPrpVnFyefL8kkQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "async-function": "^1.0.0",
        "call-bound": "^1.0.3",
        "get-proto": "^1.0.1",
        "has-tostringtag": "^1.0.2",
        "safe-regex-test": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-bigint": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/is-bigint/-/is-bigint-1.1.0.tgz",
      "integrity": "sha512-n4ZT37wG78iz03xPRKJrHTdZbe3IicyucEtdRsV5yglwc3GyUfbAfpSeD0FJ41NbUNSt5wbhqfp1fS+BgnvDFQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-bigints": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-boolean-object": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/is-boolean-object/-/is-boolean-object-1.2.2.tgz",
      "integrity": "sha512-wa56o2/ElJMYqjCjGkXri7it5FbebW5usLw/nPmCMs5DeZ7eziSYZhSmPRn0txqeW4LnAmQQU7FgqLpsEFKM4A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "has-tostringtag": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-bun-module": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-bun-module/-/is-bun-module-2.0.0.tgz",
      "integrity": "sha512-gNCGbnnnnFAUGKeZ9PdbyeGYJqewpmc2aKHUEMO5nQPWU9lOmv7jcmQIv+qHD8fXW6W7qfuCwX4rY9LNRjXrkQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "semver": "^7.7.1"
      }
    },
    "node_modules/is-callable": {
      "version": "1.2.7",
      "resolved": "https://registry.npmjs.org/is-callable/-/is-callable-1.2.7.tgz",
      "integrity": "sha512-1BC0BVFhS/p0qtw6enp8e+8OD0UrK0oFLztSjNzhcKA3WDuJxxAPXzPuPtKkjEY9UUoEWlX/8fgKeu2S8i9JTA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-core-module": {
      "version": "2.16.1",
      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.16.1.tgz",
      "integrity": "sha512-UfoeMA6fIJ8wTYFEUjelnaGI67v6+N7qXJEvQuIGa99l4xsCruSYOVSQ0uPANn4dAzm8lkYPaKLrrijLq7x23w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-data-view": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/is-data-view/-/is-data-view-1.0.2.tgz",
      "integrity": "sha512-RKtWF8pGmS87i2D6gqQu/l7EYRlVdfzemCJN/P3UOs//x1QE7mfhvzHIApBTRf7axvT6DMGwSwBXYCT0nfB9xw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "get-intrinsic": "^1.2.6",
        "is-typed-array": "^1.1.13"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-date-object": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/is-date-object/-/is-date-object-1.1.0.tgz",
      "integrity": "sha512-PwwhEakHVKTdRNVOw+/Gyh0+MzlCl4R6qKvkhuvLtPMggI1WAHt9sOwZxQLSGpUaDnrdyDsomoRgNnCfKNSXXg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "has-tostringtag": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-finalizationregistry": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/is-finalizationregistry/-/is-finalizationregistry-1.1.1.tgz",
      "integrity": "sha512-1pC6N8qWJbWoPtEjgcL2xyhQOP491EQjeUo3qTKcmV8YSDDJrOepfG8pcC7h/QgnQHYSv0mJ3Z/ZWxmatVrysg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-generator-function": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/is-generator-function/-/is-generator-function-1.1.0.tgz",
      "integrity": "sha512-nPUB5km40q9e8UfN/Zc24eLlzdSf9OfKByBw9CIdw4H1giPMeA0OIJvbchsCu4npfI2QcMVBsGEBHKZ7wLTWmQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "get-proto": "^1.0.0",
        "has-tostringtag": "^1.0.2",
        "safe-regex-test": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-map": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/is-map/-/is-map-2.0.3.tgz",
      "integrity": "sha512-1Qed0/Hr2m+YqxnM09CjA2d/i6YZNfF6R2oRAOj36eUdS6qIV/huPJNSEpKbupewFs+ZsJlxsjjPbc0/afW6Lw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-negative-zero": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/is-negative-zero/-/is-negative-zero-2.0.3.tgz",
      "integrity": "sha512-5KoIu2Ngpyek75jXodFvnafB6DJgr3u8uuK0LEZJjrU19DrMD3EVERaR8sjz8CCGgpZvxPl9SuE1GMVPFHx1mw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/is-number-object": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/is-number-object/-/is-number-object-1.1.1.tgz",
      "integrity": "sha512-lZhclumE1G6VYD8VHe35wFaIif+CTy5SJIi5+3y4psDgWu4wPDoBhF8NxUOinEc7pHgiTsT6MaBb92rKhhD+Xw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "has-tostringtag": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-regex": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/is-regex/-/is-regex-1.2.1.tgz",
      "integrity": "sha512-MjYsKHO5O7mCsmRGxWcLWheFqN9DJ/2TmngvjKXihe6efViPqc274+Fx/4fYj/r03+ESvBdTXK0V6tA3rgez1g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "gopd": "^1.2.0",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-set": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/is-set/-/is-set-2.0.3.tgz",
      "integrity": "sha512-iPAjerrse27/ygGLxw+EBR9agv9Y6uLeYVJMu+QNCoouJ1/1ri0mGrcWpfCqFZuzzx3WjtwxG098X+n4OuRkPg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-shared-array-buffer": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/is-shared-array-buffer/-/is-shared-array-buffer-1.0.4.tgz",
      "integrity": "sha512-ISWac8drv4ZGfwKl5slpHG9OwPNty4jOWPRIhBpxOoD+hqITiwuipOQ2bNthAzwA3B4fIjO4Nln74N0S9byq8A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-string": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/is-string/-/is-string-1.1.1.tgz",
      "integrity": "sha512-BtEeSsoaQjlSPBemMQIrY1MY0uM6vnS1g5fmufYOtnxLGUZM2178PKbhsk7Ffv58IX+ZtcvoGwccYsh0PglkAA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "has-tostringtag": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-symbol": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/is-symbol/-/is-symbol-1.1.1.tgz",
      "integrity": "sha512-9gGx6GTtCQM73BgmHQXfDmLtfjjTUDSyoxTCbp5WtoixAhfgsDirWIcVQ/IHpvI5Vgd5i/J5F7B9cN/WlVbC/w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "has-symbols": "^1.1.0",
        "safe-regex-test": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-typed-array": {
      "version": "1.1.15",
      "resolved": "https://registry.npmjs.org/is-typed-array/-/is-typed-array-1.1.15.tgz",
      "integrity": "sha512-p3EcsicXjit7SaskXHs1hA91QxgTw46Fv6EFKKGS5DRFLD8yKnohjF3hxoju94b/OcMZoQukzpPpBE9uLVKzgQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "which-typed-array": "^1.1.16"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-weakmap": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/is-weakmap/-/is-weakmap-2.0.2.tgz",
      "integrity": "sha512-K5pXYOm9wqY1RgjpL3YTkF39tni1XajUIkawTLUo9EZEVUFga5gSQJF8nNS7ZwJQ02y+1YCNYcMh+HIf1ZqE+w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-weakref": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/is-weakref/-/is-weakref-1.1.1.tgz",
      "integrity": "sha512-6i9mGWSlqzNMEqpCp93KwRS1uUOodk2OJ6b+sq7ZPDSy2WuI5NFIxp/254TytR8ftefexkWn5xNiHUNpPOfSew==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-weakset": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/is-weakset/-/is-weakset-2.0.4.tgz",
      "integrity": "sha512-mfcwb6IzQyOKTs84CQMrOwW4gQcaTOAWJ0zzJCl2WSPDrWk/OzDaImWFH3djXhb24g4eudZfLRozAvPGw4d9hQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "get-intrinsic": "^1.2.6"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/isarray": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/isarray/-/isarray-2.0.5.tgz",
      "integrity": "sha512-xHjhDr3cNBK0BzdUJSPXZntQUx/mwMS5Rw4A7lPJ90XGAO6ISP/ePDNuo0vhqOZU+UD5JoodwCAAoZQd3FeAKw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/iterator.prototype": {
      "version": "1.1.5",
      "resolved": "https://registry.npmjs.org/iterator.prototype/-/iterator.prototype-1.1.5.tgz",
      "integrity": "sha512-H0dkQoCa3b2VEeKQBOxFph+JAbcrQdE7KC0UkqwpLmv2EC4P41QXP+rqo9wYodACiG5/WM5s9oDApTU8utwj9g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "define-data-property": "^1.1.4",
        "es-object-atoms": "^1.0.0",
        "get-intrinsic": "^1.2.6",
        "get-proto": "^1.0.0",
        "has-symbols": "^1.1.0",
        "set-function-name": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/jiti": {
      "version": "2.5.1",
      "resolved": "https://registry.npmjs.org/jiti/-/jiti-2.5.1.tgz",
      "integrity": "sha512-twQoecYPiVA5K/h6SxtORw/Bs3ar+mLUtoPSc7iMXzQzK8d7eJ/R09wmTwAjiamETn1cXYPGfNnu7DMoHgu12w==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "jiti": "lib/jiti-cli.mjs"
      }
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/js-yaml": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz",
      "integrity": "sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "argparse": "^2.0.1"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/json-buffer": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/json-buffer/-/json-buffer-3.0.1.tgz",
      "integrity": "sha512-4bV5BfR2mqfQTJm+V5tPPdf+ZpuhiIvTuAB5g8kcrXOZpTT/QwwVRWBywX1ozr6lEuPdbHxwaJlm9G6mI2sfSQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json-schema-traverse": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json-stable-stringify-without-jsonify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
      "integrity": "sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json5": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/json5/-/json5-1.0.2.tgz",
      "integrity": "sha512-g1MWMLBiz8FKi1e4w0UyVL3w+iJceWAFBAaBnnGKOpNa5f8TLktkbre1+s6oICydWAm+HRUGTmI+//xv2hvXYA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "minimist": "^1.2.0"
      },
      "bin": {
        "json5": "lib/cli.js"
      }
    },
    "node_modules/jsx-ast-utils": {
      "version": "3.3.5",
      "resolved": "https://registry.npmjs.org/jsx-ast-utils/-/jsx-ast-utils-3.3.5.tgz",
      "integrity": "sha512-ZZow9HBI5O6EPgSJLUb8n2NKgmVWTwCvHGwFuJlMjvLFqlGG6pjirPhtdsseaLZjSibD8eegzmYpUZwoIlj2cQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "array-includes": "^3.1.6",
        "array.prototype.flat": "^1.3.1",
        "object.assign": "^4.1.4",
        "object.values": "^1.1.6"
      },
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/keyv": {
      "version": "4.5.4",
      "resolved": "https://registry.npmjs.org/keyv/-/keyv-4.5.4.tgz",
      "integrity": "sha512-oxVHkHR/EJf2CNXnWxRLW6mg7JyCCUcG0DtEGmL2ctUo1PNTin1PUil+r/+4r5MpVgC/fn1kjsx7mjSujKqIpw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "json-buffer": "3.0.1"
      }
    },
    "node_modules/language-subtag-registry": {
      "version": "0.3.23",
      "resolved": "https://registry.npmjs.org/language-subtag-registry/-/language-subtag-registry-0.3.23.tgz",
      "integrity": "sha512-0K65Lea881pHotoGEa5gDlMxt3pctLi2RplBb7Ezh4rRdLEOtgi7n4EwK9lamnUCkKBqaeKRVebTq6BAxSkpXQ==",
      "dev": true,
      "license": "CC0-1.0"
    },
    "node_modules/language-tags": {
      "version": "1.0.9",
      "resolved": "https://registry.npmjs.org/language-tags/-/language-tags-1.0.9.tgz",
      "integrity": "sha512-MbjN408fEndfiQXbFQ1vnd+1NoLDsnQW41410oQBXiyXDMYH5z505juWa4KUE1LqxRC7DgOgZDbKLxHIwm27hA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "language-subtag-registry": "^0.3.20"
      },
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/levn": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
      "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "prelude-ls": "^1.2.1",
        "type-check": "~0.4.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/lightningcss": {
      "version": "1.30.1",
      "resolved": "https://registry.npmjs.org/lightningcss/-/lightningcss-1.30.1.tgz",
      "integrity": "sha512-xi6IyHML+c9+Q3W0S4fCQJOym42pyurFiJUHEcEyHS0CeKzia4yZDEsLlqOFykxOdHpNy0NmvVO31vcSqAxJCg==",
      "dev": true,
      "license": "MPL-2.0",
      "dependencies": {
        "detect-libc": "^2.0.3"
      },
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      },
      "optionalDependencies": {
        "lightningcss-darwin-arm64": "1.30.1",
        "lightningcss-darwin-x64": "1.30.1",
        "lightningcss-freebsd-x64": "1.30.1",
        "lightningcss-linux-arm-gnueabihf": "1.30.1",
        "lightningcss-linux-arm64-gnu": "1.30.1",
        "lightningcss-linux-arm64-musl": "1.30.1",
        "lightningcss-linux-x64-gnu": "1.30.1",
        "lightningcss-linux-x64-musl": "1.30.1",
        "lightningcss-win32-arm64-msvc": "1.30.1",
        "lightningcss-win32-x64-msvc": "1.30.1"
      }
    },
    "node_modules/lightningcss-darwin-arm64": {
      "version": "1.30.1",
      "resolved": "https://registry.npmjs.org/lightningcss-darwin-arm64/-/lightningcss-darwin-arm64-1.30.1.tgz",
      "integrity": "sha512-c8JK7hyE65X1MHMN+Viq9n11RRC7hgin3HhYKhrMyaXflk5GVplZ60IxyoVtzILeKr+xAJwg6zK6sjTBJ0FKYQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-darwin-x64": {
      "version": "1.30.1",
      "resolved": "https://registry.npmjs.org/lightningcss-darwin-x64/-/lightningcss-darwin-x64-1.30.1.tgz",
      "integrity": "sha512-k1EvjakfumAQoTfcXUcHQZhSpLlkAuEkdMBsI/ivWw9hL+7FtilQc0Cy3hrx0AAQrVtQAbMI7YjCgYgvn37PzA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-freebsd-x64": {
      "version": "1.30.1",
      "resolved": "https://registry.npmjs.org/lightningcss-freebsd-x64/-/lightningcss-freebsd-x64-1.30.1.tgz",
      "integrity": "sha512-kmW6UGCGg2PcyUE59K5r0kWfKPAVy4SltVeut+umLCFoJ53RdCUWxcRDzO1eTaxf/7Q2H7LTquFHPL5R+Gjyig==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-arm-gnueabihf": {
      "version": "1.30.1",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-arm-gnueabihf/-/lightningcss-linux-arm-gnueabihf-1.30.1.tgz",
      "integrity": "sha512-MjxUShl1v8pit+6D/zSPq9S9dQ2NPFSQwGvxBCYaBYLPlCWuPh9/t1MRS8iUaR8i+a6w7aps+B4N0S1TYP/R+Q==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-arm64-gnu": {
      "version": "1.30.1",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-arm64-gnu/-/lightningcss-linux-arm64-gnu-1.30.1.tgz",
      "integrity": "sha512-gB72maP8rmrKsnKYy8XUuXi/4OctJiuQjcuqWNlJQ6jZiWqtPvqFziskH3hnajfvKB27ynbVCucKSm2rkQp4Bw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-arm64-musl": {
      "version": "1.30.1",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-arm64-musl/-/lightningcss-linux-arm64-musl-1.30.1.tgz",
      "integrity": "sha512-jmUQVx4331m6LIX+0wUhBbmMX7TCfjF5FoOH6SD1CttzuYlGNVpA7QnrmLxrsub43ClTINfGSYyHe2HWeLl5CQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-x64-gnu": {
      "version": "1.30.1",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-x64-gnu/-/lightningcss-linux-x64-gnu-1.30.1.tgz",
      "integrity": "sha512-piWx3z4wN8J8z3+O5kO74+yr6ze/dKmPnI7vLqfSqI8bccaTGY5xiSGVIJBDd5K5BHlvVLpUB3S2YCfelyJ1bw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-x64-musl": {
      "version": "1.30.1",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-x64-musl/-/lightningcss-linux-x64-musl-1.30.1.tgz",
      "integrity": "sha512-rRomAK7eIkL+tHY0YPxbc5Dra2gXlI63HL+v1Pdi1a3sC+tJTcFrHX+E86sulgAXeI7rSzDYhPSeHHjqFhqfeQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-win32-arm64-msvc": {
      "version": "1.30.1",
      "resolved": "https://registry.npmjs.org/lightningcss-win32-arm64-msvc/-/lightningcss-win32-arm64-msvc-1.30.1.tgz",
      "integrity": "sha512-mSL4rqPi4iXq5YVqzSsJgMVFENoa4nGTT/GjO2c0Yl9OuQfPsIfncvLrEW6RbbB24WtZ3xP/2CCmI3tNkNV4oA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-win32-x64-msvc": {
      "version": "1.30.1",
      "resolved": "https://registry.npmjs.org/lightningcss-win32-x64-msvc/-/lightningcss-win32-x64-msvc-1.30.1.tgz",
      "integrity": "sha512-PVqXh48wh4T53F/1CCu8PIPCxLzWyCnn/9T5W1Jpmdy5h9Cwd+0YQS6/LwhHXSafuc61/xg9Lv5OrCby6a++jg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/locate-path": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
      "integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-locate": "^5.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/lodash.merge": {
      "version": "4.6.2",
      "resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
      "integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/loose-envify": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/loose-envify/-/loose-envify-1.4.0.tgz",
      "integrity": "sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "js-tokens": "^3.0.0 || ^4.0.0"
      },
      "bin": {
        "loose-envify": "cli.js"
      }
    },
    "node_modules/magic-string": {
      "version": "0.30.18",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.18.tgz",
      "integrity": "sha512-yi8swmWbO17qHhwIBNeeZxTceJMeBvWJaId6dyvTSOwTipqeHhMhOrz6513r1sOKnpvQ7zkhlG8tPrpilwTxHQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.5"
      }
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/merge2": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
      "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/micromatch": {
      "version": "4.0.8",
      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.8.tgz",
      "integrity": "sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "braces": "^3.0.3",
        "picomatch": "^2.3.1"
      },
      "engines": {
        "node": ">=8.6"
      }
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/minimist": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.8.tgz",
      "integrity": "sha512-2yyAR8qBkN3YuheJanUpWC5U3bb5osDywNB8RzDVlDwDHbocAJveqqj1u8+SVD7jkWT4yvsHCpWqqWqAxb0zCA==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/minipass": {
      "version": "7.1.2",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=16 || 14 >=14.17"
      }
    },
    "node_modules/minizlib": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/minizlib/-/minizlib-3.0.2.tgz",
      "integrity": "sha512-oG62iEk+CYt5Xj2YqI5Xi9xWUeZhDI8jjQmC5oThVH5JGCTgIjr7ciJDzC7MBzYd//WvR1OTmP5Q38Q8ShQtVA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "minipass": "^7.1.2"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/mkdirp": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-3.0.1.tgz",
      "integrity": "sha512-+NsyUUAZDmo6YVHzL/stxSu3t9YS1iljliy3BSDrXJ/dkn1KYdmtZODGGjLcc9XLgVVpH4KshHB8XmZgMhaBXg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "mkdirp": "dist/cjs/src/bin.js"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/napi-postinstall": {
      "version": "0.3.3",
      "resolved": "https://registry.npmjs.org/napi-postinstall/-/napi-postinstall-0.3.3.tgz",
      "integrity": "sha512-uTp172LLXSxuSYHv/kou+f6KW3SMppU9ivthaVTXian9sOt3XM/zHYHpRZiLgQoxeWfYUnslNWQHF1+G71xcow==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "napi-postinstall": "lib/cli.js"
      },
      "engines": {
        "node": "^12.20.0 || ^14.18.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/napi-postinstall"
      }
    },
    "node_modules/natural-compare": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
      "integrity": "sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/next": {
      "version": "15.5.2",
      "resolved": "https://registry.npmjs.org/next/-/next-15.5.2.tgz",
      "integrity": "sha512-H8Otr7abj1glFhbGnvUt3gz++0AF1+QoCXEBmd/6aKbfdFwrn0LpA836Ed5+00va/7HQSDD+mOoVhn3tNy3e/Q==",
      "license": "MIT",
      "dependencies": {
        "@next/env": "15.5.2",
        "@swc/helpers": "0.5.15",
        "caniuse-lite": "^1.0.30001579",
        "postcss": "8.4.31",
        "styled-jsx": "5.1.6"
      },
      "bin": {
        "next": "dist/bin/next"
      },
      "engines": {
        "node": "^18.18.0 || ^19.8.0 || >= 20.0.0"
      },
      "optionalDependencies": {
        "@next/swc-darwin-arm64": "15.5.2",
        "@next/swc-darwin-x64": "15.5.2",
        "@next/swc-linux-arm64-gnu": "15.5.2",
        "@next/swc-linux-arm64-musl": "15.5.2",
        "@next/swc-linux-x64-gnu": "15.5.2",
        "@next/swc-linux-x64-musl": "15.5.2",
        "@next/swc-win32-arm64-msvc": "15.5.2",
        "@next/swc-win32-x64-msvc": "15.5.2",
        "sharp": "^0.34.3"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.1.0",
        "@playwright/test": "^1.51.1",
        "babel-plugin-react-compiler": "*",
        "react": "^18.2.0 || 19.0.0-rc-de68d2f4-20241204 || ^19.0.0",
        "react-dom": "^18.2.0 || 19.0.0-rc-de68d2f4-20241204 || ^19.0.0",
        "sass": "^1.3.0"
      },
      "peerDependenciesMeta": {
        "@opentelemetry/api": {
          "optional": true
        },
        "@playwright/test": {
          "optional": true
        },
        "babel-plugin-react-compiler": {
          "optional": true
        },
        "sass": {
          "optional": true
        }
      }
    },
    "node_modules/next/node_modules/postcss": {
      "version": "8.4.31",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.4.31.tgz",
      "integrity": "sha512-PS08Iboia9mts/2ygV3eLpY5ghnUcfLV/EXTOW1E2qYxJKGGBUtNjN76FYHnMs36RmARn41bC0AZmn+rR0OVpQ==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.6",
        "picocolors": "^1.0.0",
        "source-map-js": "^1.0.2"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/node-releases": {
      "version": "2.0.19",
      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.19.tgz",
      "integrity": "sha512-xxOWJsBKtzAq7DY0J+DTzuz58K8e7sJbdgwkbMWQe8UYB6ekmsQ45q0M/tJDsGaZmbC+l7n57UV8Hl5tHxO9uw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/normalize-range": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/normalize-range/-/normalize-range-0.1.2.tgz",
      "integrity": "sha512-bdok/XvKII3nUpklnV6P2hxtMNrCboOjAcyBuQnWEhO665FwrSNRxU+AqpsyvO6LgGYPspN+lu5CLtw4jPRKNA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.13.4",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/object-keys": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/object-keys/-/object-keys-1.1.1.tgz",
      "integrity": "sha512-NuAESUOUMrlIXOfHKzD6bpPu3tYt3xvjNdRIQ+FeT0lNb4K8WR70CaDxhuNguS2XG+GjkyMwOzsN5ZktImfhLA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/object.assign": {
      "version": "4.1.7",
      "resolved": "https://registry.npmjs.org/object.assign/-/object.assign-4.1.7.tgz",
      "integrity": "sha512-nK28WOo+QIjBkDduTINE4JkF/UJJKyf2EJxvJKfblDpyg0Q+pkOHNTL0Qwy6NP6FhE/EnzV73BxxqcJaXY9anw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.3",
        "define-properties": "^1.2.1",
        "es-object-atoms": "^1.0.0",
        "has-symbols": "^1.1.0",
        "object-keys": "^1.1.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/object.entries": {
      "version": "1.1.9",
      "resolved": "https://registry.npmjs.org/object.entries/-/object.entries-1.1.9.tgz",
      "integrity": "sha512-8u/hfXFRBD1O0hPUjioLhoWFHRmt6tKA4/vZPyckBr18l1KE9uHrFaFaUi8MDRTpi4uak2goyPTSNJLXX2k2Hw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.4",
        "define-properties": "^1.2.1",
        "es-object-atoms": "^1.1.1"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/object.fromentries": {
      "version": "2.0.8",
      "resolved": "https://registry.npmjs.org/object.fromentries/-/object.fromentries-2.0.8.tgz",
      "integrity": "sha512-k6E21FzySsSK5a21KRADBd/NGneRegFO5pLHfdQLpRDETUNJueLXs3WCzyQ3tFRDYgbq3KHGXfTbi2bs8WQ6rQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.7",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.2",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/object.groupby": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/object.groupby/-/object.groupby-1.0.3.tgz",
      "integrity": "sha512-+Lhy3TQTuzXI5hevh8sBGqbmurHbbIjAi0Z4S63nthVLmLxfbj4T54a4CfZrXIrt9iP4mVAPYMo/v99taj3wjQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.7",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/object.values": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/object.values/-/object.values-1.2.1.tgz",
      "integrity": "sha512-gXah6aZrcUxjWg2zR2MwouP2eHlCBzdV4pygudehaKXSGW4v2AsRQUK+lwwXhii6KFZcunEnmSUoYp5CXibxtA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.3",
        "define-properties": "^1.2.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/optionator": {
      "version": "0.9.4",
      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.4.tgz",
      "integrity": "sha512-6IpQ7mKUxRcZNLIObR0hz7lxsapSSIYNZJwXPGeF0mTVqGKFIXj1DQcMoT22S3ROcLyY/rz0PWaWZ9ayWmad9g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "deep-is": "^0.1.3",
        "fast-levenshtein": "^2.0.6",
        "levn": "^0.4.1",
        "prelude-ls": "^1.2.1",
        "type-check": "^0.4.0",
        "word-wrap": "^1.2.5"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/own-keys": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/own-keys/-/own-keys-1.0.1.tgz",
      "integrity": "sha512-qFOyK5PjiWZd+QQIh+1jhdb9LpxTF0qs7Pm8o5QHYZ0M3vKqSqzsZaEB6oWlxZ+q2sJBMI/Ktgd2N5ZwQoRHfg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "get-intrinsic": "^1.2.6",
        "object-keys": "^1.1.1",
        "safe-push-apply": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/p-limit": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
      "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "yocto-queue": "^0.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-locate": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
      "integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-limit": "^3.0.2"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/parent-module": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "callsites": "^3.0.0"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/path-exists": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
      "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-parse": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
      "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "license": "ISC"
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/possible-typed-array-names": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/possible-typed-array-names/-/possible-typed-array-names-1.1.0.tgz",
      "integrity": "sha512-/+5VFTchJDoVj3bhoqi6UeymcD00DAwb1nJwamzPvHEszJ4FpF6SNNbUbOS8yI56qHzdV8eK0qEfOSiodkTdxg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/postcss": {
      "version": "8.5.6",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.6.tgz",
      "integrity": "sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/postcss-value-parser": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-4.2.0.tgz",
      "integrity": "sha512-1NNCs6uurfkVbeXG4S8JFT9t19m45ICnif8zWLd5oPSZ50QnwMfK+H3jv408d4jw/7Bttv5axS5IiHoLaVNHeQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/prelude-ls": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
      "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/prop-types": {
      "version": "15.8.1",
      "resolved": "https://registry.npmjs.org/prop-types/-/prop-types-15.8.1.tgz",
      "integrity": "sha512-oj87CgZICdulUohogVAR7AjlC0327U4el4L6eAvOqCeudMDVU0NThNaV+b9Df4dXgSP1gXMTnPdhfe/2qDH5cg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "loose-envify": "^1.4.0",
        "object-assign": "^4.1.1",
        "react-is": "^16.13.1"
      }
    },
    "node_modules/proxy-from-env": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/proxy-from-env/-/proxy-from-env-1.1.0.tgz",
      "integrity": "sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg==",
      "license": "MIT"
    },
    "node_modules/punycode": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
      "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/queue-microtask": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz",
      "integrity": "sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/react": {
      "version": "19.1.0",
      "resolved": "https://registry.npmjs.org/react/-/react-19.1.0.tgz",
      "integrity": "sha512-FS+XFBNvn3GTAWq26joslQgWNoFu08F4kl0J4CgdNKADkdSGXQyTCnKteIAJy96Br6YbpEU1LSzV5dYtjMkMDg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-dom": {
      "version": "19.1.0",
      "resolved": "https://registry.npmjs.org/react-dom/-/react-dom-19.1.0.tgz",
      "integrity": "sha512-Xs1hdnE+DyKgeHJeJznQmYMIBG3TKIHJJT95Q58nHLSrElKlGQqDTR2HQ9fx5CN/Gk6Vh/kupBTDLU11/nDk/g==",
      "license": "MIT",
      "dependencies": {
        "scheduler": "^0.26.0"
      },
      "peerDependencies": {
        "react": "^19.1.0"
      }
    },
    "node_modules/react-is": {
      "version": "16.13.1",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-16.13.1.tgz",
      "integrity": "sha512-24e6ynE2H+OKt4kqsOvNd8kBpV65zoxbA4BVsEOB3ARVWQki/DHzaUoC5KuON/BiccDaCCTZBuOcfZs70kR8bQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/reflect.getprototypeof": {
      "version": "1.0.10",
      "resolved": "https://registry.npmjs.org/reflect.getprototypeof/-/reflect.getprototypeof-1.0.10.tgz",
      "integrity": "sha512-00o4I+DVrefhv+nX0ulyi3biSHCPDe+yLv5o/p6d/UVlirijB8E16FtfwSAi4g3tcqrQ4lRAqQSoFEZJehYEcw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.9",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.0.0",
        "get-intrinsic": "^1.2.7",
        "get-proto": "^1.0.1",
        "which-builtin-type": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/regexp.prototype.flags": {
      "version": "1.5.4",
      "resolved": "https://registry.npmjs.org/regexp.prototype.flags/-/regexp.prototype.flags-1.5.4.tgz",
      "integrity": "sha512-dYqgNSZbDwkaJ2ceRd9ojCGjBq+mOm9LmtXnAnEGyHhN/5R7iDW2TRw3h+o/jCFxus3P2LfWIIiwowAjANm7IA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "define-properties": "^1.2.1",
        "es-errors": "^1.3.0",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "set-function-name": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/resolve": {
      "version": "1.22.10",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.10.tgz",
      "integrity": "sha512-NPRy+/ncIMeDlTAsuqwKIiferiawhefFJtkNSW0qZJEqMEb+qBt/77B/jGeeek+F0uOeN05CDa6HXbbIgtVX4w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-core-module": "^2.16.0",
        "path-parse": "^1.0.7",
        "supports-preserve-symlinks-flag": "^1.0.0"
      },
      "bin": {
        "resolve": "bin/resolve"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/resolve-from": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
      "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/resolve-pkg-maps": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/resolve-pkg-maps/-/resolve-pkg-maps-1.0.0.tgz",
      "integrity": "sha512-seS2Tj26TBVOC2NIc2rOe2y2ZO7efxITtLZcGSOnHHNOQ7CkiUBfw0Iw2ck6xkIhPwLhKNLS8BO+hEpngQlqzw==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://github.com/privatenumber/resolve-pkg-maps?sponsor=1"
      }
    },
    "node_modules/reusify": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.1.0.tgz",
      "integrity": "sha512-g6QUff04oZpHs0eG5p83rFLhHeV00ug/Yf9nZM6fLeUrPguBTkTQOdpAWWspMh55TZfVQDPaN3NQJfbVRAxdIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "iojs": ">=1.0.0",
        "node": ">=0.10.0"
      }
    },
    "node_modules/run-parallel": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz",
      "integrity": "sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "queue-microtask": "^1.2.2"
      }
    },
    "node_modules/safe-array-concat": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/safe-array-concat/-/safe-array-concat-1.1.3.tgz",
      "integrity": "sha512-AURm5f0jYEOydBj7VQlVvDrjeFgthDdEF5H1dP+6mNpoXOMo1quQqJ4wvJDyRZ9+pO3kGWoOdmV08cSv2aJV6Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.2",
        "get-intrinsic": "^1.2.6",
        "has-symbols": "^1.1.0",
        "isarray": "^2.0.5"
      },
      "engines": {
        "node": ">=0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/safe-push-apply": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/safe-push-apply/-/safe-push-apply-1.0.0.tgz",
      "integrity": "sha512-iKE9w/Z7xCzUMIZqdBsp6pEQvwuEebH4vdpjcDWnyzaI6yl6O9FHvVpmGelvEHNsoY6wGblkxR6Zty/h00WiSA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "isarray": "^2.0.5"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/safe-regex-test": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/safe-regex-test/-/safe-regex-test-1.1.0.tgz",
      "integrity": "sha512-x/+Cz4YrimQxQccJf5mKEbIa1NzeCRNI5Ecl/ekmlYaampdNLPalVyIcCZNNH3MvmqBugV5TMYZXv0ljslUlaw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "is-regex": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/scheduler": {
      "version": "0.26.0",
      "resolved": "https://registry.npmjs.org/scheduler/-/scheduler-0.26.0.tgz",
      "integrity": "sha512-NlHwttCI/l5gCPR3D1nNXtWABUmBwvZpEQiD4IXSbIDq8BzLIK/7Ir5gTFSGZDUu37K5cMNp0hFtzO38sC7gWA==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "7.7.2",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.2.tgz",
      "integrity": "sha512-RF0Fw+rO5AMf9MAyaRXI4AV0Ulj5lMHqVxxdSgiVbixSCXoEmmX/jk0CuJw4+3SqroYO9VoUh+HcuJivvtJemA==",
      "devOptional": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/set-function-length": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/set-function-length/-/set-function-length-1.2.2.tgz",
      "integrity": "sha512-pgRc4hJ4/sNjWCSS9AmnS40x3bNMDTknHgL5UaMBTMyJnU90EgWh1Rz+MC9eFu4BuN/UwZjKQuY/1v3rM7HMfg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "define-data-property": "^1.1.4",
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2",
        "get-intrinsic": "^1.2.4",
        "gopd": "^1.0.1",
        "has-property-descriptors": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/set-function-name": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/set-function-name/-/set-function-name-2.0.2.tgz",
      "integrity": "sha512-7PGFlmtwsEADb0WYyvCMa1t+yke6daIG4Wirafur5kcf+MhUnPms1UeR0CKQdTZD81yESwMHbtn+TR+dMviakQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "define-data-property": "^1.1.4",
        "es-errors": "^1.3.0",
        "functions-have-names": "^1.2.3",
        "has-property-descriptors": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/set-proto": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/set-proto/-/set-proto-1.0.0.tgz",
      "integrity": "sha512-RJRdvCo6IAnPdsvP/7m6bsQqNnn1FCBX5ZNtFL98MmFF/4xAIJTIg1YbHW5DC2W5SKZanrC6i4HsJqlajw/dZw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/sharp": {
      "version": "0.34.3",
      "resolved": "https://registry.npmjs.org/sharp/-/sharp-0.34.3.tgz",
      "integrity": "sha512-eX2IQ6nFohW4DbvHIOLRB3MHFpYqaqvXd3Tp5e/T/dSH83fxaNJQRvDMhASmkNTsNTVF2/OOopzRCt7xokgPfg==",
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "optional": true,
      "dependencies": {
        "color": "^4.2.3",
        "detect-libc": "^2.0.4",
        "semver": "^7.7.2"
      },
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-darwin-arm64": "0.34.3",
        "@img/sharp-darwin-x64": "0.34.3",
        "@img/sharp-libvips-darwin-arm64": "1.2.0",
        "@img/sharp-libvips-darwin-x64": "1.2.0",
        "@img/sharp-libvips-linux-arm": "1.2.0",
        "@img/sharp-libvips-linux-arm64": "1.2.0",
        "@img/sharp-libvips-linux-ppc64": "1.2.0",
        "@img/sharp-libvips-linux-s390x": "1.2.0",
        "@img/sharp-libvips-linux-x64": "1.2.0",
        "@img/sharp-libvips-linuxmusl-arm64": "1.2.0",
        "@img/sharp-libvips-linuxmusl-x64": "1.2.0",
        "@img/sharp-linux-arm": "0.34.3",
        "@img/sharp-linux-arm64": "0.34.3",
        "@img/sharp-linux-ppc64": "0.34.3",
        "@img/sharp-linux-s390x": "0.34.3",
        "@img/sharp-linux-x64": "0.34.3",
        "@img/sharp-linuxmusl-arm64": "0.34.3",
        "@img/sharp-linuxmusl-x64": "0.34.3",
        "@img/sharp-wasm32": "0.34.3",
        "@img/sharp-win32-arm64": "0.34.3",
        "@img/sharp-win32-ia32": "0.34.3",
        "@img/sharp-win32-x64": "0.34.3"
      }
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/side-channel": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3",
        "side-channel-list": "^1.0.0",
        "side-channel-map": "^1.0.1",
        "side-channel-weakmap": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-list": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-map": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-weakmap": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3",
        "side-channel-map": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/simple-swizzle": {
      "version": "0.2.2",
      "resolved": "https://registry.npmjs.org/simple-swizzle/-/simple-swizzle-0.2.2.tgz",
      "integrity": "sha512-JA//kQgZtbuY83m+xT+tXJkmJncGMTFT+C+g2h2R9uxkYIrE2yy9sgmcLhCnw57/WSD+Eh3J97FPEDFnbXnDUg==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "is-arrayish": "^0.3.1"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/stable-hash": {
      "version": "0.0.5",
      "resolved": "https://registry.npmjs.org/stable-hash/-/stable-hash-0.0.5.tgz",
      "integrity": "sha512-+L3ccpzibovGXFK+Ap/f8LOS0ahMrHTf3xu7mMLSpEGU0EO9ucaysSylKo9eRDFNhWve/y275iPmIZ4z39a9iA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/stop-iteration-iterator": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/stop-iteration-iterator/-/stop-iteration-iterator-1.1.0.tgz",
      "integrity": "sha512-eLoXW/DHyl62zxY4SCaIgnRhuMr6ri4juEYARS8E6sCEqzKpOiE521Ucofdx+KnDZl5xmvGYaaKCk5FEOxJCoQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "internal-slot": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/string.prototype.includes": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/string.prototype.includes/-/string.prototype.includes-2.0.1.tgz",
      "integrity": "sha512-o7+c9bW6zpAdJHTtujeePODAhkuicdAryFsfVKwA+wGw89wJ4GTY484WTucM9hLtDEOpOvI+aHnzqnC5lHp4Rg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.7",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.3"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/string.prototype.matchall": {
      "version": "4.0.12",
      "resolved": "https://registry.npmjs.org/string.prototype.matchall/-/string.prototype.matchall-4.0.12.tgz",
      "integrity": "sha512-6CC9uyBL+/48dYizRf7H7VAYCMCNTBeM78x/VTUe9bFEaxBepPJDa1Ow99LqI/1yF7kuy7Q3cQsYMrcjGUcskA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.3",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.6",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.0.0",
        "get-intrinsic": "^1.2.6",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "internal-slot": "^1.1.0",
        "regexp.prototype.flags": "^1.5.3",
        "set-function-name": "^2.0.2",
        "side-channel": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/string.prototype.repeat": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/string.prototype.repeat/-/string.prototype.repeat-1.0.0.tgz",
      "integrity": "sha512-0u/TldDbKD8bFCQ/4f5+mNRrXwZ8hg2w7ZR8wa16e8z9XpePWl3eGEcUD0OXpEH/VJH/2G3gjUtR3ZOiBe2S/w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "define-properties": "^1.1.3",
        "es-abstract": "^1.17.5"
      }
    },
    "node_modules/string.prototype.trim": {
      "version": "1.2.10",
      "resolved": "https://registry.npmjs.org/string.prototype.trim/-/string.prototype.trim-1.2.10.tgz",
      "integrity": "sha512-Rs66F0P/1kedk5lyYyH9uBzuiI/kNRmwJAR9quK6VOtIpZ2G+hMZd+HQbbv25MgCA6gEffoMZYxlTod4WcdrKA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.2",
        "define-data-property": "^1.1.4",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.5",
        "es-object-atoms": "^1.0.0",
        "has-property-descriptors": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/string.prototype.trimend": {
      "version": "1.0.9",
      "resolved": "https://registry.npmjs.org/string.prototype.trimend/-/string.prototype.trimend-1.0.9.tgz",
      "integrity": "sha512-G7Ok5C6E/j4SGfyLCloXTrngQIQU3PWtXGst3yM7Bea9FRURf1S42ZHlZZtsNque2FN2PoUhfZXYLNWwEr4dLQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.2",
        "define-properties": "^1.2.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/string.prototype.trimstart": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/string.prototype.trimstart/-/string.prototype.trimstart-1.0.8.tgz",
      "integrity": "sha512-UXSH262CSZY1tfu3G3Secr6uGLCFVPMhIqHjlgCUtCCcgihYc/xKs9djMTMUOb2j1mVSeU8EU6NWc/iQKU6Gfg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.7",
        "define-properties": "^1.2.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/strip-bom": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/strip-bom/-/strip-bom-3.0.0.tgz",
      "integrity": "sha512-vavAMRXOgBVNF6nyEEmL3DBK19iRpDcoIwW+swQ+CbGiu7lju6t+JklA1MHweoWtadgt4ISVUsXLyDq34ddcwA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/strip-json-comments": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
      "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/styled-jsx": {
      "version": "5.1.6",
      "resolved": "https://registry.npmjs.org/styled-jsx/-/styled-jsx-5.1.6.tgz",
      "integrity": "sha512-qSVyDTeMotdvQYoHWLNGwRFJHC+i+ZvdBRYosOFgC+Wg1vx4frN2/RG/NA7SYqqvKNLf39P2LSRA2pu6n0XYZA==",
      "license": "MIT",
      "dependencies": {
        "client-only": "0.0.1"
      },
      "engines": {
        "node": ">= 12.0.0"
      },
      "peerDependencies": {
        "react": ">= 16.8.0 || 17.x.x || ^18.0.0-0 || ^19.0.0-0"
      },
      "peerDependenciesMeta": {
        "@babel/core": {
          "optional": true
        },
        "babel-plugin-macros": {
          "optional": true
        }
      }
    },
    "node_modules/supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/supports-preserve-symlinks-flag": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz",
      "integrity": "sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/swr": {
      "version": "2.3.6",
      "resolved": "https://registry.npmjs.org/swr/-/swr-2.3.6.tgz",
      "integrity": "sha512-wfHRmHWk/isGNMwlLGlZX5Gzz/uTgo0o2IRuTMcf4CPuPFJZlq0rDaKUx+ozB5nBOReNV1kiOyzMfj+MBMikLw==",
      "license": "MIT",
      "dependencies": {
        "dequal": "^2.0.3",
        "use-sync-external-store": "^1.4.0"
      },
      "peerDependencies": {
        "react": "^16.11.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/tailwindcss": {
      "version": "4.1.12",
      "resolved": "https://registry.npmjs.org/tailwindcss/-/tailwindcss-4.1.12.tgz",
      "integrity": "sha512-DzFtxOi+7NsFf7DBtI3BJsynR+0Yp6etH+nRPTbpWnS2pZBaSksv/JGctNwSWzbFjp0vxSqknaUylseZqMDGrA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tapable": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/tapable/-/tapable-2.2.3.tgz",
      "integrity": "sha512-ZL6DDuAlRlLGghwcfmSn9sK3Hr6ArtyudlSAiCqQ6IfE+b+HHbydbYDIG15IfS5do+7XQQBdBiubF/cV2dnDzg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/webpack"
      }
    },
    "node_modules/tar": {
      "version": "7.4.3",
      "resolved": "https://registry.npmjs.org/tar/-/tar-7.4.3.tgz",
      "integrity": "sha512-5S7Va8hKfV7W5U6g3aYxXmlPoZVAwUMy9AOKyF2fVuZa2UD3qZjg578OrLRt8PcNN1PleVaL/5/yYATNL0ICUw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "@isaacs/fs-minipass": "^4.0.0",
        "chownr": "^3.0.0",
        "minipass": "^7.1.2",
        "minizlib": "^3.0.1",
        "mkdirp": "^3.0.1",
        "yallist": "^5.0.0"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/tinyglobby": {
      "version": "0.2.14",
      "resolved": "https://registry.npmjs.org/tinyglobby/-/tinyglobby-0.2.14.tgz",
      "integrity": "sha512-tX5e7OM1HnYr2+a2C/4V0htOcSQcoSTH9KgJnVvNm5zm/cyEWKJ7j7YutsH9CxMdtOkkLFy2AHrMci9IM8IPZQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fdir": "^6.4.4",
        "picomatch": "^4.0.2"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/SuperchupuDev"
      }
    },
    "node_modules/tinyglobby/node_modules/fdir": {
      "version": "6.5.0",
      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.5.0.tgz",
      "integrity": "sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12.0.0"
      },
      "peerDependencies": {
        "picomatch": "^3 || ^4"
      },
      "peerDependenciesMeta": {
        "picomatch": {
          "optional": true
        }
      }
    },
    "node_modules/tinyglobby/node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/ts-api-utils": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/ts-api-utils/-/ts-api-utils-2.1.0.tgz",
      "integrity": "sha512-CUgTZL1irw8u29bzrOD/nH85jqyc74D6SshFgujOIA7osm2Rz7dYH77agkx7H4FBNxDq7Cjf+IjaX/8zwFW+ZQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18.12"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4"
      }
    },
    "node_modules/tsconfig-paths": {
      "version": "3.15.0",
      "resolved": "https://registry.npmjs.org/tsconfig-paths/-/tsconfig-paths-3.15.0.tgz",
      "integrity": "sha512-2Ac2RgzDe/cn48GvOe3M+o82pEFewD3UPbyoUHHdKasHwJKjds4fLXWf/Ux5kATBKN20oaFGu+jbElp1pos0mg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/json5": "^0.0.29",
        "json5": "^1.0.2",
        "minimist": "^1.2.6",
        "strip-bom": "^3.0.0"
      }
    },
    "node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/type-check": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
      "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "prelude-ls": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/typed-array-buffer": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/typed-array-buffer/-/typed-array-buffer-1.0.3.tgz",
      "integrity": "sha512-nAYYwfY3qnzX30IkA6AQZjVbtK6duGontcQm1WSG1MD94YLqK0515GNApXkoxKOWMusVssAHWLh9SeaoefYFGw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "es-errors": "^1.3.0",
        "is-typed-array": "^1.1.14"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/typed-array-byte-length": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/typed-array-byte-length/-/typed-array-byte-length-1.0.3.tgz",
      "integrity": "sha512-BaXgOuIxz8n8pIq3e7Atg/7s+DpiYrxn4vdot3w9KbnBhcRQq6o3xemQdIfynqSeXeDrF32x+WvfzmOjPiY9lg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "for-each": "^0.3.3",
        "gopd": "^1.2.0",
        "has-proto": "^1.2.0",
        "is-typed-array": "^1.1.14"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/typed-array-byte-offset": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/typed-array-byte-offset/-/typed-array-byte-offset-1.0.4.tgz",
      "integrity": "sha512-bTlAFB/FBYMcuX81gbL4OcpH5PmlFHqlCCpAl8AlEzMz5k53oNDvN8p1PNOWLEmI2x4orp3raOFB51tv9X+MFQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "available-typed-arrays": "^1.0.7",
        "call-bind": "^1.0.8",
        "for-each": "^0.3.3",
        "gopd": "^1.2.0",
        "has-proto": "^1.2.0",
        "is-typed-array": "^1.1.15",
        "reflect.getprototypeof": "^1.0.9"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/typed-array-length": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/typed-array-length/-/typed-array-length-1.0.7.tgz",
      "integrity": "sha512-3KS2b+kL7fsuk/eJZ7EQdnEmQoaho/r6KUef7hxvltNA5DR8NAUM+8wJMbJyZ4G9/7i3v5zPBIMN5aybAh2/Jg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.7",
        "for-each": "^0.3.3",
        "gopd": "^1.0.1",
        "is-typed-array": "^1.1.13",
        "possible-typed-array-names": "^1.0.0",
        "reflect.getprototypeof": "^1.0.6"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/typescript": {
      "version": "5.9.2",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.9.2.tgz",
      "integrity": "sha512-CWBzXQrc/qOkhidw1OzBTQuYRbfyxDXJMVJ1XNwUHGROVmuaeiEm3OslpZ1RV96d7SKKjZKrSJu3+t/xlw3R9A==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/unbox-primitive": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/unbox-primitive/-/unbox-primitive-1.1.0.tgz",
      "integrity": "sha512-nWJ91DjeOkej/TA8pXQ3myruKpKEYgqvpw9lz4OPHj/NWFNluYrjbz9j01CJ8yKQd2g4jFoOkINCTW2I5LEEyw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "has-bigints": "^1.0.2",
        "has-symbols": "^1.1.0",
        "which-boxed-primitive": "^1.1.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/undici-types": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/unrs-resolver": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/unrs-resolver/-/unrs-resolver-1.11.1.tgz",
      "integrity": "sha512-bSjt9pjaEBnNiGgc9rUiHGKv5l4/TGzDmYw3RhnkJGtLhbnnA/5qJj7x3dNDCRx/PJxu774LlH8lCOlB4hEfKg==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "dependencies": {
        "napi-postinstall": "^0.3.0"
      },
      "funding": {
        "url": "https://opencollective.com/unrs-resolver"
      },
      "optionalDependencies": {
        "@unrs/resolver-binding-android-arm-eabi": "1.11.1",
        "@unrs/resolver-binding-android-arm64": "1.11.1",
        "@unrs/resolver-binding-darwin-arm64": "1.11.1",
        "@unrs/resolver-binding-darwin-x64": "1.11.1",
        "@unrs/resolver-binding-freebsd-x64": "1.11.1",
        "@unrs/resolver-binding-linux-arm-gnueabihf": "1.11.1",
        "@unrs/resolver-binding-linux-arm-musleabihf": "1.11.1",
        "@unrs/resolver-binding-linux-arm64-gnu": "1.11.1",
        "@unrs/resolver-binding-linux-arm64-musl": "1.11.1",
        "@unrs/resolver-binding-linux-ppc64-gnu": "1.11.1",
        "@unrs/resolver-binding-linux-riscv64-gnu": "1.11.1",
        "@unrs/resolver-binding-linux-riscv64-musl": "1.11.1",
        "@unrs/resolver-binding-linux-s390x-gnu": "1.11.1",
        "@unrs/resolver-binding-linux-x64-gnu": "1.11.1",
        "@unrs/resolver-binding-linux-x64-musl": "1.11.1",
        "@unrs/resolver-binding-wasm32-wasi": "1.11.1",
        "@unrs/resolver-binding-win32-arm64-msvc": "1.11.1",
        "@unrs/resolver-binding-win32-ia32-msvc": "1.11.1",
        "@unrs/resolver-binding-win32-x64-msvc": "1.11.1"
      }
    },
    "node_modules/update-browserslist-db": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.1.3.tgz",
      "integrity": "sha512-UxhIZQ+QInVdunkDAaiazvvT/+fXL5Osr0JZlJulepYu6Jd7qJtDZjlur0emRlT71EN3ScPoE7gvsuIKKNavKw==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "escalade": "^3.2.0",
        "picocolors": "^1.1.1"
      },
      "bin": {
        "update-browserslist-db": "cli.js"
      },
      "peerDependencies": {
        "browserslist": ">= 4.21.0"
      }
    },
    "node_modules/uri-js": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
      "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "punycode": "^2.1.0"
      }
    },
    "node_modules/use-sync-external-store": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/use-sync-external-store/-/use-sync-external-store-1.5.0.tgz",
      "integrity": "sha512-Rb46I4cGGVBmjamjphe8L/UnvJD+uPPtTkNvX5mZgqdbavhI4EbgIWJiIHXJ8bc/i9EQGPRh4DwEURJ552Do0A==",
      "license": "MIT",
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/which-boxed-primitive": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/which-boxed-primitive/-/which-boxed-primitive-1.1.1.tgz",
      "integrity": "sha512-TbX3mj8n0odCBFVlY8AxkqcHASw3L60jIuF8jFP78az3C2YhmGvqbHBpAjTRH2/xqYunrJ9g1jSyjCjpoWzIAA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-bigint": "^1.1.0",
        "is-boolean-object": "^1.2.1",
        "is-number-object": "^1.1.1",
        "is-string": "^1.1.1",
        "is-symbol": "^1.1.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/which-builtin-type": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/which-builtin-type/-/which-builtin-type-1.2.1.tgz",
      "integrity": "sha512-6iBczoX+kDQ7a3+YJBnh3T+KZRxM/iYNPXicqk66/Qfm1b93iu+yOImkg0zHbj5LNOcNv1TEADiZ0xa34B4q6Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "function.prototype.name": "^1.1.6",
        "has-tostringtag": "^1.0.2",
        "is-async-function": "^2.0.0",
        "is-date-object": "^1.1.0",
        "is-finalizationregistry": "^1.1.0",
        "is-generator-function": "^1.0.10",
        "is-regex": "^1.2.1",
        "is-weakref": "^1.0.2",
        "isarray": "^2.0.5",
        "which-boxed-primitive": "^1.1.0",
        "which-collection": "^1.0.2",
        "which-typed-array": "^1.1.16"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/which-collection": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/which-collection/-/which-collection-1.0.2.tgz",
      "integrity": "sha512-K4jVyjnBdgvc86Y6BkaLZEN933SwYOuBFkdmBu9ZfkcAbdVbpITnDmjvZ/aQjRXQrv5EPkTnD1s39GiiqbngCw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-map": "^2.0.3",
        "is-set": "^2.0.3",
        "is-weakmap": "^2.0.2",
        "is-weakset": "^2.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/which-typed-array": {
      "version": "1.1.19",
      "resolved": "https://registry.npmjs.org/which-typed-array/-/which-typed-array-1.1.19.tgz",
      "integrity": "sha512-rEvr90Bck4WZt9HHFC4DJMsjvu7x+r6bImz0/BrbWb7A2djJ8hnZMrWnHo9F8ssv0OMErasDhftrfROTyqSDrw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "available-typed-arrays": "^1.0.7",
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.4",
        "for-each": "^0.3.5",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-tostringtag": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/word-wrap": {
      "version": "1.2.5",
      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.5.tgz",
      "integrity": "sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/yallist": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-5.0.0.tgz",
      "integrity": "sha512-YgvUTfwqyc7UXVMrB+SImsVYSmTS8X/tSrtdNZMImM+n7+QTriRXyXim0mBrTXNeqzVF0KWGgHPeiyViFFrNDw==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/yocto-queue": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
      "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    }
  }
}


===== FILE: sliptail-frontend\package.json =====

{
  "name": "sliptail-frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build --turbopack",
    "start": "next start",
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx"
  },
  "dependencies": {
    "axios": "^1.11.0",
    "next": "15.5.2",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "swr": "^2.3.6"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.21",
    "eslint": "^9",
    "eslint-config-next": "15.5.2",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.12",
    "typescript": "^5"
  }
}


===== FILE: sliptail-frontend\README.md =====

This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.


<!-- Test -->

===== FILE: sliptail-frontend\src\app\about\page.tsx =====

export default function AboutPage() {
  return (
    <main className="mx-auto max-w-4xl px-6 py-12">
      <h1 className="mb-4 text-3xl font-bold">About Sliptail</h1>
      <p>Sliptail connects creators with fans through memberships, downloads, and custom requests.</p>
    </main>
  );
}


===== FILE: sliptail-frontend\src\app\admin\categories\page.tsx =====

import { cookies } from "next/headers";
import { revalidatePath } from "next/cache";

interface Category {
  id: number;
  name: string;
  slug: string | null;
  active: boolean;
  created_at: string;
}

interface CategoriesResponse {
  categories: Category[];
}

async function fetchCategories(): Promise<Category[]> {
  const base = process.env.NEXT_PUBLIC_API_BASE!;
  const cookieHeader = cookies().toString();

  const res = await fetch(`${base}/api/admin/categories`, {
    cache: "no-store",
    headers: { Cookie: cookieHeader },
  });
  if (!res.ok) throw new Error("Failed to load categories");
  const data: CategoriesResponse = await res.json();
  return data.categories;
}

/* --------------------------- Server Actions --------------------------- */

export async function createCategoryAction(formData: FormData): Promise<void> {
  "use server";
  const name = String(formData.get("name") ?? "").trim();
  const slug = String(formData.get("slug") ?? "").trim() || null;
  if (!name) return;

  const base = process.env.NEXT_PUBLIC_API_BASE!;
  const cookieHeader = cookies().toString();

  await fetch(`${base}/api/admin/categories`, {
    method: "POST",
    headers: { "Content-Type": "application/json", Cookie: cookieHeader },
    body: JSON.stringify({ name, slug }),
  }).catch(() => {});

  revalidatePath("/admin/categories");
}

export async function updateCategoryAction(formData: FormData): Promise<void> {
  "use server";
  const idRaw = formData.get("id");
  const name = String(formData.get("name") ?? "").trim() || null;
  const slug = String(formData.get("slug") ?? "").trim() || null;

  const id = Number(idRaw);
  if (!Number.isFinite(id)) return;

  const base = process.env.NEXT_PUBLIC_API_BASE!;
  const cookieHeader = cookies().toString();

  await fetch(`${base}/api/admin/categories/${id}`, {
    method: "PUT",
    headers: { "Content-Type": "application/json", Cookie: cookieHeader },
    body: JSON.stringify({ name, slug }),
  }).catch(() => {});

  revalidatePath("/admin/categories");
}

export async function toggleActiveAction(formData: FormData): Promise<void> {
  "use server";
  const idRaw = formData.get("id");
  const nextActive = String(formData.get("nextActive") ?? "") === "true";

  const id = Number(idRaw);
  if (!Number.isFinite(id)) return;

  const base = process.env.NEXT_PUBLIC_API_BASE!;
  const cookieHeader = cookies().toString();

  // Uses your protected PATCH in routes/categories.js
  await fetch(`${base}/api/categories/${id}`, {
    method: "PATCH",
    headers: { "Content-Type": "application/json", Cookie: cookieHeader },
    body: JSON.stringify({ active: nextActive }),
  }).catch(() => {});

  revalidatePath("/admin/categories");
}

export async function deleteCategoryAction(formData: FormData): Promise<void> {
  "use server";
  const idRaw = formData.get("id");
  const id = Number(idRaw);
  if (!Number.isFinite(id)) return;

  const base = process.env.NEXT_PUBLIC_API_BASE!;
  const cookieHeader = cookies().toString();

  await fetch(`${base}/api/admin/categories/${id}`, {
    method: "DELETE",
    headers: { Cookie: cookieHeader },
  }).catch(() => {});

  revalidatePath("/admin/categories");
}

/* ------------------------------- Page -------------------------------- */

export default async function CategoriesPage() {
  const categories = await fetchCategories();

  return (
    <div className="space-y-6">
      <h2 className="text-xl font-semibold">Categories</h2>

      {/* Create */}
      <form action={createCategoryAction} className="flex flex-wrap gap-2 items-end">
        <div className="flex flex-col">
          <label className="text-sm opacity-70">Name</label>
          <input name="name" required className="border rounded px-3 py-2" />
        </div>
        <div className="flex flex-col">
          <label className="text-sm opacity-70">Slug</label>
          <input name="slug" className="border rounded px-3 py-2" />
        </div>
        <button className="border rounded px-3 py-2">Add</button>
      </form>

      {/* List / Edit / Toggle / Delete */}
      <div className="space-y-2">
        {categories.map((cat) => (
          <div key={cat.id} className="flex flex-col sm:flex-row sm:items-center gap-3 border rounded-2xl p-3">
            {/* Edit Name/Slug */}
            <form action={updateCategoryAction} className="flex flex-wrap gap-2 items-end">
              <input type="hidden" name="id" value={cat.id} />
              <div className="flex flex-col">
                <label className="text-sm opacity-70">Name</label>
                <input name="name" defaultValue={cat.name} className="border rounded px-3 py-2" />
              </div>
              <div className="flex flex-col">
                <label className="text-sm opacity-70">Slug</label>
                <input name="slug" defaultValue={cat.slug ?? ""} className="border rounded px-3 py-2" />
              </div>
              <button className="border rounded px-3 py-2">Save</button>
            </form>

            {/* Toggle Active */}
            <form action={toggleActiveAction} className="ml-0 sm:ml-auto">
              <input type="hidden" name="id" value={cat.id} />
              <input type="hidden" name="nextActive" value={(!cat.active).toString()} />
              <button className="border rounded px-3 py-2">
                {cat.active ? "Deactivate" : "Activate"}
              </button>
            </form>

            {/* Delete */}
            <form action={deleteCategoryAction}>
              <input type="hidden" name="id" value={cat.id} />
              <button className="border rounded px-3 py-2">Delete</button>
            </form>
          </div>
        ))}

        {categories.length === 0 && (
          <div className="p-4 text-center opacity-70 border rounded-2xl">No categories yet.</div>
        )}
      </div>
    </div>
  );
}

===== FILE: sliptail-frontend\src\app\admin\creators\page.tsx =====

import { cookies } from "next/headers";
import { revalidatePath } from "next/cache";

interface PageProps {
  searchParams?: {
    query?: string;
    only_active?: string; // "true" | "false"
  };
}

type UserRole = "admin" | "creator" | "user" | "ADMIN" | "CREATOR" | "USER";

interface AdminCreator {
  id: number;                 // users.id
  email: string;
  username: string | null;
  role: UserRole;

  user_active: boolean;       // users.is_active
  creator_active: boolean;    // creator_profiles.is_active
  is_featured: boolean;       // creator_profiles.is_featured

  display_name: string | null;
  created_at: string;         // creator_profiles.created_at
  updated_at: string;         // creator_profiles.updated_at
}

interface CreatorsResponse {
  creators: AdminCreator[];
}

async function fetchCreators(query = "", onlyActive = true): Promise<AdminCreator[]> {
  const base = process.env.NEXT_PUBLIC_API_BASE!;
  const params = new URLSearchParams();
  if (query) params.set("query", query);
  if (onlyActive) params.set("only_active", "true");

  const cookieHeader = cookies().toString();

  const res = await fetch(`${base}/api/admin/creators?${params.toString()}`, {
    cache: "no-store",
    headers: {
      Cookie: cookieHeader,
    },
  });
  if (!res.ok) throw new Error("Failed to load creators");
  const data: CreatorsResponse = await res.json();
  return data.creators;
}

/** Server Action: feature creator (PATCH alias supported by your backend) */
export async function featureCreatorAction(formData: FormData): Promise<void> {
  "use server";
  const idRaw = formData.get("id");
  const id = Number(idRaw);
  if (!Number.isFinite(id)) return;

  const base = process.env.NEXT_PUBLIC_API_BASE!;
  const cookieHeader = cookies().toString();

  await fetch(`${base}/api/admin/creators/${id}/feature`, {
    method: "PATCH",
    headers: { Cookie: cookieHeader },
  }).catch(() => { /* swallow; UI stays consistent via revalidate */ });

  revalidatePath("/admin/creators");
}

/** Server Action: unfeature creator */
export async function unfeatureCreatorAction(formData: FormData): Promise<void> {
  "use server";
  const idRaw = formData.get("id");
  const id = Number(idRaw);
  if (!Number.isFinite(id)) return;

  const base = process.env.NEXT_PUBLIC_API_BASE!;
  const cookieHeader = cookies().toString();

  await fetch(`${base}/api/admin/creators/${id}/unfeature`, {
    method: "POST",
    headers: { Cookie: cookieHeader },
  }).catch(() => {});

  revalidatePath("/admin/creators");
}

/** Server Action: hard-delete creator (and dependents) */
export async function deleteCreatorAction(formData: FormData): Promise<void> {
  "use server";
  const idRaw = formData.get("id");
  const id = Number(idRaw);
  if (!Number.isFinite(id)) return;

  const base = process.env.NEXT_PUBLIC_API_BASE!;
  const cookieHeader = cookies().toString();

  await fetch(`${base}/api/admin/creators/${id}`, {
    method: "DELETE",
    headers: { Cookie: cookieHeader },
  }).catch(() => {});

  revalidatePath("/admin/creators");
}

export default async function CreatorsPage({ searchParams }: PageProps) {
  const query = searchParams?.query ?? "";
  const onlyActive = (searchParams?.only_active ?? "true") === "true";

  const creators = await fetchCreators(query, onlyActive);

  return (
    <div className="space-y-4">
      <h2 className="text-xl font-semibold">Creators</h2>

      {/* Filters */}
      <form method="GET" className="flex flex-wrap items-end gap-2">
        <div className="flex flex-col">
          <label className="text-sm opacity-70">Search</label>
          <input
            name="query"
            defaultValue={query}
            placeholder="email, username, or display name"
            className="border rounded px-3 py-2"
          />
        </div>
        <div className="flex items-center gap-2">
          <input
            id="only_active"
            type="checkbox"
            name="only_active"
            value="true"
            defaultChecked={onlyActive}
          />
          <label htmlFor="only_active" className="text-sm">Only active</label>
        </div>
        <button className="border rounded px-3 py-2">Apply</button>
      </form>

      {/* Table */}
      <div className="overflow-x-auto">
        <table className="min-w-full text-sm">
          <thead>
            <tr className="border-b">
              <th className="text-left p-2">ID</th>
              <th className="text-left p-2">Email</th>
              <th className="text-left p-2">Username</th>
              <th className="text-left p-2">Display</th>
              <th className="text-left p-2">Role</th>
              <th className="text-left p-2">User Active</th>
              <th className="text-left p-2">Creator Active</th>
              <th className="text-left p-2">Featured</th>
              <th className="text-left p-2">Actions</th>
            </tr>
          </thead>
          <tbody>
            {creators.map((c) => (
              <tr key={c.id} className="border-b">
                <td className="p-2">{c.id}</td>
                <td className="p-2">{c.email}</td>
                <td className="p-2">{c.username ?? "—"}</td>
                <td className="p-2">{c.display_name ?? "—"}</td>
                <td className="p-2">{String(c.role).toUpperCase()}</td>
                <td className="p-2">{c.user_active ? "Yes" : "No"}</td>
                <td className="p-2">{c.creator_active ? "Yes" : "No"}</td>
                <td className="p-2">{c.is_featured ? "Yes" : "No"}</td>
                <td className="p-2">
                  <div className="flex gap-2">
                    {!c.is_featured ? (
                      <form action={featureCreatorAction}>
                        <input type="hidden" name="id" value={c.id} />
                        <button className="rounded px-3 py-1 border hover:bg-gray-50">
                          Feature
                        </button>
                      </form>
                    ) : (
                      <form action={unfeatureCreatorAction}>
                        <input type="hidden" name="id" value={c.id} />
                        <button className="rounded px-3 py-1 border hover:bg-gray-50">
                          Unfeature
                        </button>
                      </form>
                    )}
                    <form action={deleteCreatorAction}>
                      <input type="hidden" name="id" value={c.id} />
                      <button className="rounded px-3 py-1 border hover:bg-gray-50">
                        Delete (hard)
                      </button>
                    </form>
                  </div>
                </td>
              </tr>
            ))}
            {creators.length === 0 && (
              <tr>
                <td className="p-4 text-center opacity-70" colSpan={9}>
                  No creators found.
                </td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
}


===== FILE: sliptail-frontend\src\app\admin\page.tsx =====

"use client";

import Link from "next/link";

export default function AdminHome() {
  return (
    <div className="space-y-4">
      <h1 className="text-2xl font-semibold">Admin Portal</h1>
      <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
        <Link href="/admin/users" className="border rounded-2xl p-4 shadow hover:shadow-md">
          <div className="text-lg font-medium">Users</div>
          <div className="text-sm opacity-70">View & delete users</div>
        </Link>
        <Link href="/admin/creators" className="border rounded-2xl p-4 shadow hover:shadow-md">
          <div className="text-lg font-medium">Creators</div>
          <div className="text-sm opacity-70">Feature creators</div>
        </Link>
        <Link href="/admin/categories" className="border rounded-2xl p-4 shadow hover:shadow-md">
          <div className="text-lg font-medium">Categories</div>
          <div className="text-sm opacity-70">Add / Edit / Remove</div>
        </Link>
      </div>
    </div>
  );
}

===== FILE: sliptail-frontend\src\app\admin\users\page.tsx =====

import { cookies } from "next/headers";
import { revalidatePath } from "next/cache";
import { apiUrl } from "../_lib/api";

export const dynamic = "force-dynamic";

type RoleFilter = "ALL" | "ADMIN" | "CREATOR" | "USER";

interface AdminUser {
  id: number;
  email: string;
  username: string | null;
  role: "admin" | "creator" | "user" | "ADMIN" | "CREATOR" | "USER";
  is_active: boolean;
  email_verified_at: string | null;
  created_at: string;
}

interface UsersResponse {
  users: AdminUser[];
}

interface PageProps {
  searchParams?: {
    role?: RoleFilter;
    query?: string;
    only_active?: string; // "true" | "false"
    limit?: string;
    offset?: string;
  };
}

/** Build headers that forward auth to the backend (Cookie + optional Bearer). */
async function buildAuthHeaders(): Promise<HeadersInit> {
  const store = await cookies();
  const all = store.getAll(); // [{ name, value }, ...]
  const token = store.get("token")?.value;

  const cookieHeader = all
    .map(({ name, value }) => `${name}=${encodeURIComponent(value)}`)
    .join("; ");

  const headers: Record<string, string> = {};
  if (cookieHeader) headers["Cookie"] = cookieHeader;
  if (token) headers["Authorization"] = `Bearer ${token}`;
  return headers;
}

async function fetchUsers(role: RoleFilter, query = "", onlyActive = true): Promise<{ data: AdminUser[]; error?: string }> {
  const url = await apiUrl("/api/admin/users", {
    role,
    query: query || undefined,
    only_active: onlyActive ? "true" : undefined,
  });

  try {
    const res = await fetch(url, {
      cache: "no-store",
      headers: await buildAuthHeaders(),
    });

    if (!res.ok) {
      const bodyText = await res.text().catch(() => "");
      const msg = `HTTP ${res.status} ${res.statusText} — ${bodyText.slice(0, 200)}`;
      // eslint-disable-next-line no-console
      console.error("Admin users fetch failed", { url, msg });
      return { data: [], error: msg };
    }

    const data: UsersResponse = await res.json();
    return { data: data.users };
  } catch (err) {
    const msg = err instanceof Error ? err.message : "Network error";
    // eslint-disable-next-line no-console
    console.error("Admin users fetch error", { url, msg });
    return { data: [], error: msg };
  }
}

/** Server Action: delete a user by id (hard delete on your backend) */
export async function deleteUserAction(formData: FormData) {
  "use server";
  const idRaw = formData.get("id");
  const id = Number(idRaw);
  if (!Number.isFinite(id)) return;

  const url = await apiUrl(`/api/admin/users/${id}`);

  const res = await fetch(url, {
    method: "DELETE",
    headers: await buildAuthHeaders(),
  });

  if (!res.ok) {
    let body: unknown = undefined;
    try { body = await res.json(); } catch {}
    // eslint-disable-next-line no-console
    console.error("deleteUserAction error:", {
      url,
      status: res.status,
      statusText: res.statusText,
      body,
    });
  }

  revalidatePath("/admin/users");
}

export default async function UsersPage({ searchParams }: PageProps) {
  const role = (searchParams?.role ?? "ALL") as RoleFilter;
  const query = searchParams?.query ?? "";
  const onlyActive = (searchParams?.only_active ?? "true") === "true";

  const { data: users, error } = await fetchUsers(role, query, onlyActive);

  return (
    <div className="space-y-4">
      <h2 className="text-xl font-semibold">Users</h2>

      {error && (
        <div className="rounded-xl border p-3 text-sm text-red-700 bg-red-50">
          <div className="font-medium mb-1">Couldn’t load users</div>
          <div className="opacity-80 break-all">{error}</div>
          <div className="opacity-60 mt-1">
            Tip: ensure you’re logged in as an <b>admin</b> and that your backend is reachable at <code>NEXT_PUBLIC_API_BASE</code> (or dev fallback).
          </div>
        </div>
      )}

      {/* Filters */}
      <form method="GET" className="flex flex-wrap items-end gap-2">
        <div className="flex flex-col">
          <label className="text-sm opacity-70">Role</label>
          <select name="role" defaultValue={role} className="border rounded px-3 py-2">
            <option value="ALL">All</option>
            <option value="USER">User</option>
            <option value="CREATOR">Creator</option>
            <option value="ADMIN">Admin</option>
          </select>
        </div>
        <div className="flex flex-col">
          <label className="text-sm opacity-70">Search</label>
          <input
            name="query"
            defaultValue={query}
            placeholder="email or username"
            className="border rounded px-3 py-2"
          />
        </div>
        <div className="flex items-center gap-2">
          <input
            id="only_active"
            type="checkbox"
            name="only_active"
            value="true"
            defaultChecked={onlyActive}
          />
          <label htmlFor="only_active" className="text-sm">Only active</label>
        </div>
        <button className="border rounded px-3 py-2">Apply</button>
      </form>

      {/* Table */}
      <div className="overflow-x-auto">
        <table className="min-w-full text-sm">
          <thead>
            <tr className="border-b">
              <th className="text-left p-2">ID</th>
              <th className="text-left p-2">Email</th>
              <th className="text-left p-2">Username</th>
              <th className="text-left p-2">Role</th>
              <th className="text-left p-2">Active</th>
              <th className="text-left p-2">Joined</th>
              <th className="text-left p-2">Actions</th>
            </tr>
          </thead>
          <tbody>
            {users.map((u) => (
              <tr key={u.id} className="border-b">
                <td className="p-2">{u.id}</td>
                <td className="p-2">{u.email}</td>
                <td className="p-2">{u.username ?? "—"}</td>
                <td className="p-2">{String(u.role).toUpperCase()}</td>
                <td className="p-2">{u.is_active ? "Yes" : "No"}</td>
                <td className="p-2">{new Date(u.created_at).toLocaleDateString()}</td>
                <td className="p-2">
                  <form action={deleteUserAction}>
                    <input type="hidden" name="id" value={u.id} />
                    <button className="rounded px-3 py-1 border hover:bg-gray-50">
                      Delete (hard)
                    </button>
                  </form>
                </td>
              </tr>
            ))}
            {users.length === 0 && !error && (
              <tr>
                <td className="p-4 text-center opacity-70" colSpan={7}>
                  No users found.
                </td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
}


===== FILE: sliptail-frontend\src\app\admin\_lib\api.ts =====

// app/admin/_lib/api.ts
import { headers } from "next/headers";

export async function getApiBase(): Promise<string> {
  const env = process.env.NEXT_PUBLIC_API_BASE?.trim();
  if (env) return env.replace(/\/$/, "");

  const h = await headers();
  const hostHeader = h.get("x-forwarded-host") ?? h.get("host") ?? "";
  const protoRaw = h.get("x-forwarded-proto");
  const proto = protoRaw?.split(",")[0]?.trim() || "http";

  // Dev-friendly fallback: if you're on localhost and didn't set the env,
  // assume API is on :5000 (change DEV_API_PORT to override).
  if (/localhost|127\.0\.0\.1/i.test(hostHeader)) {
    const devPort = (process.env.DEV_API_PORT || "5000").trim();
    return `${proto}://localhost:${devPort}`;
  }

  if (!hostHeader) {
    throw new Error(
      "API base could not be determined. Set NEXT_PUBLIC_API_BASE or ensure host headers are forwarded."
    );
  }
  return `${proto}://${hostHeader}`;
}

type QsValue = string | number | boolean | null | undefined;
type Qs = Record<string, QsValue>;

export async function apiUrl(path: string, qs?: Qs): Promise<string> {
  const base = await getApiBase();
  const url = new URL(path.startsWith("/") ? path : `/${path}`, base);
  if (qs) {
    for (const [k, v] of Object.entries(qs)) {
      if (v === undefined || v === null || v === "") continue;
      url.searchParams.set(k, String(v));
    }
  }
  return url.toString();
}

===== FILE: sliptail-frontend\src\app\auth\forgot-password\page.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useSearchParams } from "next/navigation";

export default function ForgotPasswordPage() {
  const search = useSearchParams();
  const prefill = search.get("email") || "";

  const [email, setEmail] = useState(prefill);
  const [sent, setSent] = useState(false);
  const [loading, setLoading] = useState(false);
  const [err, setErr] = useState<string | null>(null);

  useEffect(() => {
    if (prefill) setEmail(prefill);
  }, [prefill]);

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault();
    setErr(null);
    setSent(false);
    setLoading(true);
    try {
      // Adjust the endpoint to match your backend.
      const res = await fetch("/api/auth/password/reset/start", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify({ email: email.trim() }),
      });

      // For security, don’t reveal whether the email exists.
      if (!res.ok) {
        const text = await res.text().catch(() => "");
        if (text) console.warn("reset/start:", text);
      }

      setSent(true);
    } catch (_err) {
      // `_err` name avoids eslint unused-var warning
      console.error("Forgot password error:", _err);
      setErr("Something went wrong. Please try again.");
    } finally {
      setLoading(false);
    }
  }

  return (
    <main className="mx-auto max-w-sm px-4 py-10 space-y-4">
      <h1 className="text-2xl font-semibold">Reset your password</h1>
      <p className="text-sm text-neutral-600">
        Enter the email associated with your account and we will send you a link
        to reset your password.
      </p>

      <form onSubmit={onSubmit} className="space-y-3">
        <div>
          <label
            htmlFor="reset-email"
            className="block text-xs font-medium text-neutral-700"
          >
            Email
          </label>
          <input
            id="reset-email"
            type="email"
            className="mt-1 w-full rounded-xl border px-3 py-2"
            placeholder="you@example.com"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            autoComplete="email"
            required
          />
        </div>

        {err && <div className="text-sm text-red-600">{err}</div>}

        <button
          type="submit"
          disabled={loading}
          className="w-full rounded-xl bg-black py-2 text-white disabled:opacity-50"
        >
          {loading ? "Sending…" : "Send reset email"}
        </button>
      </form>

      {sent && (
        <div className="rounded-xl border p-3 text-sm text-neutral-700">
          If an account exists for <strong>{email}</strong>, we’ve sent a reset
          link. Please check your inbox.
        </div>
      )}
    </main>
  );
}


===== FILE: sliptail-frontend\src\app\auth\login\page.tsx =====

"use client";

import { useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import Link from "next/link";
import { mutate } from "swr";
import { useAuth } from "@/components/auth/AuthProvider";
import PasswordField from "@/components/forms/PasswordField";

export default function LoginPage() {
  const router = useRouter();
  const search = useSearchParams();
  const next = search.get("next") || "/";
  const { login } = useAuth();

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [err, setErr] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const [verifyOpen, setVerifyOpen] = useState(false);
  const [resent, setResent] = useState(false);

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault();
    setErr(null);
    setLoading(true);
    try {
      // AuthProvider should store token + user (local)
      await login(email, password);

      // Immediately revalidate Navbar data (server-truth)
      await Promise.allSettled([
        mutate("/api/auth/me"),           // user session
        mutate("/api/me/creator-status"), // creator activation
      ]);

      // Navigate and force a refresh so the header re-renders
      router.replace(next || "/");
      router.refresh();
    } catch (error: unknown) {
      const msg = error instanceof Error ? error.message : "Login failed";
      if (msg.toLowerCase().includes("verify")) {
        setVerifyOpen(true);
      } else {
        setErr(msg);
      }
    } finally {
      setLoading(false);
    }
  }

  async function resend() {
    setErr(null);
    setResent(false);
    try {
      await fetch(`/api/auth/verify/resend`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify({ email }),
      });
      setResent(true);
    } catch {
      setResent(false);
    }
  }

  function googleAuth() {
    const qs = next ? `?next=${encodeURIComponent(next)}` : "";
    window.location.href = `/api/auth/google/start${qs}`;
  }

  function goForgotPassword() {
    const emailParam = email ? `?email=${encodeURIComponent(email)}` : "";
    window.location.href = `/auth/forgot-password${emailParam}`;
  }

  return (
    <main className="mx-auto max-w-sm px-4 py-10 space-y-4">
      <h1 className="text-2xl font-bold">Log in</h1>

      <form onSubmit={onSubmit} className="space-y-3">
        <div>
          <label className="block text-xs font-medium text-neutral-700" htmlFor="email">
            Email
          </label>
          <input
            id="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            type="email"
            placeholder="you@example.com"
            className="mt-1 w-full rounded-xl border px-3 py-2"
            autoComplete="email"
            required
          />
        </div>

        <PasswordField
          id="password"
          label="Password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          placeholder="••••••••"
          autoComplete="current-password"
        />

        {err && <div className="text-sm text-red-600">{err}</div>}

        <button disabled={loading} className="w-full rounded-xl bg-black py-2 text-white">
          {loading ? "Signing in…" : "Sign in"}
        </button>

        {/* Forgot password link */}
        <div className="text-sm text-center">
          <button
            type="button"
            onClick={goForgotPassword}
            className="underline"
          >
            Forgot your password?
          </button>
        </div>
      </form>

      <button
        onClick={googleAuth}
        className="w-full rounded-xl border py-2 text-sm"
        aria-label="Continue with Google"
        type="button"
      >
        Continue with Google
      </button>

      <div className="text-sm text-center">
        Don’t have an account{" "}
        <Link
          className="underline"
          href={`/auth/signup${next ? `?next=${encodeURIComponent(next)}` : ""}`}
        >
          Create one
        </Link>
      </div>

      {/* Verify modal */}
      {verifyOpen && (
        <div className="fixed inset-0 z-50 bg-black/40 flex items-center justify-center p-4">
          <div className="w-full max-w-md rounded-2xl bg-white p-4 space-y-3">
            <h3 className="text-lg font-semibold">Please verify your email</h3>
            <p className="text-sm text-neutral-700">
              We sent a verification link to <strong>{email}</strong>. Click the link, then try again.
            </p>
            <div className="flex items-center gap-2">
              <button onClick={resend} className="rounded-xl border px-3 py-1 text-sm">
                Resend verification email
              </button>
              {resent && <span className="text-sm text-green-700">Sent!</span>}
            </div>
            <div className="flex justify-end">
              <button onClick={() => setVerifyOpen(false)} className="rounded-xl border px-3 py-1 text-sm">
                Close
              </button>
            </div>
          </div>
        </div>
      )}
    </main>
  );
}


===== FILE: sliptail-frontend\src\app\auth\signup\page.tsx =====

"use client";

import { useState } from "react";
import { useSearchParams } from "next/navigation";
import Link from "next/link";
import { useAuth } from "@/components/auth/AuthProvider";
import PasswordField from "@/components/forms/PasswordField";

export default function SignupPage() {
  const { signup, loading } = useAuth();
  const search = useSearchParams();
  const next = search.get("next") || "/";

  const [email, setEmail] = useState("");
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [done, setDone] = useState(false);
  const [err, setErr] = useState<string | null>(null);

  const submit = async (e: React.FormEvent) => {
    e.preventDefault();
    setErr(null);
    try {
      await signup(email.trim(), password, username.trim() || undefined);
      setDone(true);
      // If backend returns a verify session, you can redirect to a "check email" flow here.
    } catch (e: unknown) {
      if (
        e &&
        typeof e === "object" &&
        "message" in e &&
        typeof (e as { message?: unknown }).message === "string"
      ) {
        setErr((e as { message: string }).message);
      } else {
        setErr("Signup failed");
      }
    }
  };

  function googleAuth() {
    const qs = next ? `?next=${encodeURIComponent(next)}` : "";
    window.location.href = `/api/auth/google/start${qs}`;
  }

  if (done) {
    return (
      <main className="p-6 max-w-md mx-auto">
        <h1 className="text-xl font-semibold mb-2">Check your email</h1>
        <p>We sent you a verification link to complete sign up.</p>
        <p className="mt-3 text-sm">
          Already verified?{" "}
          <Link
            className="underline"
            href={`/auth/login${next ? `?next=${encodeURIComponent(next)}` : ""}`}
          >
            Log in
          </Link>
        </p>
      </main>
    );
  }

  return (
    <main className="p-6 max-w-md mx-auto space-y-4">
      <h1 className="text-xl font-semibold">Sign up</h1>

      <form onSubmit={submit} className="space-y-3">
        <div>
          <label htmlFor="signup-email" className="block text-xs font-medium text-neutral-700">
            Email
          </label>
          <input
            id="signup-email"
            className="mt-1 w-full border rounded px-3 py-2"
            placeholder="you@example.com"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            autoComplete="email"
            required
          />
        </div>

        <div>
          <label htmlFor="signup-username" className="block text-xs font-medium text-neutral-700">
            Username (optional)
          </label>
          <input
            id="signup-username"
            className="mt-1 w-full border rounded px-3 py-2"
            placeholder="yourname"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
            autoComplete="username"
          />
        </div>

        <PasswordField
          id="signup-password"
          label="Create a password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          placeholder="At least 8 characters"
          autoComplete="new-password"
          required
        />

        {err && <p className="text-red-600 text-sm">{err}</p>}

        <button
          disabled={loading}
          className="w-full px-4 py-2 rounded bg-black text-white disabled:opacity-50"
        >
          {loading ? "…" : "Create account"}
        </button>
      </form>

      <div className="flex items-center justify-center gap-3 text-xs text-neutral-500">
        <span className="flex-1 h-px bg-neutral-200" />
        or
        <span className="flex-1 h-px bg-neutral-200" />
      </div>

      <button
        onClick={googleAuth}
        className="w-full rounded border py-2 text-sm"
        aria-label="Continue with Google"
        type="button"
      >
        Continue with Google
      </button>

      <p className="mt-3 text-sm">
        Already have an account?{" "}
        <Link
          className="underline"
          href={`/auth/login${next ? `?next=${encodeURIComponent(next)}` : ""}`}
        >
          Log in
        </Link>
      </p>
    </main>
  );
}


===== FILE: sliptail-frontend\src\app\checkout\success\page.tsx =====

// app/checkout/success/page.tsx
"use client";

import { useEffect, useMemo } from "react";
import { useRouter, useSearchParams } from "next/navigation";

// Replace this with your actual toast system
function useToast() {
  return {
    success: (msg: string) => console.log("[TOAST SUCCESS]", msg),
    error: (msg: string) => console.error("[TOAST ERROR]", msg),
  };
}

const API_BASE =
  process.env.NEXT_PUBLIC_API_BASE_URL?.replace(/\/$/, "") || "";

type FinalizeResponse =
  | {
      ok: true;
      type: "purchase" | "membership" | "request";
      creatorDisplayName: string;
      orderId: number;
    }
  | { ok: false; error: string };

export default function CheckoutSuccessPage() {
  const search = useSearchParams();
  const router = useRouter();
  const { success, error } = useToast();
  const sessionId = useMemo(
    () => search.get("session_id") || search.get("sessionId"),
    [search]
  );

  useEffect(() => {
    async function finalize() {
      if (!sessionId) {
        error("Missing Stripe session id.");
        router.replace("/purchases");
        return;
      }

      try {
        const res = await fetch(
          `${API_BASE}/api/stripe-checkout/finalize?session_id=${encodeURIComponent(sessionId)}`,
          { credentials: "include" }
        );
        const payload: FinalizeResponse = await res.json();

        if (!payload.ok) {
          error(payload.error || "Something went wrong finalizing your order.");
          router.replace("/purchases");
          return;
        }

        const msg =
          payload.type === "request"
            ? `Thanks for Supporting ${payload.creatorDisplayName}`
            : `Purchase Successful, Thanks for Supporting ${payload.creatorDisplayName}`;

        // Use flash-based toast so green check appears globally after redirect
        try {
          const { setFlash } = await import("@/lib/flash");
          setFlash({ kind: "success", title: msg, ts: Date.now() });
        } catch {}

        if (payload.type === "request") {
          router.replace(`/requests/new?orderId=${payload.orderId}`);
        } else {
          router.replace(`/purchases`);
        }
      } catch (e: unknown) {
        console.error("Finalize error:", e);
        error("Could not finalize your order.");
        router.replace("/purchases");
      }
    }

    finalize();
  }, [sessionId, router, error, success]);
  return (
    <div className="mx-auto max-w-xl p-8 text-center">
      <h1 className="text-2xl font-semibold">Finishing up…</h1>
      <p className="mt-2 text-neutral-600">
        Confirming your purchase with Stripe.
      </p>
      <div className="mt-6 h-2 w-40 mx-auto animate-pulse rounded bg-green-500/40" />
    </div>
  );
}


===== FILE: sliptail-frontend\src\app\creator\setup\page.tsx =====

"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import useSWR from "swr";
import Link from "next/link";
import { useRouter, useSearchParams } from "next/navigation";

/* ----------------------------- Types ----------------------------- */

type CreatorStatus = {
  profileComplete: boolean;
  stripeConnected: boolean;
  hasPublishedProduct: boolean;
  isActive: boolean;
};

type Category = { id: number; name: string; slug: string };

/* --------------------------- Fetch helpers --------------------------- */

function loadAuthSafe(): { token?: string } | null {
  try {
    const raw = localStorage.getItem("auth");
    return raw ? JSON.parse(raw) : null;
  } catch {
    return null;
  }
}

const fetcher = async <T,>(url: string): Promise<T> => {
  let token: string | null = null;
  try {
    token = loadAuthSafe()?.token ?? null;
  } catch {
    token = null;
  }
  const headers: Record<string, string> = {};
  if (token) headers.Authorization = `Bearer ${token}`;

  const res = await fetch(url, { credentials: "include", headers });
  if (!res.ok) throw new Error(String(res.status));
  return (await res.json()) as T;
};

/* ------------------------------ Page ------------------------------ */

export default function CreatorSetupPage() {
  const router = useRouter();
  const search = useSearchParams();

  // Current activation status
  const {
    data: status,
    mutate: mutateStatus,
    isLoading: loadingStatus,
  } = useSWR<CreatorStatus>("/api/me/creator-status", fetcher, {
    revalidateOnFocus: true,
  });

  // Categories: unwrap `{ categories: [...] }` → `Category[]`
  const { data: catResp } = useSWR<{ categories: Category[] }>(
    "/api/categories",
    fetcher
  );
  const allCats: Category[] = Array.isArray(catResp?.categories)
    ? catResp!.categories
    : [];

  // Profile form
  const [displayName, setDisplayName] = useState("");
  const [bio, setBio] = useState("");
  const [categories, setCategories] = useState<number[]>([]);

  // uploads + previews
  const [profileImage, setProfileImage] = useState<File | null>(null);
  const [profilePreview, setProfilePreview] = useState<string | null>(null);

  const [galleryFiles, setGalleryFiles] = useState<File[]>([]);
  const [galleryPreviews, setGalleryPreviews] = useState<string[]>([]);
  const galleryInputRef = useRef<HTMLInputElement | null>(null);

  const [saving, setSaving] = useState(false);
  const [saveError, setSaveError] = useState<string | null>(null);
  const [syncingStripe, setSyncingStripe] = useState(false);

  // If returning from Stripe (?onboarded=1 or ?refresh=1): sync & clean URL
  useEffect(() => {
    const onboarded = search.get("onboarded");
    const refresh = search.get("refresh");
    if (onboarded === "1" || refresh === "1") {
      (async () => {
        let token: string | null = null;
        try {
          token = loadAuthSafe()?.token ?? null;
        } catch {
          token = null;
        }
        const headers: Record<string, string> = { "Content-Type": "application/json" };
        if (token) headers.Authorization = `Bearer ${token}`;

        try {
          await fetch("/api/stripe-connect/sync", {
            method: "POST",
            credentials: "include",
            headers,
          }).catch(() => null);
          await mutateStatus(); // refresh status
        } finally {
          const url = new URL(window.location.href);
          url.searchParams.delete("onboarded");
          url.searchParams.delete("refresh");
          window.history.replaceState({}, "", url.toString());
        }
      })();
    }
  }, [search, mutateStatus]);

  // Manual Stripe sync (button)
  async function syncStripeNow() {
    setSyncingStripe(true);
    try {
      let token: string | null = null;
      try {
        token = loadAuthSafe()?.token ?? null;
      } catch {
        token = null;
      }
      const headers: Record<string, string> = { "Content-Type": "application/json" };
      if (token) headers.Authorization = `Bearer ${token}`;

      await fetch("/api/stripe-connect/sync", {
        method: "POST",
        credentials: "include",
        headers,
      });
      await mutateStatus();
    } catch {
      // noop
    } finally {
      setSyncingStripe(false);
    }
  }

  // If status flips active (auto-activation after publish), redirect to dashboard
  useEffect(() => {
    if (status?.isActive) {
      router.replace("/dashboard");
      router.refresh();
    }
  }, [status?.isActive, router]);

  /* ------------------------------ Upload handlers ------------------------------ */

  function onPickProfile(e: React.ChangeEvent<HTMLInputElement>) {
    const f = e.target.files?.[0] || null;
    setProfileImage(f || null);
    if (f) {
      const url = URL.createObjectURL(f);
      setProfilePreview((prev) => {
        if (prev) URL.revokeObjectURL(prev);
        return url;
      });
    } else {
      if (profilePreview) URL.revokeObjectURL(profilePreview);
      setProfilePreview(null);
    }
  }

  const MAX_GALLERY = 4;

  function onPickGallery(e: React.ChangeEvent<HTMLInputElement>) {
    const incoming = Array.from(e.target.files || []);
    if (incoming.length === 0) return;

    const remaining = Math.max(0, MAX_GALLERY - galleryFiles.length);
    if (remaining === 0) {
      if (galleryInputRef.current) galleryInputRef.current.value = "";
      return;
    }

    const toAdd = incoming.slice(0, remaining);
    setGalleryFiles((prev) => [...prev, ...toAdd]);
    const newPreviews = toAdd.map((f) => URL.createObjectURL(f));
    setGalleryPreviews((prev) => [...prev, ...newPreviews]);
    if (galleryInputRef.current) galleryInputRef.current.value = "";
  }

  function removeGalleryAt(idx: number) {
    const nextFiles = galleryFiles.filter((_, i) => i !== idx);
    const nextPreviews = galleryPreviews.filter((_, i) => i !== idx);
    if (galleryPreviews[idx]) URL.revokeObjectURL(galleryPreviews[idx]);
    setGalleryFiles(nextFiles);
    setGalleryPreviews(nextPreviews);
  }

  function moveGallery(from: number, to: number) {
    if (to < 0 || to >= galleryFiles.length) return;
    const files = [...galleryFiles];
    const previews = [...galleryPreviews];
    const [f] = files.splice(from, 1);
    const [p] = previews.splice(from, 1);
    files.splice(to, 0, f);
    previews.splice(to, 0, p);
    setGalleryFiles(files);
    setGalleryPreviews(previews);
  }

  useEffect(() => {
    return () => {
      if (profilePreview) URL.revokeObjectURL(profilePreview);
      galleryPreviews.forEach((p) => URL.revokeObjectURL(p));
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  /* ------------------------------ Save profile ------------------------------ */

  const missingRequired =
    !displayName.trim() || !bio.trim() || !profileImage || galleryFiles.length !== 4;

  async function saveProfile() {
    setSaveError(null);

    if (missingRequired) {
      setSaveError(
        !displayName.trim()
          ? "Display name is required."
          : !bio.trim()
          ? "Short bio is required."
          : !profileImage
          ? "Profile image is required."
          : "Please select exactly four gallery photos."
      );
      return;
    }

    setSaving(true);
    try {
      let token: string | null = null;
      try {
        token = loadAuthSafe()?.token ?? null;
      } catch {
        token = null;
      }
      const authHeader: Record<string, string> = {};
      if (token) authHeader.Authorization = `Bearer ${token}`;

      // Build multipart form
      const fd = new FormData();
      fd.append("display_name", displayName.trim());
      fd.append("bio", bio.trim());
      fd.append("profile_image", profileImage as Blob);
      galleryFiles.forEach((f) => fd.append("gallery", f));

      // Try multipart on /me
      let profRes = await fetch("/api/creators/me", {
        method: "POST",
        credentials: "include",
        headers: authHeader,
        body: fd,
      });

      // If backend doesn't accept multipart on /me, fall back to two-step flow
      if (profRes.status === 415 || profRes.status === 400) {
        const upRes = await fetch("/api/creators/me/media", {
          method: "POST",
          credentials: "include",
          headers: authHeader,
          body: fd,
        });

        if (!upRes.ok) {
          const msg = await upRes.text().catch(() => "");
          throw new Error(msg || "Failed to upload images");
        }

        type MediaResp = { profile_image?: string; gallery?: string[] };
        const mediaUnknown: unknown = await upRes.json();
        const media = mediaUnknown as MediaResp;

        const profile_image_url =
          typeof media.profile_image === "string" ? media.profile_image : null;
        const gallery_urls = Array.isArray(media.gallery) ? media.gallery : [];

        profRes = await fetch("/api/creators/me", {
          method: "POST",
          credentials: "include",
          headers: {
            "Content-Type": "application/json",
            ...authHeader,
          },
          body: JSON.stringify({
            display_name: displayName.trim(),
            bio: bio.trim(),
            profile_image: profile_image_url,
            gallery: gallery_urls,
          }),
        });
      }

      // Optimistically mark complete in SWR, then confirm below
      void mutateStatus(
        (prev) =>
          prev
            ? {
                ...prev,
                profileComplete: true,
              }
            : prev,
        false
      );

      // Save categories (non-fatal)
      try {
        const catRes = await fetch("/api/creators/me/categories", {
          method: "POST",
          credentials: "include",
          headers: {
            "Content-Type": "application/json",
            ...(token ? { Authorization: `Bearer ${token}` } : {}),
          },
          body: JSON.stringify({ category_ids: categories }),
        });
        if (!catRes.ok) {
          console.warn("categories save failed:", await catRes.text().catch(() => ""));
        }
      } catch (catErr) {
        console.warn("categories save error:", (catErr as Error)?.message || catErr);
      }

      if (!profRes.ok) {
        await mutateStatus(); // revalidate
        const latest = await fetcher<CreatorStatus>("/api/me/creator-status").catch(
          () => null as unknown as CreatorStatus
        );
        if (latest?.profileComplete) {
          setSaveError(null);
          return;
        }
        const msg = await profRes.text().catch(() => "");
        throw new Error(msg || "Failed to save profile");
      }

      await mutateStatus();
      setSaveError(null);
    } catch (e) {
      setSaveError(e instanceof Error ? e.message : "Save failed");
    } finally {
      setSaving(false);
    }
  }

  async function connectStripe() {
    let token: string | null = null;
    try {
      token = loadAuthSafe()?.token ?? null;
    } catch {
      token = null;
    }
    const headers: Record<string, string> = { "Content-Type": "application/json" };
    if (token) headers.Authorization = `Bearer ${token}`;

    const res = await fetch("/api/stripe-connect/create-link", {
      method: "POST",
      credentials: "include",
      headers,
    });

    if (!res.ok) {
      const msg = await res.text().catch(() => "");
      alert(`Stripe link error: ${res.status} ${msg || ""}`);
      return;
    }
    const data = await res.json().catch(() => null);
    if (data?.url) {
      window.location.href = data.url;
    } else {
      alert("Stripe link response was missing a URL.");
    }
  }

  function toggleCategory(id: number) {
    setCategories((prev) =>
      prev.includes(id) ? prev.filter((x) => x !== id) : [...prev, id]
    );
  }

  const readyForProduct = useMemo(
    () => !!status?.profileComplete && !!status?.stripeConnected,
    [status]
  );

  // Guard Link navigation if not ready
  function onProductLinkClick(e: React.MouseEvent<HTMLAnchorElement>) {
    if (!readyForProduct) {
      e.preventDefault();
      alert("Complete your profile and connect Stripe first.");
    }
  }

  return (
    <main className="mx-auto max-w-3xl px-4 py-8 space-y-8">
      <h1 className="text-2xl font-bold">Creator Setup</h1>

      {/* Step 1: Profile */}
      <section className="rounded-2xl border p-4 space-y-4">
        <header className="flex items-center justify-between">
          <h2 className="text-lg font-semibold">1) Your Profile</h2>
          {status?.profileComplete ? (
            <span className="text-green-700 text-sm">Complete ✓</span>
          ) : (
            <span className="text-orange-700 text-sm">Incomplete</span>
          )}
        </header>

        {/* Display name */}
        <div className="space-y-2">
          <label className="block text-sm font-medium">Display name</label>
          <input
            value={displayName}
            onChange={(e) => setDisplayName(e.target.value)}
            placeholder="How your name appears on your creator card"
            className="w-full rounded-xl border px-3 py-2"
          />
        </div>

        {/* Bio */}
        <div className="space-y-2">
          <label className="block text-sm font-medium">Short bio</label>
          <textarea
            value={bio}
            onChange={(e) => setBio(e.target.value)}
            rows={5}
            placeholder="Short bio to explain who you are…"
            className="w-full rounded-xl border px-3 py-2"
          />
          <div className="text-xs text-neutral-500">
            Keep it concise but descriptive. You can update this anytime.
          </div>
        </div>

        {/* Profile image */}
        <div className="space-y-2">
          <label className="block text-sm font-medium">Profile image (required)</label>
          <div className="flex items-center gap-4">
            <div className="h-20 w-20 overflow-hidden rounded-full border bg-neutral-50">
              {profilePreview ? (
                // eslint-disable-next-line @next/next/no-img-element
                <img
                  src={profilePreview}
                  alt="Profile preview"
                  className="h-full w-full object-cover"
                />
              ) : (
                <div className="flex h-full w-full items-center justify-center text-xs text-neutral-500">
                  Preview
                </div>
              )}
            </div>
            <input type="file" accept="image/*" onChange={onPickProfile} className="text-sm" />
          </div>
        </div>

        {/* Gallery upload */}
        <div className="space-y-2">
          <label className="block text-sm font-medium">
            Back-of-card gallery (4 photos required)
          </label>
          <input
            ref={galleryInputRef}
            type="file"
            accept="image/*"
            multiple
            onChange={onPickGallery}
            className="text-sm"
          />
          <div className="grid grid-cols-2 sm:grid-cols-4 gap-3">
            {Array.from({ length: Math.max(4, galleryPreviews.length) }).map((_, i) => {
              const preview = galleryPreviews[i];
              return (
                <div
                  key={i}
                  className="relative aspect-square overflow-hidden rounded-xl border bg-neutral-50"
                >
                  {preview ? (
                    // eslint-disable-next-line @next/next/no-img-element
                    <img
                      src={preview}
                      alt={`Gallery ${i + 1}`}
                      className="h-full w-full object-cover"
                    />
                  ) : (
                    <div className="flex h-full w-full items-center justify-center text-xs text-neutral-500">
                      {i < 4 ? "Required" : "Extra"}
                    </div>
                  )}
                  {preview && (
                    <div className="absolute inset-x-1 bottom-1 flex items-center justify-between gap-1">
                      <button
                        onClick={() => moveGallery(i, i - 1)}
                        className="rounded bg-white/80 px-2 py-1 text-[10px] shadow"
                      >
                        ←
                      </button>
                      <button
                        onClick={() => removeGalleryAt(i)}
                        className="rounded bg-white/80 px-2 py-1 text-[10px] shadow"
                      >
                        Remove
                      </button>
                      <button
                        onClick={() => moveGallery(i, i + 1)}
                        className="rounded bg-white/80 px-2 py-1 text-[10px] shadow"
                      >
                        →
                      </button>
                    </div>
                  )}
                </div>
              );
            })}
          </div>
          <div className="text-xs text-neutral-500">
            Tip: Pick four photos that represent your style. Reorder with arrows.
          </div>
        </div>

        {/* Categories */}
        <div className="space-y-2">
          <div className="text-sm font-medium">Categories</div>
          <div className="flex flex-wrap gap-2">
            {allCats.map((c) => (
              <button
                key={c.id}
                onClick={() => toggleCategory(c.id)}
                className={`rounded-full border px-3 py-1 text-sm ${
                  categories.includes(c.id) ? "bg-black text-white" : "hover:bg-neutral-100"
                }`}
              >
                {c.name}
              </button>
            ))}
          </div>
        </div>

        {saveError && <div className="text-sm text-red-600">{saveError}</div>}

        <div className="flex gap-2">
          <button
            onClick={saveProfile}
            disabled={saving}
            className="rounded-xl bg-black px-4 py-2 text-white disabled:opacity-60"
          >
            {saving ? "Saving…" : "Save Profile"}
          </button>
        </div>
      </section>

      {/* Step 2: Stripe */}
      <section className="rounded-2xl border p-4 space-y-4">
        <header className="flex items-center justify-between">
          <h2 className="text-lg font-semibold">2) Connect Stripe</h2>
          {status?.stripeConnected ? (
            <span className="text-green-700 text-sm">Connected ✓</span>
          ) : (
            <span className="text-orange-700 text-sm">Not connected</span>
          )}
        </header>
        <p className="text-sm text-neutral-700">
          Payouts are handled via Stripe. You’ll be redirected to finish onboarding.
        </p>
        <div className="flex items-center gap-2">
          <button onClick={connectStripe} className="rounded-xl border px-4 py-2 text-sm">
            Connect Stripe
          </button>
          <button
            onClick={syncStripeNow}
            disabled={syncingStripe}
            className="rounded-xl border px-3 py-2 text-xs disabled:opacity-60"
            title="If Stripe just finished enabling your account, click to refresh status."
          >
            {syncingStripe ? "Syncing…" : "Sync status"}
          </button>
        </div>
      </section>

      {/* Step 3: First Product */}
      <section className="rounded-2xl border p-4 space-y-4">
        <header className="flex items-center justify-between">
          <h2 className="text-lg font-semibold">3) Create Your First Product</h2>
          {status?.hasPublishedProduct ? (
            <span className="text-green-700 text-sm">Published ✓</span>
          ) : (
            <span className="text-orange-700 text-sm">None published</span>
          )}
        </header>
        <p className="text-sm text-neutral-700">
          Once you publish your first product, your creator account will activate automatically and your dashboard/nav will update.
        </p>

        <div className="flex gap-2">
          <Link
            href="/dashboard/products/new?from=setup"
            onClick={onProductLinkClick}
            className={`rounded-xl px-4 py-2 text-sm ${
              readyForProduct ? "bg-black text-white" : "bg-neutral-200 text-neutral-500 cursor-not-allowed"
            }`}
            aria-disabled={!readyForProduct}
          >
            Go to Product Creator
          </Link>
        </div>
        {!readyForProduct && (
          <p className="text-xs text-neutral-600">
            Tip: Complete profile and connect Stripe first to enable product creation.
          </p>
        )}
      </section>

      {/* Status footer */}
      <footer className="text-sm text-neutral-600">
        {status ? (
          <div>
            Status: <strong>{status.isActive ? "Active" : loadingStatus ? "Checking…" : "Pending (complete steps above)"}</strong>
          </div>
        ) : (
          <div>Loading status…</div>
        )}
      </footer>
    </main>
  );
}


===== FILE: sliptail-frontend\src\app\creator\success\page.tsx =====

"use client";
import { useEffect } from "react";

export default function CreatorSuccessPage() {
  useEffect(() => {
    // Let’s nav flip immediately in this session
    localStorage.setItem("creatorSetupDone", "true");
  }, []);

  const handleGoToDashboard = () => {
    try {
      // Mark for one-time hard refresh on dashboard to avoid stale token
      sessionStorage.setItem("refreshOnDashboard", "1");
    } catch {
      // ignore storage errors (Safari private mode, etc.)
    }
    // Full reload ensures the entire app (including nav bar) re-mounts
    window.location.href = "/dashboard?fresh=1";
  };

  return (
    <main className="mx-auto max-w-2xl px-4 py-12">
      <div className="rounded-2xl border p-8 text-center">
        <div className="mx-auto mb-4 h-12 w-12 rounded-full bg-green-100 flex items-center justify-center">
          <span className="text-2xl">✅</span>
        </div>
        <h1 className="text-2xl font-semibold">You’re officially a Creator!</h1>
        <p className="mt-2 text-neutral-600">
          Your first product has been created. You can finish setting up your
          creator space from your dashboard.
        </p>

        <div className="mt-6 flex items-center justify-center">
          <button
            type="button"
            onClick={handleGoToDashboard}
            className="rounded-xl px-4 py-2 text-sm bg-black text-white"
          >
            Next → Dashboard
          </button>
        </div>
      </div>
    </main>
  );
}

===== FILE: sliptail-frontend\src\app\creators\page.tsx =====

"use client";

import { useEffect, useMemo, useState } from "react";
import Image from "next/image";
import Link from "next/link";

/* -------------------------- Types -------------------------- */

type Category = { id: number; name: string; slug: string };
type Creator = {
  creator_id: number;
  display_name: string;
  bio: string | null;
  profile_image: string | null;
  gallery: string[];
  average_rating: number;
  products_count: number;
  categories: { id: number; name: string; slug: string }[];
};
type CreatorsResponse = { creators: Creator[] };
type CategoriesResponse = { categories: Category[] };

/* ----------------------------- Helpers ----------------------------- */

function isRecord(v: unknown): v is Record<string, unknown> {
  return typeof v === "object" && v !== null;
}
function toApiBase(): string {
  return (process.env.NEXT_PUBLIC_API_URL || "http://localhost:5000").replace(/\/$/, "");
}
function resolveImageUrl(src: string | null | undefined, apiBase: string): string | null {
  if (!src) return null;
  let s = src.trim();
  if (s.startsWith("//")) s = s.slice(1);
  if (/^https?:\/\//i.test(s)) return s;
  if (!s.startsWith("/")) s = `/${s}`;
  return `${apiBase}${s}`;
}

/* ----------------------------- Component ---------------------------- */

export default function CreatorsExplorePage() {
  const apiBase = useMemo(() => toApiBase(), []);

  const [categories, setCategories] = useState<Category[]>([]);
  const [catsLoading, setCatsLoading] = useState(true);

  const [creators, setCreators] = useState<Creator[]>([]);
  const [loading, setLoading] = useState(true);

  const [query, setQuery] = useState("");
  const [categoryId, setCategoryId] = useState<number | null>(null);

  const [error, setError] = useState<string | null>(null);

  // Load categories
  useEffect(() => {
    const ac = new AbortController();
    setCatsLoading(true);
    (async () => {
      try {
        const res = await fetch(`${apiBase}/api/categories`, {
          credentials: "include",
          signal: ac.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data: unknown = await res.json();
        if (isRecord(data) && Array.isArray((data as CategoriesResponse).categories)) {
          setCategories((data as CategoriesResponse).categories);
        } else {
          setCategories([]);
        }
      } catch (e) {
        if (!(e instanceof DOMException && e.name === "AbortError")) setCategories([]);
      } finally {
        setCatsLoading(false);
      }
    })();
    return () => ac.abort();
  }, [apiBase]);

  // Load creators whenever query or category changes
  useEffect(() => {
    const ac = new AbortController();
    setLoading(true);
    setError(null);
    (async () => {
      try {
        const params = new URLSearchParams();
        if (query.trim()) params.set("q", query.trim());
        if (categoryId != null) params.set("categoryId", String(categoryId));

        const url = params.toString()
          ? `${apiBase}/api/creators?${params.toString()}`
          : `${apiBase}/api/creators`;

        const res = await fetch(url, { credentials: "include", signal: ac.signal });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data: unknown = await res.json();

        let list: Creator[] = [];
        if (isRecord(data) && Array.isArray((data as CreatorsResponse).creators)) {
          list = (data as CreatorsResponse).creators;
        }

        setCreators(list.filter((cr) => (cr.products_count || 0) > 0));
      } catch (e) {
        if (!(e instanceof DOMException && e.name === "AbortError")) {
          setError("Failed to load creators");
          setCreators([]);
        }
      } finally {
        setLoading(false);
      }
    })();

    return () => ac.abort();
  }, [apiBase, query, categoryId]);

  function onSubmitSearch(e: React.FormEvent) {
    e.preventDefault();
  }

  return (
    <main className="mx-auto max-w-6xl px-4 py-8 space-y-6">
      <header className="space-y-2">
        <h1 className="text-2xl font-bold">Explore creators</h1>
        <p className="text-sm text-neutral-600">
          Discover active creators. Filter by category or search by name.
        </p>
      </header>

      {/* Search bar */}
      <form onSubmit={onSubmitSearch} className="flex items-center gap-2">
        <input
          aria-label="Search creators"
          placeholder="Search creators by name"
          className="w-full rounded-xl border px-3 py-2"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
        />
        <button
          type="submit"
          className="rounded-xl bg-black px-4 py-2 text-sm font-semibold text-white"
        >
          Search
        </button>
      </form>

      {/* Category filter chips */}
      <div className="flex flex-wrap gap-2">
        <button
          type="button"
          aria-pressed={categoryId === null}
          onClick={() => setCategoryId(null)}
          className={`rounded-full border px-3 py-1 text-sm ${
            categoryId === null ? "bg-black text-white border-black" : "hover:bg-neutral-100"
          }`}
        >
          All
        </button>

        {catsLoading ? (
          <span className="text-sm text-neutral-500">Loading categories…</span>
        ) : categories.length ? (
          categories.map((cat) => {
            const active = categoryId === cat.id;
            return (
              <button
                key={cat.id}
                type="button"
                aria-pressed={active}
                onClick={() => setCategoryId(active ? null : cat.id)}
                className={`rounded-full border px-3 py-1 text-sm ${
                  active ? "bg-black text-white border-black" : "hover:bg-neutral-100"
                }`}
                title={cat.name}
              >
                {cat.name}
              </button>
            );
          })
        ) : (
          <span className="text-sm text-neutral-500">No categories available.</span>
        )}
      </div>

      {/* Results */}
      {error && (
        <div className="rounded-xl border border-red-300 bg-red-50 p-3 text-sm text-red-800">
          {error}
        </div>
      )}

      {loading ? (
        <div className="text-sm text-neutral-600">Loading creators…</div>
      ) : creators.length === 0 ? (
        <div className="text-sm text-neutral-600">No matching creators.</div>
      ) : (
        <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
          {creators.map((creator) => {
            const profile = resolveImageUrl(creator.profile_image, apiBase);
            const gallery = (creator.gallery || [])
              .slice(0, 4)
              .map((u) => resolveImageUrl(u, apiBase))
              .filter((u): u is string => !!u);

            const rating =
              typeof creator.average_rating === "number"
                ? Number(creator.average_rating).toFixed(1)
                : "0.0";

            return (
              <div
                key={creator.creator_id}
                className="group relative h-64 rounded-2xl overflow-hidden transition hover:shadow-md"
                style={{ perspective: "1000px", isolation: "isolate" }}
              >
                {/* Flipper (border flips with content) */}
                <div
                  className="flip-inner relative h-full w-full rounded-2xl border transition-transform duration-500"
                  style={{
                    transformStyle: "preserve-3d",
                    WebkitTransformStyle: "preserve-3d",
                    willChange: "transform",
                    transformOrigin: "center center",
                    background: "transparent",
                  }}
                >
                  {/* FRONT face (transparent container) */}
                  <div
                    className="absolute inset-0 rounded-2xl"
                    style={{
                      transform: "rotateY(0deg) translateZ(0.01px)",
                      backfaceVisibility: "hidden",
                      WebkitBackfaceVisibility: "hidden",
                    }}
                  >
                    {/* inset white panel so border isn't covered */}
                    <div className="panel-front absolute inset-[1px] rounded-2xl bg-white p-4 transition-opacity duration-200 opacity-100 group-hover:opacity-0">
                      <div className="flex items-center gap-3">
                        <div className="relative h-12 w-12 overflow-hidden rounded-full bg-neutral-100">
                          {profile ? (
                            <Image
                              src={profile}
                              alt={creator.display_name}
                              fill
                              className="object-cover"
                              unoptimized
                              sizes="48px"
                            />
                          ) : null}
                        </div>
                        <div>
                          <div className="font-semibold">{creator.display_name}</div>
                          <div className="text-xs text-neutral-600">
                            {rating} ★ · {creator.products_count} product
                            {creator.products_count === 1 ? "" : "s"}
                          </div>
                        </div>
                      </div>

                      {creator.categories?.length ? (
                        <div className="mt-3 flex flex-wrap gap-1">
                          {creator.categories.slice(0, 3).map((c) => (
                            <span
                              key={c.id}
                              className="rounded-full border px-2 py-0.5 text-xs text-neutral-700"
                            >
                              {c.name}
                            </span>
                          ))}
                          {creator.categories.length > 3 && (
                            <span className="text-xs text-neutral-500">
                              +{creator.categories.length - 3} more
                            </span>
                          )}
                        </div>
                      ) : null}

                      {creator.bio ? (
                        <p className="mt-3 line-clamp-4 text-sm text-neutral-700">
                          {creator.bio}
                        </p>
                      ) : null}
                    </div>
                  </div>

                  {/* BACK face (transparent container) */}
                  <div
                    className="absolute inset-0 rounded-2xl"
                    style={{
                      transform: "rotateY(180deg) translateZ(0.01px)",
                      backfaceVisibility: "hidden",
                      WebkitBackfaceVisibility: "hidden",
                    }}
                  >
                    {/* inset white panel; cross-fade in on hover */}
                    <div className="panel-back absolute inset-[1px] rounded-2xl bg-white p-3 transition-opacity duration-200 opacity-0 group-hover:opacity-100">
                      <div className="grid h-full grid-rows-[1fr_auto] gap-3">
                        <div className="grid grid-cols-2 grid-rows-2 gap-2">
                          {[0, 1, 2, 3].map((idx) => {
                            const src = gallery[idx];
                            return (
                              <div
                                key={idx}
                                className="relative h-full min-h-16 w-full overflow-hidden rounded-lg bg-neutral-100"
                              >
                                {src ? (
                                  <Image
                                    src={src}
                                    alt={`${creator.display_name} photo ${idx + 1}`}
                                    fill
                                    className="object-cover"
                                    unoptimized
                                    sizes="(max-width:768px) 33vw, 200px"
                                  />
                                ) : null}
                              </div>
                            );
                          })}
                        </div>

                        <div className="flex items-center justify-end">
                          <Link
                            href={`/creators/${creator.creator_id}`}
                            className="inline-flex items-center rounded-xl bg-black px-3 py-2 text-sm font-semibold text-white hover:bg-black/90"
                          >
                            View profile
                          </Link>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>

                {/* Flip interaction */}
                <style jsx>{`
                  .group:hover .flip-inner {
                    transform: rotateY(180deg) translateZ(0);
                  }
                `}</style>
              </div>
            );
          })}
        </div>
      )}
    </main>
  );
}

===== FILE: sliptail-frontend\src\app\creators\[id]\page.tsx =====

// src/app/creators/[id]/page.tsx
"use client";

import { useEffect, useMemo, useState } from "react";
import { useParams, useRouter, useSearchParams } from "next/navigation";
import Image from "next/image";
import { useAuth } from "@/components/auth/AuthProvider";

/* -------------------------- Types -------------------------- */

type Product = {
  id: string;
  title: string;
  description?: string | null;
  product_type: "purchase" | "membership" | "request";
  price: number; // cents
};

type CreatorProfile = {
  creator_id: number;
  display_name: string;
  bio: string | null;
  profile_image: string | null;
  average_rating: number;
  products_count: number;
  gallery?: string[];
};

type CategoryChip = { id: number; name: string; slug: string };

type Review = {
  id: string;
  author_name: string;
  rating: number;
  comment: string | null;
  created_at: string; // ISO
};

/* ------------------------- Helpers ------------------------- */

function isRecord(v: unknown): v is Record<string, unknown> {
  return typeof v === "object" && v !== null;
}

function getString(obj: unknown, key: string): string | undefined {
  if (!isRecord(obj)) return undefined;
  const v = obj[key];
  return typeof v === "string" ? v : undefined;
}

function getNumber(obj: unknown, key: string): number | undefined {
  if (!isRecord(obj)) return undefined;
  const v = obj[key];
  return typeof v === "number" ? v : undefined;
}

function getArray(obj: unknown, key: string): unknown[] | undefined {
  if (!isRecord(obj)) return undefined;
  const v = obj[key];
  return Array.isArray(v) ? v : undefined;
}

function toApiBase(): string {
  return (process.env.NEXT_PUBLIC_API_URL || "http://localhost:5000").replace(/\/$/, "");
}

/** Normalize backend image paths to absolute URLs usable by next/image */
function resolveImageUrl(src: string | null | undefined, apiBase: string): string | null {
  if (!src) return null;
  let s = src.trim();
  if (s.startsWith("//")) s = s.slice(1);
  if (/^https?:\/\//i.test(s)) return s;
  if (!s.startsWith("/")) s = `/${s}`;
  return `${apiBase}${s}`;
}

/* ----------------------- JSON Parsers ----------------------- */

function parseCreatorProfile(json: unknown, fallbackId: string | null): CreatorProfile | null {
  if (!isRecord(json)) return null;

  const idFromUser = getNumber(json, "user_id");
  const idFromCreator = getNumber(json, "creator_id");
  const id = idFromUser ?? idFromCreator ?? (fallbackId ? Number(fallbackId) : Number.NaN);
  if (!Number.isFinite(id)) return null;

  const display_name = getString(json, "display_name") ?? "";
  const bio = ((): string | null => {
    const b = json["bio"];
    return typeof b === "string" ? b : null;
  })();
  const profile_image = ((): string | null => {
    const p = json["profile_image"];
    return typeof p === "string" ? p : null;
  })();
  const average_rating = ((): number => {
    const vNum = getNumber(json, "average_rating");
    if (typeof vNum === "number") return vNum;
    const vStr = getString(json, "average_rating");
    return typeof vStr === "string" ? Number(vStr) || 0 : 0;
  })();
  const products_count = ((): number => {
    const vNum = getNumber(json, "products_count");
    if (typeof vNum === "number") return vNum;
    const vStr = getString(json, "products_count");
    return typeof vStr === "string" ? Number(vStr) || 0 : 0;
  })();
  const gallery = ((): string[] => {
    const arr = json["gallery"];
    return Array.isArray(arr) ? arr.filter((x): x is string => typeof x === "string") : [];
  })();

  return {
    creator_id: id,
    display_name,
    bio,
    profile_image,
    average_rating,
    products_count,
    gallery,
  };
}

function parseProductItem(x: unknown): Product | null {
  if (!isRecord(x)) return null;

  const id =
    getString(x, "id") ?? (typeof x["id"] === "number" ? String(x["id"]) : undefined);
  if (!id) return null;

  const title = getString(x, "title") ?? "";
  const description = ((): string | null => {
    const d = x["description"];
    return typeof d === "string" ? d : null;
  })();

  const typeRaw = getString(x, "product_type") ?? "purchase";
  const product_type: Product["product_type"] =
    typeRaw === "membership" ? "membership" : typeRaw === "request" ? "request" : "purchase";

  const price = ((): number => {
    const pNum = getNumber(x, "price");
    if (typeof pNum === "number") return pNum;
    const pStr = getString(x, "price");
    return typeof pStr === "string" ? Number(pStr) || 0 : 0;
  })();

  return { id, title, description, product_type, price };
}

function parseProductsResponse(json: unknown): Product[] {
  if (!isRecord(json)) return [];
  const arr = getArray(json, "products");
  if (!arr) return [];
  const out: Product[] = [];
  for (const item of arr) {
    const p = parseProductItem(item);
    if (p) out.push(p);
  }
  return out;
}

function parseCreatorCard(json: unknown): {
  categories: CategoryChip[];
  gallery: string[];
} {
  if (!isRecord(json)) return { categories: [], gallery: [] };

  const front = isRecord(json.front) ? json.front : null;
  const back = isRecord(json.back) ? json.back : null;

  const catsRaw = front ? getArray(front, "categories") ?? [] : [];
  const categories: CategoryChip[] = [];
  for (const c of catsRaw) {
    if (!isRecord(c)) continue;
    const id =
      getNumber(c, "id") ?? (typeof c["id"] === "string" ? Number(c["id"]) : undefined);
    const name = getString(c, "name");
    const slug = getString(c, "slug") ?? "";
    if (typeof id === "number" && Number.isFinite(id) && name) {
      categories.push({ id, name, slug });
    }
  }

  const galRaw = back ? back["gallery"] : [];
  const gallery = Array.isArray(galRaw)
    ? galRaw.filter((x): x is string => typeof x === "string")
    : [];

  return { categories, gallery };
}

function parseReviews(json: unknown): Review[] {
  let arr: unknown[] | undefined;

  if (Array.isArray(json)) {
    arr = json;
  } else if (isRecord(json)) {
    arr = getArray(json, "reviews");
  }

  if (!arr) return [];

  const out: Review[] = [];
  for (const r of arr) {
    if (!isRecord(r)) continue;
    const id =
      getString(r, "id") ??
      (typeof r["id"] === "number" ? String(r["id"]) : undefined) ??
      Math.random().toString(36).slice(2);
    const author_name =
      getString(r, "author_name") ??
      getString(r, "user_name") ??
      getString(r, "username") ??
      "Anonymous";
    const rating = ((): number => {
      const n = getNumber(r, "rating");
      if (typeof n === "number") return n;
      const s = getString(r, "rating");
      return typeof s === "string" ? Number(s) || 0 : 0;
    })();
    const comment = ((): string | null => {
      const cmt = r["comment"] ?? r["text"] ?? r["review"];
      return typeof cmt === "string" ? cmt : null;
    })();
    const created_at =
      getString(r, "created_at") ?? getString(r, "createdAt") ?? new Date().toISOString();

    out.push({ id, author_name, rating, comment, created_at });
  }
  return out;
}

/* ------------------------- Component ------------------------ */

export default function CreatorProfilePage() {
  const params = useParams<{ id: string }>();
  const searchParams = useSearchParams();
  const creatorId = params?.id ?? null;

  const apiBase = useMemo(() => toApiBase(), []);
  const router = useRouter();
  const { user } = useAuth?.() ?? { user: null };

  const [creator, setCreator] = useState<CreatorProfile | null>(null);
  const [products, setProducts] = useState<Product[]>([]);
  const [categories, setCategories] = useState<CategoryChip[]>([]);
  const [gallery, setGallery] = useState<string[]>([]);
  const [reviews, setReviews] = useState<Review[]>([]);
  const [loading, setLoading] = useState(true);
  const [err, setErr] = useState<string | null>(null);
  const [checkingOutId, setCheckingOutId] = useState<string | null>(null);

  const isOwner =
    !!user &&
    (typeof user.id === "number" ? user.id : Number(user.id)) ===
      (creator?.creator_id ?? Number(creatorId || NaN));

  useEffect(() => {
    if (!creatorId) return;

    const ac = new AbortController();
    let cancelled = false;

    (async () => {
      setLoading(true);
      setErr(null);
      try {
        const profReq = fetch(`${apiBase}/api/creators/${creatorId}`, {
          credentials: "include",
          signal: ac.signal,
        });
        const cardReq = fetch(`${apiBase}/api/creators/${creatorId}/card`, {
          credentials: "include",
          signal: ac.signal,
        });
        const prodReq = fetch(`${apiBase}/api/products/user/${creatorId}`, {
          credentials: "include",
          signal: ac.signal,
        });

        const profRes = await profReq;
        if (!profRes.ok) throw new Error(`HTTP ${profRes.status}`);
        const profJson: unknown = await profRes.json();
        const prof = parseCreatorProfile(profJson, creatorId);
        if (!prof) throw new Error("Invalid profile payload");
        if (cancelled) return;
        setCreator(prof);

        try {
          const res = await cardReq;
          if (res.ok) {
            const cardJson: unknown = await res.json();
            const parsed = parseCreatorCard(cardJson);
            if (!cancelled) {
              setCategories(parsed.categories);
              setGallery(parsed.gallery);
            }
          }
        } catch {}

        try {
          const res = await prodReq;
          if (res.ok) {
            const prodJson: unknown = await res.json();
            const list = parseProductsResponse(prodJson);
            if (!cancelled) setProducts(list);
          } else if (!cancelled) {
            setProducts([]);
          }
        } catch {
          if (!cancelled) setProducts([]);
        }

        try {
          let revs: Review[] = [];
          const r1 = await fetch(`${apiBase}/api/creators/${creatorId}/reviews`, {
            credentials: "include",
            signal: ac.signal,
          });
          if (r1.ok) {
            const j: unknown = await r1.json();
            revs = parseReviews(j);
          } else {
            const r2 = await fetch(`${apiBase}/api/reviews?creatorId=${creatorId}`, {
              credentials: "include",
              signal: ac.signal,
            });
            if (r2.ok) {
              const j2: unknown = await r2.json();
              revs = parseReviews(j2);
            }
          }
          if (!cancelled) setReviews(revs);
        } catch {
          if (!cancelled) setReviews([]);
        }
      } catch {
        if (!cancelled) {
          setErr("Failed to load creator");
          setCreator(null);
          setProducts([]);
          setCategories([]);
          setGallery([]);
          setReviews([]);
        }
      } finally {
        if (!cancelled) setLoading(false);
      }
    })();

    return () => {
      cancelled = true;
      ac.abort();
    };
  }, [creatorId, apiBase]);

  /**
   * Client-side checkout:
   * - If not signed in: push to login with next=/creators/:id?checkout=:pid
   * - If signed in: call our server route at /stripe-checkout/start (which forwards cookies and picks the right backend route)
   */
  async function startCheckout(p: Product) {
    if (!creatorId) return;

    if (!user) {
      const nextUrl = `/creators/${encodeURIComponent(String(creatorId))}?checkout=${encodeURIComponent(
        p.id
      )}`;
      router.push(`/auth/login?next=${encodeURIComponent(nextUrl)}`);
      return;
    }

    setCheckingOutId(p.id);
    try {
      window.location.href = `/stripe-checkout/start?pid=${encodeURIComponent(
        p.id
      )}&action=${encodeURIComponent(p.product_type)}`;
    } finally {
      setCheckingOutId(null);
    }
  }

  // Auto-start after login if ?checkout=PID
  useEffect(() => {
    const pid = searchParams.get("checkout");
    if (!pid || !user || products.length === 0) return;
    const p = products.find((x) => x.id === pid);
    if (p) void startCheckout(p);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams, user, products]);

  if (!creatorId) {
    return (
      <main className="mx-auto max-w-5xl px-4 py-10">
        <h1 className="text-2xl font-bold">Creator</h1>
        <p className="mt-2 text-sm text-neutral-600">No creator id.</p>
      </main>
    );
  }

  const profileUrl = resolveImageUrl(creator?.profile_image ?? null, apiBase);
  const galleryUrls = (gallery || [])
    .slice(0, 4)
    .map((u) => resolveImageUrl(u, apiBase))
    .filter((u): u is string => !!u);

  return (
    <main className="mx-auto max-w-5xl px-4 py-10 space-y-10">
      {loading ? (
        <div className="text-sm text-neutral-600 text-center">Loading…</div>
      ) : err ? (
        <div className="rounded-xl border border-red-300 bg-red-50 p-3 text-sm text-red-800 text-center">
          {err}
        </div>
      ) : !creator ? (
        <div className="text-sm text-neutral-600 text-center">Creator not found.</div>
      ) : (
        <>
          {/* Header: centered */}
          <header className="flex flex-col items-center text-center gap-4">
            <div className="relative h-36 w-36 overflow-hidden rounded-full bg-neutral-100">
              {profileUrl ? (
                <Image
                  src={profileUrl}
                  alt={creator.display_name}
                  fill
                  className="object-cover"
                  unoptimized
                  sizes="144px"
                />
              ) : null}
            </div>

            <div>
              <h1 className="text-3xl font-bold">{creator.display_name}</h1>
              <div className="mt-1 text-sm text-neutral-600">
                {Number(creator.average_rating || 0).toFixed(1)} ★ · {creator.products_count} product
                {creator.products_count === 1 ? "" : "s"}
              </div>
            </div>

            {/* Categories under rating */}
            {categories.length > 0 ? (
              <div className="mt-1 flex flex-wrap justify-center gap-2">
                {categories.map((cat) => (
                  <span
                    key={cat.id}
                    className="rounded-full border px-3 py-1 text-xs text-neutral-700"
                    title={cat.name}
                  >
                    {cat.name}
                  </span>
                ))}
              </div>
            ) : null}
          </header>

          {/* About */}
          {creator.bio ? (
            <section className="text-center">
              <h2 className="mb-2 text-lg font-semibold">About</h2>
              <p className="whitespace-pre-line text-neutral-800">{creator.bio}</p>
            </section>
          ) : null}

          {/* Products */}
          <section>
            <h2 className="mb-3 text-lg font-semibold text-center">Products</h2>
            {products.length === 0 ? (
              <div className="text-sm text-neutral-600 text-center">No products yet.</div>
            ) : (
              <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
                {products.map((p) => {
                  const basePriceLabel = `$${((p.price || 0) / 100).toFixed(2)}`;
                  const priceLabel =
                    p.product_type === "membership" ? `${basePriceLabel} per month` : basePriceLabel;

                  let cta = "Purchase download";
                  if (p.product_type === "membership") cta = "Subscribe for membership";
                  else if (p.product_type === "request") cta = "Purchase request";

                  const ownerCTA = "Edit product";

                  return (
                    <div key={p.id} className="rounded-2xl border p-4 flex flex-col">
                      <div className="text-xs uppercase tracking-wide text-neutral-600">
                        {p.product_type}
                      </div>
                      <div className="font-semibold">{p.title}</div>
                      {p.description ? (
                        <p className="mt-1 text-sm text-neutral-700">{p.description}</p>
                      ) : null}

                      <div className="mt-auto">
                        <div className="mt-2 font-semibold">{priceLabel}</div>

                        {isOwner ? (
                          <button
                            className="mt-3 w-full rounded-xl border py-2"
                            onClick={() => router.push("/dashboard")}
                          >
                            {ownerCTA}
                          </button>
                        ) : (
                          <button
                            className="mt-3 w-full rounded-xl bg-black py-2 text-white hover:bg黑/90 disabled:opacity-60"
                            onClick={() => void startCheckout(p)}
                            disabled={checkingOutId === p.id}
                          >
                            {checkingOutId === p.id ? "Redirecting…" : cta}
                          </button>
                        )}
                      </div>
                    </div>
                  );
                })}
              </div>
            )}
          </section>

          {/* Photos */}
          {galleryUrls.length > 0 ? (
            <section aria-label="Creator photos">
              <div className="mx-auto max-w-5xl overflow-hidden rounded-2xl">
                <div className="flex">
                  {[0, 1, 2, 3].map((idx) => {
                    const src = galleryUrls[idx];
                    return (
                      <div key={idx} className="relative aspect-[4/3] w-1/4">
                        {src ? (
                          <Image
                            src={src}
                            alt={`${creator.display_name} photo ${idx + 1}`}
                            fill
                            className="object-cover"
                            unoptimized
                            sizes="(max-width: 1280px) 25vw, 320px"
                          />
                        ) : null}
                      </div>
                    );
                  })}
                </div>
              </div>
            </section>
          ) : null}

          {/* Reviews */}
          {reviews.length > 0 ? (
            <section>
              <h2 className="mb-3 text-lg font-semibold text-center">Reviews</h2>
              <div className="mx-auto max-w-3xl space-y-3">
                {reviews.map((r) => (
                  <div key={r.id} className="rounded-2xl border p-4">
                    <div className="flex items-center justify-between text-sm">
                      <span className="font-medium">{r.author_name || "Anonymous"}</span>
                      <span className="text-neutral-500">{(r.created_at || "").slice(0, 10)}</span>
                    </div>
                    <div className="mt-0.5 text-sm">{Number(r.rating || 0).toFixed(1)} ★</div>
                    {r.comment ? <p className="mt-2 text-neutral-800">{r.comment}</p> : null}
                  </div>
                ))}
              </div>
            </section>
          ) : null}
        </>
      )}
    </main>
  );
}



===== FILE: sliptail-frontend\src\app\dashboard\page.tsx =====

// src/app/dashboard/page.tsx
"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { useRouter } from "next/navigation";
import { useAuth } from "@/components/auth/AuthProvider";
import { loadAuth } from "@/lib/auth";

// ----- Types -----
type Product = {
  id: string;
  title: string;
  description?: string | null;
  product_type: "purchase" | "membership" | "request";
  price: number;
};

type CreatorProfile = {
  creator_id: number;
  display_name: string;
  bio: string | null;
  profile_image: string | null;
  average_rating: number;
  products_count: number;
};
type GalleryPhoto = { position: number; url: string | null };

type CategoryItem = { id: string; name: string };

// --------- Safe helpers ----------
function isRecord(v: unknown): v is Record<string, unknown> {
  return typeof v === "object" && v !== null;
}
function asString(v: unknown): string | undefined {
  return typeof v === "string" ? v : undefined;
}
function getStringProp(obj: unknown, key: string): string | undefined {
  if (!isRecord(obj)) return undefined;
  const v = obj[key];
  return typeof v === "string" ? v : undefined;
}
function getBooleanProp(obj: unknown, key: string): boolean | undefined {
  if (!isRecord(obj)) return undefined;
  const v = obj[key];
  return typeof v === "boolean" ? v : undefined;
}
function isStringArray(v: unknown): v is string[] {
  return Array.isArray(v) && v.every((x) => typeof x === "string");
}
function getStringArrayProp(obj: unknown, key: string): string[] | undefined {
  if (!isRecord(obj)) return undefined;
  const v = obj[key];
  return isStringArray(v) ? v : undefined;
}
function toCategoryItem(input: unknown): CategoryItem | null {
  const maybeStr = asString(input);
  if (maybeStr) return { id: maybeStr, name: maybeStr };
  if (isRecord(input)) {
    const name =
      getStringProp(input, "name") ??
      getStringProp(input, "category") ??
      getStringProp(input, "label") ??
      getStringProp(input, "title");
    if (!name) return null;
    const id =
      getStringProp(input, "id") ??
      getStringProp(input, "category_id") ??
      getStringProp(input, "slug") ??
      getStringProp(input, "value") ??
      name;
    return { id: id || name, name };
  }
  return null;
}
function toCategoryItemsFlexible(payload: unknown): CategoryItem[] {
  if (Array.isArray(payload)) {
    return payload.map(toCategoryItem).filter((x): x is CategoryItem => x !== null);
  }
  if (isRecord(payload)) {
    const keys = ["categories", "data", "items", "results"];
    for (const k of keys) {
      const v = (payload as Record<string, unknown>)[k];
      if (Array.isArray(v)) {
        return v.map(toCategoryItem).filter((x): x is CategoryItem => x !== null);
      }
    }
    const entries = Object.entries(payload);
    if (entries.length > 0 && entries.every(([k]) => typeof k === "string")) {
      return entries.map(([k]) => ({ id: String(k), name: String(k) }));
    }
  }
  return [];
}
function uniqStrings(list: string[]): string[] {
  const set = new Set<string>();
  for (const s of list) set.add(s);
  return Array.from(set);
}
function extractMessage(obj: unknown, fallback: string): string {
  return getStringProp(obj, "error") || getStringProp(obj, "message") || fallback;
}

// Attach Authorization header (Bearer) when we have a saved token
function buildAuthHeaders(extra?: Record<string, string>): HeadersInit {
  let token: string | null = null;
  try {
    token = loadAuth()?.token ?? null;
  } catch {
    token = null;
  }
  return {
    ...(extra || {}),
    ...(token ? { Authorization: `Bearer ${token}` } : {}),
  };
}

// Resolve relative /uploads paths to full URLs
function resolveImageUrl(src: string | null | undefined, apiBase: string): string | null {
  if (!src) return null;
  let s = src.trim();
  if (s.startsWith("//")) s = s.slice(1);
  if (/^https?:\/\//i.test(s)) return s;
  if (!s.startsWith("/")) s = `/${s}`;
  return `${apiBase}${s}`;
}

export default function DashboardPage() {
  const router = useRouter();
  const { user } = useAuth?.() ?? { user: null };

  const [creator, setCreator] = useState<CreatorProfile | null>(null);
  const [gallery, setGallery] = useState<GalleryPhoto[]>([
    { position: 1, url: null },
    { position: 2, url: null },
    { position: 3, url: null },
    { position: 4, url: null },
  ]);
  const profileImgInputRef = useRef<HTMLInputElement | null>(null);
  const galleryInputRefs = [
    useRef<HTMLInputElement | null>(null),
    useRef<HTMLInputElement | null>(null),
    useRef<HTMLInputElement | null>(null),
    useRef<HTMLInputElement | null>(null),
  ];
  const [products, setProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);

  // Quick edit state
  const [displayName, setDisplayName] = useState("");
  const [bio, setBio] = useState("");
  const [selectedCategories, setSelectedCategories] = useState<string[]>([]);
  const [savingProfile, setSavingProfile] = useState(false);
  const [saveMsg, setSaveMsg] = useState<string | null>(null);

  // Dynamic categories from DB
  const [allCategories, setAllCategories] = useState<CategoryItem[]>([]);
  const [catsLoading, setCatsLoading] = useState(false);

  // Stripe
  const [connecting, setConnecting] = useState(false);
  const [stripeLoading, setStripeLoading] = useState(false);
  const [stripeConnected, setStripeConnected] = useState<boolean | null>(null);

  // Delete confirm
  const [confirmDeleteId, setConfirmDeleteId] = useState<string | null>(null);
  const [deleting, setDeleting] = useState(false);
  const [deleteErr, setDeleteErr] = useState<string | null>(null);

  // NEW: Toast state
  const [toastOpen, setToastOpen] = useState(false);
  const [toastText, setToastText] = useState<string>("");
  const toastTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  const apiBase = useMemo(
    () => (process.env.NEXT_PUBLIC_API_URL || "http://localhost:5000").replace(/\/$/, ""),
    []
  );

  const creatorId = user?.id ? String(user.id) : null;

  // Load creator profile & products
  useEffect(() => {
    const ac = new AbortController();

    async function load() {
      if (!creatorId) {
        setLoading(false);
        return;
      }
      try {
        setLoading(true);
        // Own profile (includes ungated + gallery)
        const profRes = await fetch(`${apiBase}/api/creators/me`, {
          credentials: "include",
          signal: ac.signal,
          headers: buildAuthHeaders(),
        });
        const profJson: unknown = await profRes.json();
        // If not eligible yet, fields may differ but we map defensively
        const prof = profJson as Partial<CreatorProfile> & { gallery?: string[] };
        setCreator({
          creator_id: Number(prof?.creator_id || user?.id || creatorId),
          display_name: prof?.display_name || "",
          bio: (prof as any)?.bio || null,
          profile_image: (prof as any)?.profile_image || null,
          average_rating: Number((prof as any)?.average_rating || 0),
          products_count: Number((prof as any)?.products_count || 0),
        });
        setDisplayName(prof?.display_name || "");
        setBio(((prof as any)?.bio as string) || "");
        const cats = getStringArrayProp(profJson, "categories");
        if (cats) setSelectedCategories(uniqStrings(cats));
        const galArr = Array.isArray((prof as any)?.gallery)
          ? ((prof as any)?.gallery as string[])
          : [];
        setGallery((prev) =>
          prev.map((g) => ({ position: g.position, url: galArr[g.position - 1] || null }))
        );

        // Products
        const prodRes = await fetch(`${apiBase}/api/products/user/${creatorId}`, {
          credentials: "include",
          signal: ac.signal,
        });
        const prodJson: unknown = await prodRes.json();
        const list =
          (isRecord(prodJson) && Array.isArray((prodJson as Record<string, unknown>).products)
            ? (((prodJson as Record<string, unknown>).products as unknown[]) || [])
            : []
          ).filter(isRecord);
        const typedProducts: Product[] = list.map((x) => {
          const id = getStringProp(x, "id") ?? "";
          const title = getStringProp(x, "title") ?? "";
          const description = getStringProp(x, "description") ?? null;
          const typeStr = getStringProp(x, "product_type") ?? "purchase";
          const product_type: Product["product_type"] =
            typeStr === "membership" ? "membership" : typeStr === "request" ? "request" : "purchase";
          const priceRaw = isRecord(x) ? (x as Record<string, unknown>)["price"] : undefined;
          const price =
            typeof priceRaw === "number"
              ? priceRaw
              : typeof priceRaw === "string"
              ? Number(priceRaw)
              : 0;
          return { id, title, description, product_type, price };
        });
        setProducts(typedProducts);
      } catch (e) {
        if (!(e instanceof DOMException && e.name === "AbortError")) {
          console.error("dashboard load error", e);
        }
      } finally {
        setLoading(false);
      }
    }

    load();
    return () => ac.abort();
  }, [creatorId, apiBase]);

  // Load categories list from DB (tolerant parsing)
  useEffect(() => {
    const ac = new AbortController();

    async function loadAllCategories() {
      if (!creatorId) return;
      setCatsLoading(true);
      try {
        let items: CategoryItem[] = [];
        const endpoints = [
          `${apiBase}/api/categories`,
          `${apiBase}/api/category`,
          `${apiBase}/api/creators/${creatorId}/categories`,
        ];

        for (const url of endpoints) {
          try {
            const res = await fetch(url, { credentials: "include", signal: ac.signal });
            if (!res.ok) continue;
            const data: unknown = await res.json();
            items = toCategoryItemsFlexible(data);
            if (items.length > 0) break;
          } catch (err) {
            if (err instanceof DOMException && err.name === "AbortError") break;
          }
        }

        if (items.length === 0 && selectedCategories.length > 0) {
          items = selectedCategories.map((name) => ({ id: name, name }));
        }

        setAllCategories(items);
      } finally {
        setCatsLoading(false);
      }
    }

    loadAllCategories();
    return () => ac.abort();
  }, [creatorId, apiBase, selectedCategories]);

  // Load Stripe connect status (requires auth)
  useEffect(() => {
    const ac = new AbortController();

    async function loadStripeStatus() {
      if (!creatorId) return;
      setStripeLoading(true);
      try {
        const res = await fetch(`${apiBase}/api/stripe-connect/status`, {
          credentials: "include",
          signal: ac.signal,
          headers: buildAuthHeaders(),
        });
        if (res.ok) {
          const data: unknown = await res.json().catch(() => ({}));
          const connected =
            getBooleanProp(data, "connected") ??
            getBooleanProp(data, "details_submitted") ??
            null;
          setStripeConnected(connected);
        } else {
          // fallback
          try {
            const altRes = await fetch(`${apiBase}/api/me/creator-status`, {
              credentials: "include",
              signal: ac.signal,
              headers: buildAuthHeaders(),
            });
            if (altRes.ok) {
              const alt: unknown = await altRes.json();
              const sc = getBooleanProp(alt, "stripeConnected") ?? null;
              setStripeConnected(sc);
            } else {
              setStripeConnected(null);
            }
          } catch {
            setStripeConnected(null);
          }
        }
      } catch {
        setStripeConnected(null);
      } finally {
        setStripeLoading(false);
      }
    }

    loadStripeStatus();
    return () => ac.abort();
  }, [creatorId, apiBase]);

  function toggleCategoryName(name: string) {
    setSelectedCategories((prev) =>
      prev.includes(name) ? prev.filter((c) => c !== name) : [...prev, name]
    );
  }

  async function saveQuickProfile() {
    if (!creatorId) return;
    setSavingProfile(true);
    setSaveMsg(null);
    try {
      const res = await fetch(`${apiBase}/api/creators/${creatorId}`, {
        method: "PUT",
        credentials: "include",
        headers: buildAuthHeaders({ "Content-Type": "application/json" }),
        body: JSON.stringify({
          display_name: displayName.trim(),
          bio: bio.trim(),
          categories: selectedCategories,
        }),
      });
      if (!res.ok) {
        const text = await res.text().catch(() => "");
        if (res.status === 401) throw new Error("Unauthorized — please sign in again.");
        if (res.status === 403)
          throw new Error("Forbidden — you don’t have permission to edit this profile.");
        throw new Error(text || "Failed to save profile");
      }
      const updated: unknown = await res.json().catch(() => ({}));
      const newDisplay = getStringProp(updated, "display_name") ?? displayName;
      const newBio = getStringProp(updated, "bio") ?? bio;

      setCreator((prev) => ({
        ...(prev ?? ({} as CreatorProfile)),
        display_name: newDisplay,
        bio: newBio,
        profile_image: prev?.profile_image ?? null,
        average_rating: prev?.average_rating ?? 0,
        products_count: prev?.products_count ?? 0,
        creator_id: prev?.creator_id ?? Number(creatorId),
      }));
      setSaveMsg("Saved ✔");
      setTimeout(() => setSaveMsg(null), 2000);
    } catch (e) {
      console.error("profile save error", e);
      setSaveMsg(e instanceof Error ? e.message : "Could not save profile");
    } finally {
      setSavingProfile(false);
    }
  }

  async function connectStripe() {
    try {
      setConnecting(true);
      const res = await fetch(`${apiBase}/api/stripe-connect/create-link`, {
        method: "POST",
        credentials: "include",
        headers: buildAuthHeaders(),
      });
      const data: unknown = await res.json();
      const url = getStringProp(data, "url");
      if (url) {
        window.location.href = url;
      } else {
        // use toast instead of alert for consistency
        showToast(extractMessage(data, "Could not start Stripe onboarding"));
      }
    } catch {
      showToast("Stripe onboarding error");
    } finally {
      setConnecting(false);
    }
  }

  // Delete product (protected)
  function requestDelete(id: string) {
    setDeleteErr(null);
    setConfirmDeleteId(id);
  }
  async function confirmDelete() {
    if (!confirmDeleteId) return;
    setDeleting(true);
    setDeleteErr(null);
    try {
      const res = await fetch(`${apiBase}/api/products/${encodeURIComponent(confirmDeleteId)}`, {
        method: "DELETE",
        credentials: "include",
        headers: buildAuthHeaders(),
      });
      if (!res.ok) {
        const text = await res.text().catch(() => "");
        throw new Error(text || "Failed to delete product");
      }
      const payload: unknown = await res.json().catch(() => ({}));
      const success =
        (isRecord(payload) &&
          typeof (payload as Record<string, unknown>).success === "boolean" &&
          (payload as Record<string, unknown>).success === true) || false;
      if (!success) throw new Error(extractMessage(payload, "Delete failed"));

      setProducts((prev) => prev.filter((p) => p.id !== confirmDeleteId));
      setConfirmDeleteId(null);
    } catch (e) {
      console.error("delete product error", e);
      setDeleteErr(e instanceof Error ? e.message : "Could not delete product");
    } finally {
      setDeleting(false);
    }
  }

  // ----- NEW: View profile + Copy link actions -----
  const publicProfilePath = creatorId ? `/creators/${creatorId}` : "/";
  const onViewProfile = () => router.push(publicProfilePath);

  // Toast helpers
  function showToast(text: string) {
    if (toastTimerRef.current) clearTimeout(toastTimerRef.current);
    setToastText(text);
    setToastOpen(true);
    toastTimerRef.current = setTimeout(() => {
      setToastOpen(false);
      toastTimerRef.current = null;
    }, 5000);
  }
  useEffect(() => {
    return () => {
      if (toastTimerRef.current) clearTimeout(toastTimerRef.current);
    };
  }, []);

  const onCopyLink = async () => {
    try {
      const origin = typeof window !== "undefined" ? window.location.origin : "";
      const fullUrl = `${origin}${publicProfilePath}`;
      await navigator.clipboard.writeText(fullUrl);
      showToast("Profile link copied to clipboard");
    } catch {
      // Fallback prompt (still show toast so it feels consistent)
      const origin = typeof window !== "undefined" ? window.location.origin : "";
      const fullUrl = `${origin}${publicProfilePath}`;
      window.prompt("Copy your profile link:", fullUrl);
      showToast("Profile link ready to copy");
    }
  };

  if (!creatorId) {
    return (
      <main className="max-w-4xl mx-auto p-6">
        <h1 className="text-2xl font-bold">Creator Dashboard</h1>
        <p className="mt-2 text-sm text-neutral-700">Please sign in to view your dashboard.</p>
      </main>
    );
  }

  return (
    <>
      {/* Toast (Instagram-style): bottom center, grey bg, check icon, fade/slide */}
      <div
        className={[
          "fixed left-1/2 bottom-8 z-[1000] -translate-x-1/2",
          "transition-all duration-300",
          toastOpen ? "opacity-100 translate-y-0" : "opacity-0 translate-y-2 pointer-events-none",
        ].join(" ")}
        role="status"
        aria-live="polite"
      >
        <div className="flex items-center gap-2 rounded-full bg-neutral-800 px-4 py-2 text-white shadow-lg">
          {/* Check icon */}
          <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">
            <path
              d="M20 6L9 17l-5-5"
              fill="none"
              stroke="currentColor"
              strokeWidth="2.5"
              strokeLinecap="round"
              strokeLinejoin="round"
            />
          </svg>
          <span className="text-sm">{toastText}</span>
        </div>
      </div>

      <main className="mx-auto max-w-6xl px-4 py-8 space-y-8">
        {/* Header: avatar + name + stats */}
        <header className="flex items-center gap-4">
          <div className="relative h-20 w-20 overflow-hidden rounded-full bg-neutral-100">
      {creator?.profile_image ? (
              // eslint-disable-next-line @next/next/no-img-element
              <img
        src={resolveImageUrl(creator.profile_image, apiBase) || creator.profile_image}
                alt={creator.display_name || "Creator"}
                className="h-full w-full object-cover"
              />
            ) : null}
          </div>
          <div>
            <h1 className="text-2xl font-bold">
              {loading ? "Loading..." : creator?.display_name || "Your Profile"}
            </h1>
            {creator?.bio && <p className="text-neutral-700">{creator.bio}</p>}
            {creator && (
              <div className="text-sm text-neutral-600 mt-1">
                {(Number(creator.average_rating) || 0).toFixed(1)} ★ · {creator.products_count} products
              </div>
            )}
          </div>
        </header>

        {/* View profile & Copy link actions */}
        <section className="grid grid-cols-1 sm:grid-cols-2 gap-4">
          {/* View Profile card */}
          <div className="rounded-2xl border p-4">
            <button
              onClick={onViewProfile}
              className="w-full rounded-xl bg-black py-2 text-white hover:bg-black/90"
              aria-label="View your public profile"
            >
              View your profile
            </button>
            <p className="mt-2 text-xs text-neutral-600 text-center">
              See how your profile looks to others
            </p>
          </div>

          {/* Copy Link card */}
          <div className="rounded-2xl border p-4">
            <button
              onClick={onCopyLink}
              className="w-full inline-flex items-center justify-center gap-2 rounded-xl border py-2 hover:bg-neutral-50"
              aria-label="Copy your profile link"
              title="Copy profile link"
            >
              {/* Copy icon */}
              <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">
                <path
                  d="M8 7V5a3 3 0 0 1 3-3h6a3 3 0 0 1 3 3v6a3 3 0 0 1-3 3h-2"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                />
                <rect
                  x="3"
                  y="7"
                  width="11"
                  height="14"
                  rx="3"
                  ry="3"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                />
              </svg>
              Copy profile link
            </button>
            <p className="mt-2 text-xs text-neutral-600 text-center">
              Copy your profile link to share for more engagement by adding to social media profiles
            </p>
          </div>
        </section>

        {/* ROW 1: Quick Edit (span 2) • Pending (span 1) */}
        <section className="grid grid-cols-1 md:grid-cols-3 gap-4">
          {/* Quick Edit: wider */}
          <div className="md:col-span-2 rounded-2xl border p-4">
            <div className="font-semibold mb-2">Quick Edit: Profile</div>
            <div className="grid gap-3">
              <div className="space-y-1">
                <label className="block text-xs font-medium text-neutral-700">Display name</label>
                <input
                  value={displayName}
                  onChange={(e) => setDisplayName(e.target.value)}
                  placeholder="Display name"
                  className="w-full rounded-xl border px-3 py-2"
                />
              </div>

              <div className="space-y-1">
                <label className="block text-xs font-medium text-neutral-700">Categories</label>

                {/* Category chips from DB */}
                <div className="flex flex-wrap gap-2">
                  {catsLoading && allCategories.length === 0 ? (
                    <span className="text-sm text-neutral-500">Loading categories…</span>
                  ) : allCategories.length > 0 ? (
                    allCategories.map((cat) => {
                      const active = selectedCategories.includes(cat.name);
                      return (
                        <button
                          key={cat.id || cat.name}
                          type="button"
                          onClick={() => toggleCategoryName(cat.name)}
                          className={`rounded-full border px-3 py-1 text-sm ${
                            active ? "bg-black text-white border-black" : "hover:bg-neutral-100"
                          }`}
                          aria-pressed={active}
                          title={cat.name}
                        >
                          {cat.name}
                        </button>
                      );
                    })
                  ) : (
                    <span className="text-sm text-neutral-500">No categories configured yet.</span>
                  )}
                </div>

                {/* If creator has a category that's not in the master list, show it too */}
                {selectedCategories.some((n) => !allCategories.find((c) => c.name === n)) && (
                  <div className="mt-2">
                    <div className="text-xs text-neutral-500 mb-1">Your categories</div>
                    <div className="flex flex-wrap gap-2">
                      {selectedCategories
                        .filter((n) => !allCategories.find((c) => c.name === n))
                        .map((name) => (
                          <button
                            key={`own-${name}`}
                            type="button"
                            onClick={() => toggleCategoryName(name)}
                            className="rounded-full border px-3 py-1 text-sm bg-black text-white border-black"
                            aria-pressed
                            title={name}
                          >
                            {name}
                          </button>
                        ))}
                    </div>
                  </div>
                )}

                <p className="text-xs text-neutral-500">
                  Pick one or more categories that best describe your work.
                </p>
              </div>

              <div className="space-y-1">
                <label className="block text-xs font-medium text-neutral-700">Bio</label>
                <textarea
                  value={bio}
                  onChange={(e) => setBio(e.target.value)}
                  placeholder="Tell buyers what you do"
                  rows={4}
                  className="w-full rounded-xl border px-3 py-2"
                />
              </div>

              {/* Profile Image uploader */}
              <div className="space-y-2">
                <label className="block text-xs font-medium text-neutral-700">Profile Image</label>
                <div className="flex items-center gap-4">
                  <button
                    type="button"
                    onClick={() => profileImgInputRef.current?.click()}
                    className="relative h-20 w-20 overflow-hidden rounded-full border bg-neutral-50 flex items-center justify-center text-xs text-neutral-500 hover:ring-2 hover:ring-black/20"
                    aria-label="Change profile image"
                  >
          {creator?.profile_image ? (
                      // eslint-disable-next-line @next/next/no-img-element
                      <img
            src={resolveImageUrl(creator.profile_image, apiBase) || creator.profile_image}
                        alt="Profile"
                        className="h-full w-full object-cover"
                      />
                    ) : (
                      <span>Upload</span>
                    )}
                  </button>
                  <div className="text-xs text-neutral-600 max-w-xs">
                    Click the image to upload / replace. JPG, PNG, WEBP, GIF up to 15MB.
                  </div>
                  <input
                    ref={profileImgInputRef}
                    type="file"
                    accept="image/*"
                    className="hidden"
                    onChange={async (e) => {
                      const file = e.target.files?.[0];
                      if (!file) return;
                      try {
                        const fd = new FormData();
                        fd.append("profile_image", file);
                        const res = await fetch(`${apiBase}/api/creators/me/profile-image`, {
                          method: "PATCH",
                          credentials: "include",
                          headers: buildAuthHeaders(),
                          body: fd,
                        });
                        if (!res.ok) throw new Error(await res.text());
                        const data: any = await res.json();
                        const url = data?.profile_image as string | undefined;
                        if (url) {
                          setCreator((prev) => (prev ? { ...prev, profile_image: url } : prev));
                          showToast("Profile image updated");
                        }
                      } catch (err) {
                        console.error(err);
                        showToast("Profile image upload failed");
                      } finally {
                        e.target.value = ""; // reset
                      }
                    }}
                  />
                </div>
              </div>

              {/* Gallery (4 photos) */}
              <div className="space-y-2">
                <label className="block text-xs font-medium text-neutral-700">Gallery Photos (4)</label>
                <div className="grid grid-cols-2 sm:grid-cols-4 gap-3">
                  {gallery.map((g, idx) => (
                    <div key={g.position} className="flex flex-col items-center gap-1">
                      <button
                        type="button"
                        onClick={() => galleryInputRefs[idx].current?.click()}
                        className="relative h-28 w-full overflow-hidden rounded-xl border bg-neutral-50 flex items-center justify-center text-xs text-neutral-500 hover:ring-2 hover:ring-black/20"
                        aria-label={`Replace gallery photo ${g.position}`}
                      >
                        {g.url ? (
                          // eslint-disable-next-line @next/next/no-img-element
                          <img
                            src={resolveImageUrl(g.url, apiBase) || g.url}
                            alt={`Gallery ${g.position}`}
                            className="h-full w-full object-cover"
                          />
                        ) : (
                          <span>Photo {g.position}</span>
                        )}
                        <span className="absolute bottom-1 right-1 rounded bg-black/60 px-1 text-[10px] text-white">Edit</span>
                      </button>
                      <input
                        ref={galleryInputRefs[idx]}
                        type="file"
                        accept="image/*"
                        className="hidden"
                        onChange={async (e) => {
                          const file = e.target.files?.[0];
                          if (!file) return;
                          try {
                            const fd = new FormData();
                            fd.append("photo", file);
                            const res = await fetch(`${apiBase}/api/creators/me/gallery/${g.position}`, {
                              method: "PATCH",
                              credentials: "include",
                              headers: buildAuthHeaders(),
                              body: fd,
                            });
                            if (!res.ok) throw new Error(await res.text());
                            const data: any = await res.json();
                            const newUrl = data?.url as string | undefined;
                            const newGallery: string[] | undefined = data?.gallery;
                            setGallery((prev) =>
                              prev.map((ph) =>
                                ph.position === g.position
                                  ? { ...ph, url: newUrl || ph.url }
                                  : newGallery && newGallery[ph.position - 1]
                                  ? { ...ph, url: newGallery[ph.position - 1] }
                                  : ph
                              )
                            );
                            showToast(`Gallery photo ${g.position} updated`);
                          } catch (err) {
                            console.error(err);
                            showToast("Gallery upload failed");
                          } finally {
                            e.target.value = "";
                          }
                        }}
                      />
                    </div>
                  ))}
                </div>
                <p className="text-xs text-neutral-500">These appear on the back of your creator card.</p>
              </div>

              <div className="flex items-center gap-3">
                <button
                  onClick={saveQuickProfile}
                  disabled={savingProfile}
                  className={`rounded-xl px-4 py-2 text-sm ${
                    savingProfile ? "bg-neutral-300 text-neutral-600" : "bg-black text-white"
                  }`}
                >
                  {savingProfile ? "Saving…" : "Save"}
                </button>
                {saveMsg && (
                  <span
                    className={`text-sm ${
                      saveMsg.includes("Saved") ? "text-green-700" : "text-red-700"
                    }`}
                  >
                    {saveMsg}
                  </span>
                )}
              </div>
            </div>
          </div>

          {/* Pending Requests */}
          <div className="rounded-2xl border p-4">
            <div className="font-semibold mb-2">Pending Requests</div>
            <div className="text-sm text-neutral-600">(none yet)</div>
          </div>
        </section>

        {/* ROW 2: Stripe (span 2) • Add Product (span 1) */}
        <section className="grid grid-cols-1 md:grid-cols-3 gap-4">
          {/* Stripe: left, span 2 */}
          <div className="md:col-span-2 rounded-2xl border p-4">
            <div className="font-semibold mb-2">Stripe Connect</div>

            <div className="flex items-center gap-2">
              <span
                className={`inline-block h-2 w-2 rounded-full ${
                  stripeConnected ? "bg-green-500" : stripeConnected === false ? "bg-red-500" : "bg-neutral-300"
                }`}
                aria-hidden="true"
              />
              <span className="text-sm text-neutral-700">
                {stripeLoading
                  ? "Checking status…"
                  : stripeConnected
                  ? "Connected"
                  : stripeConnected === false
                  ? "Not connected"
                  : "Status unavailable"}
              </span>
            </div>

            <button
              onClick={connectStripe}
              disabled={connecting}
              className="mt-3 w-full rounded-xl bg-black py-2 text-white"
            >
              {connecting ? "Redirecting…" : stripeConnected ? "Manage in Stripe" : "Connect Stripe"}
            </button>
          </div>

          {/* Add Product Icon card: right */}
          <button
            type="button"
            onClick={() => router.push("/dashboard/products/new")}
            className="rounded-2xl border p-4 flex items-center justify-center hover:bg-neutral-50"
            aria-label="Add Product"
            title="Add Product"
          >
            <div className="flex flex-col items-center gap-2">
              <div className="flex h-14 w-14 items-center justify-center rounded-full border-2 border-dashed">
                <svg width="28" height="28" viewBox="0 0 24 24" aria-hidden="true">
                  <path d="M12 5v14M5 12h14" stroke="currentColor" strokeWidth="2" strokeLinecap="round" />
                </svg>
              </div>
              <span className="text-sm font-medium">Add Product</span>
            </div>
          </button>
        </section>

        {/* Products grid */}
        <section>
          <h2 className="font-semibold mb-2">Your Products</h2>
          {loading ? (
            <div className="text-sm text-neutral-600">Loading…</div>
          ) : products.length > 0 ? (
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
              {products.map((p) => (
                <div key={p.id} className="rounded-2xl border p-4">
                  <div className="text-xs uppercase tracking-wide text-neutral-600">{p.product_type}</div>
                  <div className="font-semibold">{p.title}</div>
                  {p.description && (
                    <p className="text-sm text-neutral-700 mt-1 line-clamp-3">{p.description}</p>
                  )}
                  <div className="mt-2 font-semibold">${((p.price || 0) / 100).toFixed(2)}</div>
                  <div className="mt-3 flex gap-2">
                    <button
                      className="rounded-lg border px-3 py-1 text-sm"
                      onClick={() => router.push(`/products/${p.id}`)}
                    >
                      Edit
                    </button>
                    <button
                      className="rounded-lg border px-3 py-1 text-sm"
                      onClick={() => requestDelete(p.id)}
                    >
                      Delete
                    </button>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <div className="text-sm text-neutral-600">No products yet.</div>
          )}
        </section>

        {/* Delete confirm modal */}
        {confirmDeleteId && (
          <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/40 p-4">
            <div className="w-full max-w-md space-y-4 rounded-2xl bg-white p-5">
              <h3 className="text-lg font-semibold">Delete product?</h3>
              <p className="text-sm text-neutral-700">
                This action cannot be undone. Are you sure you want to delete this product?
              </p>
              {deleteErr && (
                <div className="rounded border border-red-300 bg-red-50 p-2 text-sm text-red-700">
                  {deleteErr}
                </div>
              )}
              <div className="flex items-center justify-end gap-2">
                <button
                  onClick={() => setConfirmDeleteId(null)}
                  className="rounded-xl border px-4 py-2 text-sm"
                  disabled={deleting}
                >
                  No
                </button>
                <button
                  onClick={confirmDelete}
                  className={`rounded-xl px-4 py-2 text-sm text-white ${
                    deleting ? "bg-neutral-400" : "bg-black"
                  }`}
                  disabled={deleting}
                >
                  {deleting ? "Deleting…" : "Yes, delete"}
                </button>
              </div>
            </div>
          </div>
        )}
      </main>
    </>
  );
}


===== FILE: sliptail-frontend\src\app\dashboard\products\new\page.tsx =====

"use client";

import { useEffect, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";

const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL?.replace(/\/$/, "") || "";

type ProductType = "purchase" | "membership" | "request";

type CreatorStatus = {
  profileComplete: boolean;
  stripeConnected: boolean;
  hasPublishedProduct?: boolean;
  isActive?: boolean;
};

function loadAuthSafe(): { token: string | null } | null {
  try {
    const raw = localStorage.getItem("auth");
    return raw ? JSON.parse(raw) : null;
  } catch {
    return null;
  }
}

function getErrorMessage(e: unknown): string {
  if (e instanceof Error) return e.message;
  if (typeof e === "string") return e;
  return "Something went wrong";
}

function isRecord(v: unknown): v is Record<string, unknown> {
  return typeof v === "object" && v !== null;
}
function getProp(obj: unknown, key: string): unknown {
  if (!isRecord(obj)) return undefined;
  return obj[key];
}
function getStringProp(obj: unknown, key: string): string | undefined {
  const val = getProp(obj, key);
  return typeof val === "string" ? val : undefined;
}
function getArrayOfStrings(obj: unknown, key: string): string[] | undefined {
  const val = getProp(obj, key);
  return Array.isArray(val) && val.every((x) => typeof x === "string")
    ? (val as string[])
    : undefined;
}
function getIdAsString(obj: unknown): string | undefined {
  if (!isRecord(obj)) return undefined;
  const val = obj["id"];
  if (typeof val === "string" || typeof val === "number") return String(val);
  return undefined;
}
function getProductId(payload: unknown): string | undefined {
  const product = getProp(payload, "product");
  return getIdAsString(product);
}
function extractServerError(payload: unknown, fallback: string): string {
  const err =
    getStringProp(payload, "error") || getStringProp(payload, "message");
  if (err) return err;
  try {
    return isRecord(payload) ? JSON.stringify(payload) : fallback;
  } catch {
    return fallback;
  }
}

function parsePriceToCents(priceStr: string) {
  const t = priceStr.trim();
  if (t === "") return 0;
  const n = Number(t);
  if (Number.isNaN(n)) return NaN;
  return Math.round(n * 100);
}

type ApiResponse = {
  ok: boolean;
  status: number;
  statusText: string;
  payload: unknown;
};
async function apiFetch(
  path: string,
  init?: RequestInit
): Promise<ApiResponse> {
  const url = `${API_BASE}${path}`;
  const res = await fetch(url, init);
  let payload: unknown = null;
  try {
    const ct = res.headers.get("content-type") || "";
    payload = ct.includes("application/json") ? await res.json() : await res.text();
  } catch {}
  return { ok: res.ok, status: res.status, statusText: res.statusText, payload };
}

export default function NewProductPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const fromSetup = (searchParams.get("from") || "").toLowerCase() === "setup";

  const [form, setForm] = useState<{
    productType: ProductType;
    title: string;
    description: string;
    price: string;
  }>({
    productType: "purchase",
    title: "",
    description: "",
    price: "",
  });

  const [file, setFile] = useState<File | null>(null);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const [status, setStatus] = useState<CreatorStatus | null>(null);
  const [statusLoading, setStatusLoading] = useState<boolean>(true);
  const [statusError, setStatusError] = useState<string | null>(null);

  const IDS = {
    productType: "productType",
    productTypeHelp: "productTypeHelp",
    title: "title",
    description: "description",
    price: "price",
    priceHelp: "priceHelp",
    file: "productFile",
    fileHelp: "fileHelp",
    errorBox: "formError",
    readinessBox: "readinessBox",
  };

  useEffect(() => {
    if (form.productType !== "purchase") setFile(null);
  }, [form.productType]);

  useEffect(() => {
    let cancelled = false;
    (async () => {
      setStatusLoading(true);
      setStatusError(null);
      try {
        const token = loadAuthSafe()?.token ?? null;
        const { ok, payload } = await apiFetch("/api/me/creator-status", {
          credentials: "include",
          headers: token ? { Authorization: `Bearer ${token}` } : undefined,
        });
        if (!ok) {
          if (!cancelled) setStatusError("Could not load creator status.");
          return;
        }
        if (isRecord(payload)) {
          const next: CreatorStatus = {
            profileComplete: Boolean(getProp(payload, "profileComplete")),
            stripeConnected: Boolean(getProp(payload, "stripeConnected")),
            hasPublishedProduct: Boolean(getProp(payload, "hasPublishedProduct")),
            isActive: Boolean(getProp(payload, "isActive")),
          };
          if (!cancelled) setStatus(next);
        }
      } catch (e) {
        if (!cancelled) setStatusError(getErrorMessage(e));
      } finally {
        if (!cancelled) setStatusLoading(false);
      }
    })();
    return () => {
      cancelled = true;
    };
  }, []);

  function onChange<K extends keyof typeof form>(key: K) {
    return (
      e: React.ChangeEvent<
        HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement
      >
    ) => {
      const value = e.target.value;
      setForm((prev) => ({ ...prev, [key]: value }));
    };
  }

  async function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    setError(null);

    const title = form.title.trim();
    const description = form.description.trim();
    const productType = form.productType;
    const cents = parsePriceToCents(form.price);

    if (!title) {
      setError("Please enter a product title.");
      return;
    }
    if (form.price.trim() !== "" && Number.isNaN(cents)) {
      setError("Price must be a number (omit symbols).");
      return;
    }
    if (productType === "purchase" && !file) {
      setError("Please select a file to upload for this purchase product.");
      return;
    }

    setSaving(true);
    try {
      const token = loadAuthSafe()?.token ?? null;

      if (productType === "purchase" && file) {
        const formData = new FormData();
        formData.append("file", file);
        formData.append("title", title);
        formData.append("description", description);
        formData.append("product_type", productType);
        formData.append("productType", productType);
        formData.append("price", String(cents));
        formData.append("price_cents", String(cents));

        const { ok, status, statusText, payload } = await apiFetch(
          "/api/products/upload",
          {
            method: "POST",
            credentials: "include",
            headers: token ? { Authorization: `Bearer ${token}` } : undefined,
            body: formData,
          }
        );

        if (!ok) {
          if (status === 403 && isRecord(payload)) {
            const missing = getArrayOfStrings(payload, "missing");
            const detail = getStringProp(payload, "detail");
            const base = extractServerError(
              payload,
              "Failed to create product with file"
            );
            const more =
              (missing && missing.length ? `\n• ${missing.join("\n• ")}` : "") +
              (detail ? `\n(${detail})` : "");
            setError(
              `Create failed (403 Forbidden) — ${base}${more ? `\n${more}` : ""}`
            );
          } else {
            const msg = extractServerError(
              payload,
              "Failed to create product with file"
            );
            setError(
              `Upload failed (${status}${
                statusText ? " " + statusText : ""
              }) — ${msg}`
            );
          }
          setSaving(false);
          return;
        }

        const productId = getProductId(payload);
        if (fromSetup) {
          router.push(
            `/creator/success${
              productId ? `?pid=${encodeURIComponent(productId)}` : ""
            }`
          );
        } else {
          router.push("/dashboard");
        }
        return;
      }

      const jsonPayload = {
        title,
        description,
        product_type: productType,
        productType,
        price: cents,
        price_cents: cents,
      };

      const { ok, status, statusText, payload } = await apiFetch(
        "/api/products/new",
        {
          method: "POST",
          credentials: "include",
          headers: {
            "Content-Type": "application/json",
            ...(token ? { Authorization: `Bearer ${token}` } : {}),
          },
          body: JSON.stringify(jsonPayload),
        }
      );

      if (!ok) {
        if (status === 403 && isRecord(payload)) {
          const missing = getArrayOfStrings(payload, "missing");
          const detail = getStringProp(payload, "detail");
          const base = extractServerError(payload, "Failed to create product");
          const more =
            (missing && missing.length ? `\n• ${missing.join("\n• ")}` : "") +
            (detail ? `\n(${detail})` : "");
          setError(
            `Create failed (403 Forbidden) — ${base}${more ? `\n${more}` : ""}`
          );
        } else {
          const msg = extractServerError(payload, "Failed to create product");
          setError(
            `Create failed (${status}${statusText ? " " + statusText : ""}) — ${msg}`
          );
        }
        setSaving(false);
        return;
      }

      const productId = getProductId(payload);
      if (fromSetup) {
        router.push(
          `/creator/success${
            productId ? `?pid=${encodeURIComponent(productId)}` : ""
          }`
        );
      } else {
        router.push("/dashboard");
      }
    } catch (e: unknown) {
      setError(getErrorMessage(e));
    } finally {
      setSaving(false);
    }
  }

  const showReadinessBanner =
    !statusLoading &&
    (statusError ||
      (status && (!status.profileComplete || !status.stripeConnected)));

  // Dynamic price label + placeholder
  const priceLabel =
    form.productType === "membership" ? "Price per month (USD)" : "Price (USD)";
  const pricePlaceholder =
    form.productType === "membership" ? "e.g., 12.00 per month" : "e.g., 12.00";
  const priceHelpText =
    form.productType === "membership"
      ? "Leave blank for 0 (free). Stored as integer cents (monthly)."
      : "Leave blank for 0 (free). Stored as integer cents.";

  return (
    <main className="mx-auto max-w-3xl px-4 py-8">
      <h1 className="mb-6 text-2xl font-bold tracking-tight md:text-3xl">
        Create a New Product
      </h1>

      {showReadinessBanner && (
        <div
          id={IDS.readinessBox}
          role="status"
          className={`mb-6 rounded-2xl border p-4 text-sm ${
            statusError
              ? "border-yellow-300 bg-yellow-50 text-yellow-900"
              : "border-blue-300 bg-blue-50 text-blue-900"
          }`}
        >
          {statusError ? (
            <div>{statusError}</div>
          ) : (
            <>
              {!status?.profileComplete || !status?.stripeConnected ? (
                <div className="space-y-2">
                  <div className="font-medium">
                    Before you can publish or create products:
                  </div>
                  <ul className="list-disc pl-5">
                    {!status?.profileComplete && (
                      <li>Complete your creator profile</li>
                    )}
                    {!status?.stripeConnected && (
                      <li>Connect your Stripe account</li>
                    )}
                  </ul>
                  <div>
                    <a
                      href="/creator/setup"
                      className="inline-block rounded-xl bg-black px-3 py-1 text-white"
                    >
                      Go to Creator Setup
                    </a>
                  </div>
                </div>
              ) : (
                <div>Ready to create! 🚀</div>
              )}
            </>
          )}
        </div>
      )}

      <form
        onSubmit={handleSubmit}
        className="space-y-6 rounded-2xl border p-6"
        noValidate
      >
        {/* Product Type */}
        <div className="space-y-2">
          <label
            htmlFor={IDS.productType}
            className="block text-sm font-medium"
          >
            Product Type
          </label>
          <select
            id={IDS.productType}
            name="productType"
            value={form.productType}
            onChange={onChange("productType")}
            aria-describedby={IDS.productTypeHelp}
            className="w-full rounded-xl border px-3 py-2"
          >
            <option value="purchase">Purchase (downloadable)</option>
            <option value="membership">Membership</option>
            <option value="request">Request</option>
          </select>
          <p id={IDS.productTypeHelp} className="text-xs text-neutral-600">
            Choose how customers will buy or access this.
          </p>
        </div>

        {/* Title */}
        <div className="space-y-2">
          <label htmlFor={IDS.title} className="block text-sm font-medium">
            Title
          </label>
          <input
            id={IDS.title}
            name="title"
            value={form.title}
            onChange={onChange("title")}
            placeholder="e.g., Preset Pack Vol. 1"
            autoComplete="off"
            required
            className="w-full rounded-xl border px-3 py-2"
          />
        </div>

        {/* Description */}
        <div className="space-y-2">
          <label
            htmlFor={IDS.description}
            className="block text-sm font-medium"
          >
            Description
          </label>
          <textarea
            id={IDS.description}
            name="description"
            value={form.description}
            onChange={onChange("description")}
            rows={5}
            placeholder="Tell buyers what they'll get"
            className="w-full rounded-xl border px-3 py-2"
          />
        </div>

        {/* Price (dynamic label for membership) */}
        <div className="space-y-2">
          <label htmlFor={IDS.price} className="block text-sm font-medium">
            {priceLabel}
          </label>
          <input
            id={IDS.price}
            name="price"
            value={form.price}
            onChange={onChange("price")}
            inputMode="decimal"
            placeholder={pricePlaceholder}
            aria-describedby={IDS.priceHelp}
            autoComplete="off"
            className="w-full rounded-xl border px-3 py-2"
          />
        </div>
        <p id={IDS.priceHelp} className="text-xs text-neutral-600">
          {priceHelpText}
        </p>

        {/* File (purchase only) */}
        {form.productType === "purchase" && (
          <div className="space-y-2">
            <label htmlFor={IDS.file} className="block text-sm font-medium">
              Upload File (delivered to buyers)
            </label>
            <input
              id={IDS.file}
              name="file"
              type="file"
              onChange={(e) => setFile(e.target.files?.[0] ?? null)}
              aria-describedby={IDS.fileHelp}
              required
              className="w-full rounded-xl border px-3 py-2"
            />
            <p id={IDS.fileHelp} className="text-xs text-neutral-600">
              PDF, images, video, text and other common formats supported.
            </p>
          </div>
        )}

        {error && (
          <div
            id={IDS.errorBox}
            role="alert"
            className="whitespace-pre-wrap rounded-xl border border-red-300 bg-red-50 p-3 text-sm text-red-800"
          >
            {error}
          </div>
        )}

        <div className="flex items-center gap-3">
          <button
            type="submit"
            disabled={saving}
            className={`rounded-xl px-4 py-2 text-sm ${
              saving ? "bg-neutral-300 text-neutral-600" : "bg-black text-white"
            }`}
          >
            {saving ? "Creating…" : "Create Product"}
          </button>
          <button
            type="button"
            onClick={() => router.back()}
            className="rounded-xl border px-4 py-2 text-sm"
          >
            Cancel
          </button>
        </div>
      </form>
    </main>
  );
}


===== FILE: sliptail-frontend\src\app\feed\page.tsx =====

import { fetchApi } from "@/lib/api";

type Membership = {
  creator_id: number;
  status: string;
  has_access: boolean;
};

type Post = {
  id: number;
  creator_id: number;
  title: string | null;
  body: string | null;
  media_path: string | null;
  created_at: string;
};

export const revalidate = 0;

async function getMemberships() {
  const data = (await fetchApi<{ memberships: Membership[] }>("/api/memberships/mine")) as { memberships: Membership[] };
  return (data?.memberships ?? []).filter((m) => m.has_access);
}

async function getPostsForCreator(creatorId: number) {
  const data = (await fetchApi<{ posts: Post[] }>(`/api/posts/${creatorId}`)) as { posts: Post[] };
  return data?.posts ?? [];
}

export default async function MembershipFeedPage() {
  const memberships = await getMemberships();
  const postsArrays = await Promise.all(memberships.map((m) => getPostsForCreator(m.creator_id)));
  const posts = postsArrays.flat().sort((a, b) => +new Date(b.created_at) - +new Date(a.created_at));

  return (
    <main className="max-w-5xl mx-auto p-4 space-y-4">
      <h1 className="text-2xl font-bold">Membership Feed</h1>
      {posts.length === 0 && <div className="text-sm text-neutral-600">No posts yet.</div>}
      {posts.map((post) => (
        <article key={post.id} className="rounded-2xl border p-3">
          <div className="text-xs opacity-70 mb-1">
            Creator #{post.creator_id} · {new Date(post.created_at).toLocaleString()}
          </div>
          {post.title && <h2 className="font-semibold">{post.title}</h2>}
          {post.media_path && (
            <div className="relative aspect-video rounded-xl overflow-hidden bg-neutral-100 mt-2">
              {/* eslint-disable-next-line @next/next/no-img-element */}
              <img src={post.media_path} alt="post" className="h-full w-full object-cover" />
            </div>
          )}
          {post.body && <p className="mt-2 text-sm whitespace-pre-wrap">{post.body}</p>}
        </article>
      ))}
    </main>
  );
}

===== FILE: sliptail-frontend\src\app\globals.css =====

@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

:root {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

@keyframes fade-in-up {
  0% {
    opacity: 0;
    transform: translateY(20px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

.animate-fade-in-up {
  animation: fade-in-up 0.8s ease-out both;
}


===== FILE: sliptail-frontend\src\app\layout.tsx =====

import type { Metadata } from "next";
import "@/app/globals.css";
import Navbar from "@/components/Navbar";
import Footer from "@/components/Footer";
import { AuthProvider } from "@/components/auth/AuthProvider";
import Toast from "@/components/Toast";

export const metadata: Metadata = {
  title: "Sliptail",
  description: "Memberships, downloads, and custom requests for creators.",
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body className="flex min-h-screen flex-col bg-white text-black">
        {/* Wrap the entire app with AuthProvider so useAuth works anywhere */}
        <AuthProvider>
          <Navbar />
          <main className="flex-1">{children}</main>
          <Toast />
          <Footer />
        </AuthProvider>
      </body>
    </html>
  );
}

===== FILE: sliptail-frontend\src\app\notifications\page.tsx =====

"use client";

import { useEffect, useMemo, useState, useCallback } from "react";

type Notification = {
  id: number;
  title: string | null;
  body: string | null;
  type: string | null;
  metadata?: Record<string, unknown>;
  read_at: string | null;
  created_at: string;
};

export default function NotificationsPage() {
  const [items, setItems] = useState<Notification[]>([]);
  const [loading, setLoading] = useState(true);
  const [unreadOnly, setUnreadOnly] = useState(false);

  const apiBase = useMemo(
    () => (process.env.NEXT_PUBLIC_API_URL || "http://localhost:5000").replace(/\/$/, ""),
    []
  );

  const load = useCallback(async () => {
    setLoading(true);
    const res = await fetch(
      `${apiBase}/api/notifications?limit=50&offset=0&unread_only=${unreadOnly}`,
      { credentials: "include" }
    );
    const data = await res.json();
    setItems(data?.notifications ?? []);
    setLoading(false);
  }, [apiBase, unreadOnly]);

  useEffect(() => {
    load();
  }, [load]);

  const markRead = useCallback(
    async (id: number) => {
      await fetch(`${apiBase}/api/notifications/${id}/read`, {
        method: "POST",
        credentials: "include",
      });
      setItems((prev) =>
        prev.map((n) => (n.id === id ? { ...n, read_at: new Date().toISOString() } : n))
      );
    },
    [apiBase]
  );

  const markAll = useCallback(async () => {
    await fetch(`${apiBase}/api/notifications/read-all`, {
      method: "POST",
      credentials: "include",
    });
    setItems((prev) => prev.map((n) => ({ ...n, read_at: new Date().toISOString() })));
  }, [apiBase]);

  return (
    <main className="max-w-4xl mx-auto p-4 space-y-4">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Notifications</h1>
        <div className="flex items-center gap-2">
          <label className="text-sm flex items-center gap-1">
            <input
              type="checkbox"
              checked={unreadOnly}
              onChange={(e) => setUnreadOnly(e.target.checked)}
            />
            Unread only
          </label>
          <button onClick={markAll} className="rounded-lg border px-3 py-1 text-sm">
            Mark all read
          </button>
        </div>
      </div>

      {loading && <div className="text-sm text-neutral-600">Loading…</div>}

      <ul className="space-y-2">
        {items.map((n) => (
          <li key={n.id} className="rounded-2xl border p-3">
            <div className="flex items-center justify-between">
              <div className="font-medium">{n.title || n.type || "Notification"}</div>
              {!n.read_at && (
                <button onClick={() => markRead(n.id)} className="text-sm underline">
                  Mark read
                </button>
              )}
            </div>
            {n.body && <p className="text-sm mt-1">{n.body}</p>}
            <div className="text-xs text-neutral-500 mt-1">
              {new Date(n.created_at).toLocaleString()}
            </div>
          </li>
        ))}
      </ul>
    </main>
  );
}

===== FILE: sliptail-frontend\src\app\page.tsx =====

"use client";

import Image from "next/image";
import Link from "next/link";
import { useEffect, useState } from "react";
import CreatorCard from "@/components/CreatorCard";
import StartSellingButton from "@/components/StartSellingButton";
import { useAuth } from "@/components/auth/AuthProvider"; // <-- added

/* ----------------------------- Types ----------------------------- */

type FeaturedApiCreator = {
  creator_id: number;
  display_name: string;
  bio: string | null;
  profile_image: string | null;
  average_rating: string | number | null;
  gallery?: string[] | null;
};
type FeaturedApiResponse =
  | { creators: FeaturedApiCreator[] }
  | FeaturedApiCreator[];

interface CategoryRow {
  id: number;
  name: string;
  slug: string;
  active?: boolean;
  creators_count?: number;
}

/* --------------------------- Data loaders --------------------------- */

const API_BASE =
  process.env.NEXT_PUBLIC_API_BASE_URL?.replace(/\/$/, "") || "";

/** Normalize featured creators payload */
function normalizeFeatured(payload: FeaturedApiResponse): FeaturedApiCreator[] {
  return Array.isArray(payload) ? payload : payload.creators ?? [];
}

async function fetchFeatured(): Promise<FeaturedApiCreator[]> {
  const res = await fetch(`${API_BASE}/api/creators/featured`, {
    credentials: "include",
  });
  if (!res.ok) return [];
  const payload: FeaturedApiResponse = await res.json();
  return normalizeFeatured(payload);
}

/** Normalize category array safely */
function normalizeCategoryArray(payload: unknown): CategoryRow[] {
  if (Array.isArray(payload)) {
    return payload.filter((r): r is CategoryRow => {
      return typeof r === "object" && r !== null && "id" in r && "name" in r;
    });
  }
  if (payload && typeof payload === "object") {
    const obj = payload as Record<string, unknown>;
    if (Array.isArray(obj.categories)) {
      return normalizeCategoryArray(obj.categories);
    }
    if (Array.isArray(obj.data)) {
      return normalizeCategoryArray(obj.data);
    }
  }
  return [];
}

async function fetchCategories(): Promise<CategoryRow[]> {
  const urls = [
    `${API_BASE}/api/categories?count=true`,
    `${API_BASE}/api/categories`,
  ];

  for (const url of urls) {
    try {
      const res = await fetch(url, { credentials: "include" });
      if (!res.ok) continue;
      const payload: unknown = await res.json();
      const rows = normalizeCategoryArray(payload).filter((r) =>
        r.active === false ? false : true
      );
      if (rows.length) return rows;
    } catch {
      // try next URL
    }
  }

  return [];
}

/* --------------------------------- Page --------------------------------- */

export default function Home() {
  const [featured, setFeatured] = useState<FeaturedApiCreator[]>([]);
  const [categories, setCategories] = useState<CategoryRow[]>([]);
  const [loading, setLoading] = useState(true);

  const { user, loading: authLoading } = useAuth(); // <-- read auth

  // Helper: render the Start Selling CTA with routing override for signed-in users
  const StartSellingCTA = ({ children }: { children: React.ReactNode }) => {
    // While auth is hydrating, render the original component (keeps your UX smooth)
    if (authLoading) {
      return (
        <StartSellingButton className="rounded-md bg-white px-8 py-3 font-semibold text-green-700 shadow transition hover:scale-105">
          {children}
        </StartSellingButton>
      );
    }

    // If signed out, keep your existing StartSellingButton behavior
    if (!user) {
      return (
        <StartSellingButton className="rounded-md bg-white px-8 py-3 font-semibold text-green-700 shadow transition hover:scale-105">
          {children}
        </StartSellingButton>
      );
    }

    // Signed-in: route based on role
    const isCreatorLike =
      user.role === "creator" || user.role === "admin" 

    const href = isCreatorLike ? "/dashboard" : "/creator/setup";

    return (
      <Link
        href={href}
        className="rounded-md bg-white px-8 py-3 font-semibold text-green-700 shadow transition hover:scale-105"
      >
        {children}
      </Link>
    );
  };

  useEffect(() => {
    let cancelled = false;
    (async () => {
      setLoading(true);
      try {
        const [feat, cats] = await Promise.all([
          fetchFeatured(),
          fetchCategories(),
        ]);
        if (!cancelled) {
          setFeatured(feat);
          setCategories(cats);
        }
      } catch {
        if (!cancelled) {
          setFeatured([]);
          setCategories([]);
        }
      } finally {
        if (!cancelled) setLoading(false);
      }
    })();
    return () => {
      cancelled = true;
    };
  }, []);

  return (
    <div className="font-sans">
      {/* Hero Section */}
      <section className="relative overflow-hidden bg-gradient-to-r from-green-400 to-green-600 text-white">
        <div className="mx-auto max-w-6xl px-6 py-24 text-center">
          <div className="mx-auto mb-6 w-40 animate-fade-in-up">
            <Image src="/sliptail-logo.png" alt="Sliptail" width={160} height={50} />
          </div>
        <h1 className="mb-4 text-5xl font-bold animate-fade-in-up [animation-delay:200ms]">
            Support and Create
          </h1>
          <p className="mx-auto mb-8 max-w-2xl text-lg animate-fade-in-up [animation-delay:400ms]">
            Sliptail helps creators provide memberships, digital downloads, and custom requests — all in one place.
          </p>
          <div className="flex flex-col items-center justify-center gap-4 sm:flex-row">
            {/* Only the routing behavior of this button changes based on auth/role */}
            <StartSellingCTA>For Creators: Start Selling</StartSellingCTA>

            <Link
              href="/creators"
              className="rounded-md border border-white px-8 py-3 font-semibold text-white transition hover:scale-105 hover:bg-white/20"
            >
              For Fans: Explore Creators
            </Link>
          </div>
        </div>
      </section>

      {/* Featured Creators */}
      <section className="bg-gray-50 py-16">
        <div className="mx-auto max-w-6xl px-6">
          <h2 className="mb-8 text-center text-3xl font-bold">Featured Creators</h2>
          {loading ? (
            <div className="grid justify-items-center gap-6 sm:grid-cols-2 md:grid-cols-3">
              {[...Array(3)].map((_, i) => (
                <div key={i} className="h-64 w-full max-w-sm animate-pulse rounded-2xl bg-white p-4 shadow" />
              ))}
            </div>
          ) : (
            <div className="grid justify-items-center gap-6 sm:grid-cols-2 md:grid-cols-3">
              {featured.map((c) => (
                <CreatorCard
                  key={c.creator_id}
                  creator={{
                    id: String(c.creator_id),
                    displayName: c.display_name,
                    avatar: c.profile_image ?? "",
                    bio: c.bio ?? "",
                    rating:
                      typeof c.average_rating === "string"
                        ? parseFloat(c.average_rating) || 0
                        : Number(c.average_rating || 0),
                    photos: (c.gallery ?? []).slice(0, 4),
                  }}
                />
              ))}
              {featured.length === 0 && (
                <div className="col-span-full text-center text-sm text-neutral-600">
                  No featured creators yet.
                </div>
              )}
            </div>
          )}
        </div>
      </section>

      {/* Categories */}
      <section className="mx-auto max-w-6xl px-6 py-16">
        <h2 className="mb-4 text-2xl font-bold">Explore by category</h2>
        {loading ? (
          <div className="flex flex-wrap gap-3">
            {[...Array(6)].map((_, i) => (
              <span key={i} className="h-9 w-28 animate-pulse rounded-full border border-green-200 bg-green-50/50" />
            ))}
          </div>
        ) : (
          <div className="flex flex-wrap gap-3">
            {categories.map((cat) => (
              <a
                key={cat.id}
                href={`/creators?categoryId=${encodeURIComponent(cat.id)}`}
                className="rounded-full border border-green-500 px-5 py-2 capitalize text-green-700 transition hover:bg-green-50"
                title={
                  typeof cat.creators_count === "number"
                    ? `${cat.creators_count} creators`
                    : undefined
                }
              >
                {cat.name}
              </a>
            ))}
            {categories.length === 0 && (
              <div className="text-sm text-neutral-600">No categories yet.</div>
            )}
          </div>
        )}
      </section>

      {/* CTA */}
      <section className="bg-gradient-to-r from-green-500 to-green-700 py-20 text-center text-white">
        <h2 className="mb-4 text-4xl font-bold">Join Sliptail today</h2>
        <p className="mx-auto mb-8 max-w-xl text-lg">
          Whether you’re a creator or a fan, Sliptail makes connecting simple,
          safe, and fun.
        </p>
        {/* Bottom button shares the same smart routing */}
        <StartSellingCTA>Get Started</StartSellingCTA>
      </section>
    </div>
  );
}



===== FILE: sliptail-frontend\src\app\products\error.tsx =====

"use client";
export default function ErrorProducts({ error }: { error: Error }) {
return (
<main className="mx-auto max-w-6xl px-4 py-10">
<div className="rounded-2xl border p-6 text-sm text-red-600">{error.message || "Failed to load products."}</div>
</main>
);
}

===== FILE: sliptail-frontend\src\app\products\Loading.tsx =====

export default function LoadingProducts() {
return (
<main className="mx-auto max-w-6xl px-4 py-10">
<div className="h-8 w-48 animate-pulse rounded bg-neutral-200" />
<div className="mt-6 grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
{Array.from({ length: 6 }).map((_, i) => (
<div key={i} className="h-64 animate-pulse rounded-2xl border bg-neutral-50" />
))}
</div>
</main>
);
}

===== FILE: sliptail-frontend\src\app\products\page.tsx =====

import { fetchApi } from "@/lib/api";
import ProductCard from "@/components/products/ProductCard";
import { Product } from "@/types/products";

export const dynamic = "force-dynamic"; // ensure fresh fetch in dev

export default async function ProductsPage() {
  // Cast to Product[] since we're not using raw:true in fetchApi
  const products = (await fetchApi<Product[]>("/api/products")) as Product[];

  return (
    <main className="mx-auto max-w-6xl px-4 py-10">
      <div className="mb-6 flex items-end justify-between">
        <div>
          <h1 className="text-2xl font-bold tracking-tight md:text-3xl">Products</h1>
          <p className="mt-1 text-sm text-neutral-600">
            Downloads, memberships, and custom requests.
          </p>
        </div>
      </div>

      {(!products || products.length === 0) ? (
        <div className="rounded-2xl border p-6 text-sm text-neutral-600">
          No products yet.
        </div>
      ) : (
        <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
          {products.map((p) => (
            <ProductCard key={p.id} product={p} />
          ))}
        </div>
      )}
    </main>
  );
}

===== FILE: sliptail-frontend\src\app\products\[id]\page.tsx =====

"use client";

import { useEffect, useMemo, useState } from "react";
import { useParams, useRouter } from "next/navigation";

/** Types */
type ProductType = "purchase" | "membership" | "request";

/** Safe helpers */
function isRecord(v: unknown): v is Record<string, unknown> {
  return typeof v === "object" && v !== null;
}
function getStringProp(obj: unknown, key: string): string | undefined {
  if (!isRecord(obj)) return undefined;
  const v = obj[key];
  return typeof v === "string" ? v : undefined;
}
function getNumberProp(obj: unknown, key: string): number | undefined {
  if (!isRecord(obj)) return undefined;
  const v = obj[key];
  return typeof v === "number" ? v : undefined;
}
function extractMessage(obj: unknown, fallback: string): string {
  return getStringProp(obj, "error") || getStringProp(obj, "message") || fallback;
}

/** Local auth loader */
function loadAuthSafe(): { token: string | null } | null {
  try {
    const raw = localStorage.getItem("auth");
    return raw ? JSON.parse(raw) : null;
  } catch {
    return null;
  }
}

/** Price helpers */
function dollarsFromCents(cents: number | undefined | null): string {
  const n = typeof cents === "number" ? cents : 0;
  return (n / 100).toFixed(2);
}
function centsFromDollars(input: string): number | null {
  const t = input.trim();
  if (t === "") return 0;
  const n = Number(t);
  if (Number.isNaN(n)) return null;
  return Math.round(n * 100);
}

export default function ProductEditPage() {
  const router = useRouter();
  const params = useParams<{ id: string }>();
  const routeId = params?.id;
  const productId = Array.isArray(routeId) ? routeId[0] : routeId;

  const apiBase = useMemo(
    () => (process.env.NEXT_PUBLIC_API_URL || "http://localhost:5000").replace(/\/$/, ""),
    []
  );

  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [replacingFile, setReplacingFile] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Editable fields
  const [title, setTitle] = useState("");
  const [description, setDescription] = useState<string>("");
  const [priceInput, setPriceInput] = useState<string>(""); // dollars as string
  const [productType, setProductType] = useState<ProductType>("purchase");

  // File replacement (purchase only)
  const [file, setFile] = useState<File | null>(null);

  useEffect(() => {
    let cancelled = false;
    if (!productId) {
      setError("Missing product id in route.");
      setLoading(false);
      return;
    }

    async function load() {
      setError(null);
      setLoading(true);
      try {
        const res = await fetch(`${apiBase}/api/products/${encodeURIComponent(productId)}`, {
          credentials: "include",
        });
        if (!res.ok) {
          const text = await res.text().catch(() => "");
          throw new Error(text || `Failed to load product (${res.status})`);
        }
        const data: unknown = await res.json();

        const titleV = getStringProp(data, "title") ?? "";
        const descV = getStringProp(data, "description") ?? "";
        const typeV = (getStringProp(data, "product_type") as ProductType) || "purchase";
        const priceV =
          getNumberProp(data, "price") ??
          ((): number => {
            const raw = getStringProp(data, "price");
            return raw ? Number(raw) || 0 : 0;
          })();

        if (!cancelled) {
          setTitle(titleV);
          setDescription(descV);
          setProductType(typeV);
          setPriceInput(dollarsFromCents(priceV));
        }
      } catch (e) {
        if (!cancelled) setError(e instanceof Error ? e.message : "Failed to load product");
      } finally {
        if (!cancelled) setLoading(false);
      }
    }
    load();
    return () => {
      cancelled = true;
    };
  }, [apiBase, productId]);

  async function saveDetails(e: React.FormEvent) {
    e.preventDefault();
    if (!productId) return;
    setError(null);

    const cents = centsFromDollars(priceInput);
    if (cents == null) {
      setError("Price must be a number (omit symbols).");
      return;
    }
    if (!title.trim()) {
      setError("Please enter a title.");
      return;
    }

    setSaving(true);
    try {
      const token = loadAuthSafe()?.token ?? null;
      const headers: Record<string, string> = { "Content-Type": "application/json" };
      if (token) headers.Authorization = `Bearer ${token}`;

      const res = await fetch(`${apiBase}/api/products/${encodeURIComponent(productId)}`, {
        method: "PUT",
        credentials: "include",
        headers,
        body: JSON.stringify({
          title: title.trim(),
          description: description.trim(),
          price: cents,
        }),
      });

      if (!res.ok) {
        const payload = await res.json().catch(() => ({}));
        throw new Error(extractMessage(payload, "Could not update product"));
      }

      router.push("/dashboard");
    } catch (e) {
      setError(e instanceof Error ? e.message : "Failed to save changes");
    } finally {
      setSaving(false);
    }
  }

  async function replaceFile(e: React.FormEvent) {
    e.preventDefault();
    if (!productId) return;
    if (!file) {
      setError("Please choose a file to upload.");
      return;
    }
    setError(null);
    setReplacingFile(true);
    try {
      const token = loadAuthSafe()?.token ?? null;

      const formData = new FormData();
      formData.append("file", file);

      const headers: Record<string, string> = {};
      if (token) headers.Authorization = `Bearer ${token}`;

      const res = await fetch(`${apiBase}/api/products/${encodeURIComponent(productId)}/file`, {
        method: "PUT",
        credentials: "include",
        headers,
        body: formData,
      });

      if (!res.ok) {
        const payload = await res.json().catch(() => ({}));
        throw new Error(extractMessage(payload, "Failed to update product file"));
      }

      router.push("/dashboard");
    } catch (e) {
      setError(e instanceof Error ? e.message : "Failed to replace file");
    } finally {
      setReplacingFile(false);
    }
  }

  const priceLabel =
    productType === "membership" ? "Price per month (USD)" : "Price (USD)";
  const pricePlaceholder =
    productType === "membership" ? "e.g., 12.00 per month" : "e.g., 12.00";

  return (
    <main className="mx-auto max-w-3xl px-4 py-8">
      <h1 className="mb-6 text-2xl font-bold tracking-tight md:text-3xl">
        {loading ? "Loading…" : "Edit Product"}
      </h1>

      {error && (
        <div className="mb-4 rounded-xl border border-red-300 bg-red-50 p-3 text-sm text-red-800">
          {error}
        </div>
      )}

      <form onSubmit={saveDetails} className="space-y-6 rounded-2xl border p-6" noValidate>
        {/* Product Type (read-only) */}
        <div className="space-y-2">
          <label className="block text-sm font-medium" htmlFor="productType">
            Product Type
          </label>
          <input
            id="productType"
            value={productType}
            readOnly
            className="w-full rounded-xl border px-3 py-2 bg-neutral-50 text-neutral-700"
          />
          <p className="text-xs text-neutral-600">Product type cannot be changed once created.</p>
        </div>

        {/* Title */}
        <div className="space-y-2">
          <label className="block text-sm font-medium" htmlFor="title">
            Title
          </label>
          <input
            id="title"
            name="title"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full rounded-xl border px-3 py-2"
            required
          />
        </div>

        {/* Description */}
        <div className="space-y-2">
          <label className="block text-sm font-medium" htmlFor="description">
            Description
          </label>
          <textarea
            id="description"
            name="description"
            rows={5}
            value={description ?? ""}
            onChange={(e) => setDescription(e.target.value)}
            className="w-full rounded-xl border px-3 py-2"
          />
        </div>

        {/* Price (dynamic label for membership) */}
        <div className="space-y-2">
          <label className="block text-sm font-medium" htmlFor="price">
            {priceLabel}
          </label>
          <input
            id="price"
            name="price"
            inputMode="decimal"
            value={priceInput}
            onChange={(e) => setPriceInput(e.target.value)}
            className="w-full rounded-xl border px-3 py-2"
            placeholder={pricePlaceholder}
          />
          <p className="text-xs text-neutral-600">
            Stored as integer cents{productType === "membership" ? " (monthly)." : "."}
          </p>
        </div>

        <div className="flex items-center gap-3">
          <button
            type="submit"
            disabled={saving}
            className={`rounded-xl px-4 py-2 text-sm ${
              saving ? "bg-neutral-300 text-neutral-600" : "bg-black text-white"
            }`}
          >
            {saving ? "Saving…" : "Save Changes"}
          </button>
          <button
            type="button"
            onClick={() => router.push("/dashboard")}
            className="rounded-xl border px-4 py-2 text-sm"
          >
            Cancel
          </button>
        </div>
      </form>

      {/* File replacement for purchase products */}
      {productType === "purchase" && (
        <form onSubmit={replaceFile} className="mt-6 space-y-4 rounded-2xl border p-6" noValidate>
          <div className="space-y-2">
            <label className="block text-sm font-medium" htmlFor="file">
              Replace File (delivered to buyers)
            </label>
            <input
              id="file"
              name="file"
              type="file"
              onChange={(e) => setFile(e.target.files?.[0] ?? null)}
              className="w-full rounded-xl border px-3 py-2"
            />
            <p className="text-xs text-neutral-600">
              PDF, images, video, text and other common formats supported.
            </p>
          </div>
          <button
            type="submit"
            disabled={replacingFile}
            className={`rounded-xl px-4 py-2 text-sm ${
              replacingFile ? "bg-neutral-300 text-neutral-600" : "bg-black text-white"
            }`}
          >
            {replacingFile ? "Updating…" : "Replace File"}
          </button>
        </form>
      )}
    </main>
  );
}

===== FILE: sliptail-frontend\src\app\products\[id]\ProductDetail.tsx =====

"use client";
import { useState } from "react";
import { Product } from "@/types/products";
import { formatUSD } from "@/lib/format";
import { useCart } from "@/components/cart/CartProvider";

function isErrorWithMessage(err: unknown): err is { message: string } {
  return (
    typeof err === "object" &&
    err !== null &&
    "message" in err &&
    typeof (err as { message: unknown }).message === "string"
  );
}

function getErrorMessage(err: unknown): string {
  if (err instanceof Error) return err.message;
  if (typeof err === "string") return err;
  if (isErrorWithMessage(err)) return err.message;
  return "Something went wrong";
}

export default function ProductDetail({ product }: { product: Product }) {
  const { addItem } = useCart();
  const [adding, setAdding] = useState(false);
  const [msg, setMsg] = useState<string | null>(null);

  async function handleAdd() {
    setAdding(true);
    setMsg(null);
    try {
      await addItem({ productId: product.id, quantity: 1 });
      setMsg("Added to cart");
    } catch (err: unknown) {
      setMsg(getErrorMessage(err));
    } finally {
      setAdding(false);
    }
  }

  const isMembership = product.productType === "membership";

  return (
    <div className="grid grid-cols-1 gap-8 md:grid-cols-2">
      <div className="overflow-hidden rounded-2xl border">
        {product.thumbnailUrl ? (
          <img src={product.thumbnailUrl} alt={product.title} className="w-full object-cover" />
        ) : (
          <div className="flex aspect-[4/3] w-full items-center justify-center bg-neutral-100">No image</div>
        )}
      </div>

      <div>
        <h1 className="text-2xl font-bold tracking-tight md:text-3xl">{product.title}</h1>
        <p className="mt-2 text-neutral-700">{product.description || ""}</p>

        <div className="mt-6">
          <div className="text-2xl font-bold">{formatUSD(product.price)}</div>
          <button
            onClick={handleAdd}
            disabled={adding}
            className="mt-3 inline-flex items-center justify-center rounded-2xl bg-black px-4 py-2 text-sm font-semibold text-white hover:bg-black/90 disabled:opacity-60"
          >
            {adding ? (isMembership ? "Joining..." : "Adding...") : isMembership ? "Join membership" : "Add to cart"}
          </button>
          {msg && <div className="mt-2 text-xs text-neutral-600">{msg}</div>}
        </div>
      </div>
    </div>
  );
}

===== FILE: sliptail-frontend\src\app\purchases\page.tsx =====

// src/app/purchases/page.tsx
"use client";

import { useEffect, useState } from "react";
import { fetchApi } from "@/lib/api"; // your helper
// optional: your toast hook
function useToast(){ return { error:(m:string)=>console.error(m), success:(m:string)=>console.log(m) } }

type Order = {
  id: number;
  product_id: number | null;
  amount_cents: number;
  status: string;
  created_at: string;
};

export default function PurchasesPage({ searchParams }: { searchParams: { toast?: string } }) {
  const [orders, setOrders] = useState<Order[] | null>(null);
  const [loading, setLoading] = useState(true);
  const { success, error } = useToast();

  useEffect(() => {
    if (searchParams.toast) success(searchParams.toast);
  }, [searchParams.toast, success]);

  useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        const data = await fetchApi<Order[]>("/api/orders", {
          // IMPORTANT: see api.ts change below — credentials must be included
          method: "GET",
        });
        if (!cancelled) setOrders(data);
      } catch (e) {
        const msg = e instanceof Error ? e.message : "Failed to load purchases.";
        error(msg);
      } finally {
        if (!cancelled) setLoading(false);
      }
    })();
    return () => { cancelled = true; };
  }, [error]);

  return (
    <div className="mx-auto max-w-3xl p-6">
      <h1 className="text-2xl font-bold">Your Purchases</h1>

      {loading && <div className="mt-6 h-2 w-40 animate-pulse rounded bg-green-500/40" />}

      {!loading && orders && orders.length === 0 && (
        <p className="mt-4 text-neutral-600">No purchases yet.</p>
      )}

      {!loading && orders && orders.length > 0 && (
        <ul className="mt-6 space-y-3">
          {orders.map(o => (
            <li key={o.id} className="rounded border p-3">
              <div className="flex items-center justify-between">
                <span>Order #{o.id}</span>
                <span className="font-semibold">${(o.amount_cents/100).toFixed(2)}</span>
              </div>
              <div className="text-sm text-neutral-600">
                {o.status} · {new Date(o.created_at).toLocaleString()}
              </div>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}


===== FILE: sliptail-frontend\src\app\purchases\success\page.tsx =====

"use client";
import { useEffect } from "react";
import { useRouter, useSearchParams } from "next/navigation";

export default function PurchasesSuccessAlias() {
  const router = useRouter();
  const sp = useSearchParams();
  const sessionId = sp.get("session_id") || "";
  const pid = sp.get("pid") || "";
  const action = sp.get("action") || "";

  useEffect(() => {
    const q = new URLSearchParams();
    if (sessionId) q.set("sid", sessionId); // your success page can accept sid
    if (pid) q.set("pid", pid);
    if (action) q.set("action", action);
    router.replace(`/checkout/success${q.size ? `?${q.toString()}` : ""}`);
  }, [router, sessionId, pid, action]);

  return null;
}

===== FILE: sliptail-frontend\src\app\requests\new\page.tsx =====

// app/requests/new/page.tsx
"use client";

import { useEffect, useMemo, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";

const API_BASE =
  process.env.NEXT_PUBLIC_API_BASE_URL?.replace(/\/$/, "") || "";

// Replace with your real toast system/hook
function useToast() {
  return {
    success: (msg: string) => console.log("[TOAST SUCCESS]", msg),
    error: (msg: string) => console.error("[TOAST ERROR]", msg),
  };
}

type CreateRequestOk = { ok: true; requestId: number };
type CreateRequestErr = { ok: false; error: string };
type CreateRequestResponse = CreateRequestOk | CreateRequestErr;


export default function NewRequestPage() {
  const search = useSearchParams();
  const router = useRouter();
  const { success, error } = useToast();

  const orderId = useMemo(() => {
    const raw = search.get("orderId");
    const num = raw ? Number(raw) : NaN;
    return Number.isFinite(num) ? num : 0;
  }, [search]);

  const initialToast = search.get("toast");

  const [details, setDetails] = useState<string>("");
  const [file, setFile] = useState<File | null>(null);
  const [submitting, setSubmitting] = useState<boolean>(false);

  // If a toast was passed via query (legacy), show it once via console placeholder
  useEffect(() => {
    if (initialToast && initialToast.trim()) success(initialToast);
  }, [initialToast, success]);

  if (!orderId) {
    return (
      <div className="mx-auto max-w-xl p-8">
        <h1 className="text-xl font-semibold">Invalid request</h1>
        <p className="mt-2 text-neutral-600">We couldn’t find your order.</p>
        <button
          onClick={() => router.replace("/purchases")}
          className="mt-4 rounded border px-4 py-2"
        >
          Go to Purchases
        </button>
      </div>
    );
  }

  async function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    setSubmitting(true);
    try {
      const formData = new FormData();
      formData.append("orderId", String(orderId));
      formData.append("details", details);
      if (file) formData.append("attachment", file);

      const res = await fetch(`${API_BASE}/api/requests`, {
        method: "POST",
        credentials: "include",
        body: formData,
      });

      const payload: unknown = await res.json();
      // Narrow unknown to our expected shape:
      const parsed = payload as CreateRequestResponse;

      if (!res.ok || !parsed || parsed.ok !== true) {
        const message =
          parsed && "error" in parsed && typeof parsed.error === "string"
            ? parsed.error
            : "Request failed";
        throw new Error(message);
      }

      const toastMsg = initialToast && initialToast.includes("Thanks for Supporting")
        ? initialToast
        : "Thanks for Supporting Your Creator";
      try {
        const { setFlash } = await import("@/lib/flash");
        setFlash({ kind: "success", title: toastMsg, ts: Date.now() });
      } catch {}
      router.replace(`/purchases`);
    } catch (e) {
      const message =
        e instanceof Error ? e.message : "Could not submit your request.";
      error(message);
    } finally {
      setSubmitting(false);
    }
  }

  function handleFileChange(ev: React.ChangeEvent<HTMLInputElement>) {
    const f = ev.currentTarget.files?.[0] ?? null;
    setFile(f);
  }

  function doLater() {
    const toastMsg = initialToast && initialToast.includes("Thanks for Supporting")
      ? initialToast
      : "Thanks for Supporting Your Creator";
    import("@/lib/flash").then(m => m.setFlash({ kind: "success", title: toastMsg, ts: Date.now() })).catch(()=>{});
    router.replace(`/purchases`);
  }

  return (
    <div className="mx-auto max-w-2xl p-6">
      <h1 className="mb-2 text-2xl font-bold">Tell the creator what you need</h1>
      <p className="mb-6 text-neutral-600">
        Add a brief description and any reference media (optional). You can also
        do this later.
      </p>

      <form onSubmit={handleSubmit} className="grid gap-4">
        <label className="grid gap-2">
          <span className="text-sm font-medium">Description</span>
          <textarea
            className="min-h-[120px] w-full rounded border p-3"
            value={details}
            onChange={(ev) => setDetails(ev.target.value)}
            placeholder="Describe your request…"
            required
          />
        </label>

        <label className="grid gap-2">
          <span className="text-sm font-medium">Attachment (optional)</span>
          <input
            type="file"
            accept="image/*,video/*,application/pdf"
            onChange={handleFileChange}
            className="block"
          />
          {file && (
            <span className="text-xs text-neutral-600">
              Selected: {file.name}
            </span>
          )}
        </label>

        <div className="mt-4 flex gap-3">
          <button
            type="submit"
            disabled={submitting}
            className="rounded bg-green-600 px-5 py-2 font-semibold text-white disabled:opacity-60"
          >
            {submitting ? "Submitting…" : "Submit Request"}
          </button>
          <button
            type="button"
            onClick={doLater}
            className="rounded border px-5 py-2 font-semibold"
          >
            Do Later
          </button>
        </div>
      </form>
    </div>
  );
}

===== FILE: sliptail-frontend\src\app\settings\page.tsx =====

"use client";

import { useEffect, useMemo, useState } from "react";

type Prefs = {
  notify_post: boolean;
  notify_membership_expiring: boolean;
  notify_purchase: boolean;
  notify_request_completed: boolean;
  notify_new_request: boolean;
  notify_product_sale: boolean;
};

export default function SettingsPage() {
  const [prefs, setPrefs] = useState<Prefs | null>(null);
  const [saving, setSaving] = useState(false);
  const apiBase = useMemo(() => (process.env.NEXT_PUBLIC_API_URL || "http://localhost:5000").replace(/\/$/, ""), []);

  useEffect(() => {
    (async () => {
      const res = await fetch(`${apiBase}/api/settings/notifications`, { credentials: "include" });
      const data = await res.json();
      setPrefs(data as Prefs);
    })();
  }, [apiBase]);

  async function save() {
    if (!prefs) return;
    setSaving(true);
    await fetch(`${apiBase}/api/settings/notifications`, {
      method: "PUT",
      credentials: "include",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(prefs),
    });
    setSaving(false);
  }

  if (!prefs) return <main className="max-w-3xl mx-auto p-4">Loading…</main>;

  return (
    <main className="max-w-3xl mx-auto p-4 space-y-6">
      <h1 className="text-2xl font-bold">Settings</h1>

      <section className="rounded-2xl border p-4">
        <h2 className="font-semibold mb-3">Notifications</h2>
        <div className="grid gap-2 text-sm">
          {Object.entries(prefs).map(([k, v]) => (
            <label key={k} className="inline-flex items-center gap-2">
              <input
                type="checkbox"
                checked={!!v}
                onChange={(e) => setPrefs((p) => ({ ...(p as Prefs), [k]: e.target.checked }))}
              />
              {k}
            </label>
          ))}
        </div>
        <button onClick={save} disabled={saving} className="mt-3 rounded-xl bg-black text-white py-2 px-4">
          {saving ? "Saving…" : "Save"}
        </button>
      </section>
    </main>
  );
}

===== FILE: sliptail-frontend\src\app\stripe-checkout\start\route.ts =====

// src/app/stripe-checkout/start/route.ts
import { NextRequest, NextResponse } from "next/server";

export const dynamic = "force-dynamic"; // avoid caching in app router

function abs(req: NextRequest, path: string) {
  return new URL(path, req.url).toString();
}

const API_BASE =
  process.env.NEXT_PUBLIC_API_URL?.replace(/\/$/, "") ||
  process.env.API_BASE_URL?.replace(/\/$/, "") ||
  "http://localhost:5000";

type Json = Record<string, unknown>;

function isRecord(v: unknown): v is Record<string, unknown> {
  return typeof v === "object" && v !== null;
}
function getString(obj: unknown, key: string): string | undefined {
  if (!isRecord(obj)) return undefined;
  const v = obj[key];
  return typeof v === "string" ? v : undefined;
}

/**
 * Usage:
 *   /stripe-checkout/start?pid=<productId>&action=purchase|membership|request
 *
 * Behavior:
 * - POST directly to backend to create a Stripe session (forwarding cookies).
 *   - If backend returns 401/403 ⇒ redirect to login (with ?next back here).
 *   - If backend returns { url } ⇒ 303 redirect to Stripe Checkout.
 *   - Else ⇒ redirect back to product page with an error message.
 */
export async function GET(req: NextRequest) {
  const { searchParams, pathname } = new URL(req.url);
  const pid = searchParams.get("pid");
  const actionRaw = (searchParams.get("action") || "").toLowerCase();
  const action = actionRaw || "purchase"; // treat missing as a purchase

  if (!pid) {
    return NextResponse.redirect(abs(req, "/"), { status: 302 });
  }

  // Build success/cancel URLs:
  // - Requests go to /checkout/success (so we can collect details)
  // - Purchases/Memberships go straight to /purchases (optionally with a toast flag)
  const origin = new URL(req.url).origin;

  const successUrl =
    action === "request"
      ? `${origin}/checkout/success?sid={CHECKOUT_SESSION_ID}&pid=${encodeURIComponent(
          pid
        )}&action=${encodeURIComponent(action)}`
      : `${origin}/purchases?flash=purchase_success&session_id={CHECKOUT_SESSION_ID}&pid=${encodeURIComponent(
          pid
        )}&action=${encodeURIComponent(action)}`;

  const cancelUrl = `${origin}/checkout/cancel?pid=${encodeURIComponent(pid)}&action=${encodeURIComponent(action)}`;

  // Build payload once
  const payload = JSON.stringify({
    product_id: pid,                   // expected by your backend
    productId: pid,                    // leniency for any older handlers
    action: action || undefined,       // optional echo
    mode: action === "membership" ? "subscription" : "payment",
    quantity: 1,
    success_url: successUrl,           // <— key change
    cancel_url: cancelUrl,             // <— unchanged behavior
  });

  // Forward cookies so cookie-based auth works server-to-server
  const headers = {
    "content-type": "application/json",
    cookie: req.headers.get("cookie") || "",
  };

  // Try your current route first, then fallbacks
  const endpoints = [
    `${API_BASE}/api/stripe-checkout/create-session`, // your implemented route
    `${API_BASE}/api/stripe-checkout/session`,
    `${API_BASE}/api/stripe-checkout/create`,
    `${API_BASE}/api/checkout/create-session`,
    `${API_BASE}/api/checkout/session`,
    `${API_BASE}/api/checkout/create`,
    `${API_BASE}/api/stripe/checkout/session`,
    `${API_BASE}/api/stripe/checkout/create-session`,
  ];

  let lastMsg = "";

  for (const url of endpoints) {
    try {
      const res = await fetch(url, {
        method: "POST",
        headers,
        body: payload,
        cache: "no-store",
      });

      // If not authenticated, send to login with next back to this URL
      if (res.status === 401 || res.status === 403) {
        const nextUrl = `${pathname}?${searchParams.toString()}`;
        const loginUrl = `/auth/login?next=${encodeURIComponent(nextUrl)}`;
        return NextResponse.redirect(abs(req, loginUrl), { status: 302 });
      }

      const ct = res.headers.get("content-type") || "";
      const data: Json | string | null = ct.includes("application/json")
        ? ((await res.json().catch(() => ({}))) as Json)
        : await res.text().catch(() => "");

      const maybeUrl = isRecord(data) ? getString(data, "url") : null;

      const msg =
        (isRecord(data) && (getString(data, "message") || getString(data, "error"))) ||
        (typeof data === "string" ? data : "") ||
        res.statusText;

      if (res.ok && maybeUrl) {
        // Support absolute or relative (rare) URLs
        const absolute =
          /^https?:\/\//i.test(maybeUrl)
            ? maybeUrl
            : `${API_BASE}${maybeUrl.startsWith("/") ? "" : "/"}${maybeUrl}`;
        return NextResponse.redirect(absolute, { status: 303 });
      } else {
        lastMsg = `(${res.status}) ${msg || "Unknown error"}`;
      }
    } catch {
      // try next endpoint
    }
  }

  // Fallback — send back to product page with the last error we saw
  const fallback = `/products/${encodeURIComponent(pid)}?error=${encodeURIComponent(
    lastMsg || "Could not start checkout"
  )}`;
  return NextResponse.redirect(abs(req, fallback), { status: 302 });
}


===== FILE: sliptail-frontend\src\app\support\page.tsx =====

export default function SupportPage() {
  return (
    <main className="mx-auto max-w-4xl px-6 py-12">
      <h1 className="mb-4 text-3xl font-bold">Support</h1>
      <p>For assistance, please contact support@sliptail.com.</p>
    </main>
  );
}


===== FILE: sliptail-frontend\src\components\auth\AuthProvider.tsx =====

"use client";

import React, {
  createContext,
  useContext,
  useEffect,
  useMemo,
  useState,
  useCallback,
  useRef,
} from "react";
import { api, setAuthToken } from "@/lib/api";
import { loadAuth, saveAuth, clearAuth, AuthState, SafeUser } from "@/lib/auth";
import axios from "axios";

type AuthContextType = {
  user: SafeUser | null;
  token: string | null;
  loading: boolean;
  login: (email: string, password: string) => Promise<void>;
  signup: (
    email: string,
    password: string,
    username?: string
  ) => Promise<"verify-sent">;
  logout: () => void;
};

const AuthContext = createContext<AuthContextType | null>(null);

// Shallow “meaningful” equality: same token and same user id (or both null)
function sameAuth(a: AuthState, b: AuthState) {
  const tEqual = a.token === b.token;
  const aId = a.user?.id ?? null;
  const bId = b.user?.id ?? null;
  return tEqual && aId === bId;
}

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [{ user, token }, setAuth] = useState<AuthState>({
    user: null,
    token: null,
  });
  const [loading, setLoading] = useState(true);

  // Track last applied state to avoid re-applying same thing.
  const lastAppliedRef = useRef<AuthState>({ user: null, token: null });

  const fetchMe = useCallback(async (): Promise<SafeUser> => {
    const { data } = await api.get<{ user: SafeUser }>("/auth/me");
    return data.user;
  }, []);

  /** Apply new auth state if it actually changed */
  const applyAuthState = useCallback((next: AuthState) => {
    if (sameAuth(next, lastAppliedRef.current)) {
      return; // nothing meaningful changed; skip writes & state updates
    }
    const tok = next.token ?? null;
    setAuthToken(tok);
    setAuth(next);
    saveAuth(next);
    lastAppliedRef.current = next;
  }, []);

  /** Clear auth everywhere */
  const clearAllAuth = useCallback(() => {
    clearAuth();
    try {
      localStorage.removeItem("token");
    } catch {
      /* no-op */
    }
    const cleared: AuthState = { user: null, token: null };
    setAuth(cleared);
    setAuthToken(null);
    lastAppliedRef.current = cleared;
  }, []);

  /**
   * Read from localStorage, attach token, fetch /auth/me if needed,
   * and normalize through applyAuthState — but only if changed.
   */
  const rehydrateFromLocal = useCallback(async () => {
    const stored = loadAuth();
    let tok = stored.token || null;

    // If a bare token was stashed by some flow, pick it up
    if (!tok) {
      const strayToken =
        typeof window !== "undefined"
          ? window.localStorage.getItem("token")
          : null;
      if (strayToken) tok = strayToken;
    }

    // If nothing to hydrate, clear and bail
    if (!tok) {
      clearAllAuth();
      return;
    }

    // If we already *have* token+user in storage, trust and apply (if different)
    if (stored.user) {
      const next: AuthState = { token: tok, user: stored.user };
      applyAuthState(next);
      return;
    }

    // Otherwise fetch /auth/me to populate user
    setAuthToken(tok);
    try {
      const me = await fetchMe();
      applyAuthState({ token: tok, user: me });
    } catch {
      // bad/expired token
      clearAllAuth();
    }
  }, [applyAuthState, clearAllAuth, fetchMe]);

  // Hydrate on mount; set up cross-tab sync via native storage event only
  useEffect(() => {
    let cancelled = false;

    (async () => {
      try {
        await rehydrateFromLocal();
      } finally {
        if (!cancelled) setLoading(false);
      }
    })();

    const onStorage = (e: StorageEvent) => {
      // storage events DO NOT fire in the same tab that wrote the storage.
      // So this safely picks up changes from *other* tabs.
      if (e.key === "auth" || e.key === "token") {
        void rehydrateFromLocal();
      }
    };

    window.addEventListener("storage", onStorage);
    return () => {
      cancelled = true;
      window.removeEventListener("storage", onStorage);
    };
  }, [rehydrateFromLocal]);

  // --- Actions ---

  const login = useCallback(
    async (email: string, password: string) => {
      setLoading(true);
      try {
        const { data } = await api.post<{ token: string; user: SafeUser }>(
          "/auth/login",
          { email, password }
        );
        applyAuthState({ token: data.token, user: data.user });
      } catch (e: unknown) {
        const message = axios.isAxiosError<{ error?: string }>(e)
          ? e.response?.data?.error ?? "Login failed"
          : "Login failed";
        throw new Error(message);
      } finally {
        setLoading(false);
      }
    },
    [applyAuthState]
  );

  const signup = useCallback(
    async (
      email: string,
      password: string,
      username?: string
    ): Promise<"verify-sent"> => {
      setLoading(true);
      try {
        const { data } = await api.post<{ checkEmail: boolean }>(
          "/auth/signup",
          { email, password, username }
        );
        if (data?.checkEmail) return "verify-sent";
        throw new Error("Signup failed");
      } catch (e: unknown) {
        const message = axios.isAxiosError<{ error?: string }>(e)
          ? e.response?.data?.error ?? "Signup failed"
          : "Signup failed";
        throw new Error(message);
      } finally {
        setLoading(false);
      }
    },
    []
  );

  const logout = useCallback(() => {
    clearAllAuth();
  }, [clearAllAuth]);

  const value = useMemo(
    () => ({ user, token, loading, login, signup, logout }),
    [user, token, loading, login, signup, logout]
  );

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth() {
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error("useAuth must be used within <AuthProvider>");
  return ctx;
}

===== FILE: sliptail-frontend\src\components\auth\Protected.tsx =====

"use client";

import { useAuth } from "@/components/auth/AuthProvider";
import { useRouter } from "next/navigation";
import { useEffect } from "react";

export default function Protected({ children }: { children: React.ReactNode }) {
  const { user, loading } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!loading && !user) router.replace("/login");
  }, [loading, user, router]);

  if (loading || !user) return <div className="p-6">Loading...</div>;
  return <>{children}</>;
}

===== FILE: sliptail-frontend\src\components\cart\CartProvider.tsx =====

"use client";
import React, { createContext, useContext, useEffect, useMemo, useState } from "react";
import { api } from "@/lib/api";


export type CartItem = {
productId: string;
quantity: number;
};


export type CartState = {
items: CartItem[];
};


const CART_KEY = "sliptail.cart";


const loadCart = (): CartState => {
if (typeof window === "undefined") return { items: [] };
try {
const raw = localStorage.getItem(CART_KEY);
return raw ? JSON.parse(raw) : { items: [] };
} catch {
return { items: [] };
}
};


const saveCart = (state: CartState) => {
try {
localStorage.setItem(CART_KEY, JSON.stringify(state));
} catch {}
};


export type CartContextType = {
items: CartItem[];
addItem: (item: CartItem) => Promise<void>;
removeItem: (productId: string) => void;
clear: () => void;
};


const CartContext = createContext<CartContextType | null>(null);


export function CartProvider({ children }: { children: React.ReactNode }) {
const [state, setState] = useState<CartState>({ items: [] });


useEffect(() => {
setState(loadCart());
}, []);


useEffect(() => {
if (typeof window !== "undefined") saveCart(state);
}, [state]);


async function addItem(item: CartItem) {
setState((s) => {
const existingIdx = s.items.findIndex((i) => i.productId === item.productId);
const next = { ...s, items: [...s.items] };
if (existingIdx >= 0) next.items[existingIdx].quantity += item.quantity;
else next.items.push(item);
return next;
});
try {
await api.post("/cart/add", item); // optional backend sync
} catch {}
}


function removeItem(productId: string) {
setState((s) => ({ items: s.items.filter((i) => i.productId !== productId) }));
}


function clear() {
setState({ items: [] });
}


const value = useMemo(() => ({ items: state.items, addItem, removeItem, clear }), [state.items]);


return <CartContext.Provider value={value}>{children}</CartContext.Provider>;
}


export function useCart() {
const ctx = useContext(CartContext);
if (!ctx) throw new Error("useCart must be used within <CartProvider>");
return ctx;
}

===== FILE: sliptail-frontend\src\components\CreatorCard.tsx =====

import Image from "next/image";
import Link from "next/link";

interface Creator {
  id: string;
  displayName: string;
  avatar: string;
  bio: string;
  rating: number;
  photos: string[];
}

export default function CreatorCard({ creator }: { creator: Creator }) {
  return (
    <div className="group relative h-80 w-64 [perspective:1000px]">
      <div className="relative h-full w-full transition-transform duration-500 [transform-style:preserve-3d] group-hover:[transform:rotateY(180deg)]">
        {/* front */}
        <div className="absolute inset-0 flex flex-col items-center rounded border bg-white p-4 [backface-visibility:hidden]">
          <Image
            src={creator.avatar}
            alt={creator.displayName}
            width={80}
            height={80}
            className="mb-2 rounded-full"
          />
          <h3 className="font-semibold">{creator.displayName}</h3>
          <p className="text-center text-sm text-gray-600">{creator.bio}</p>
          <div className="mt-2 flex items-center">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="currentColor"
              className="h-4 w-4 text-yellow-500"
            >
              <path d="M12 .587l3.668 7.431 8.2 1.193-5.934 5.787 1.402 8.168L12 18.896l-7.336 3.87 1.402-8.168L.132 9.211l8.2-1.193z" />
            </svg>
            <span className="ml-1 text-sm">{creator.rating.toFixed(1)}</span>
          </div>
        </div>
        {/* back */}
        <div className="absolute inset-0 grid grid-cols-2 gap-1 rounded border bg-white p-2 [transform:rotateY(180deg)] [backface-visibility:hidden]">
          {creator.photos.slice(0, 4).map((src, i) => (
            <Image
              key={i}
              src={src}
              alt=""
              width={120}
              height={120}
              className="h-full w-full object-cover"
            />
          ))}
          <Link
            href={`/creators/${creator.id}`}
            className="col-span-2 mt-1 rounded bg-blue-600 py-1 text-center text-white"
          >
            View Profile
          </Link>
        </div>
      </div>
    </div>
  );
}


===== FILE: sliptail-frontend\src\components\Footer.tsx =====

import Link from "next/link";

export default function Footer() {
  return (
    <footer className="mt-auto bg-gray-100 py-8">
      <div className="mx-auto flex max-w-6xl flex-col items-center justify-between gap-4 px-6 sm:flex-row">
        <div className="flex gap-4">
          <Link href="/support" className="text-sm text-gray-600 hover:text-gray-800">
            Support
          </Link>
          <Link href="/about" className="text-sm text-gray-600 hover:text-gray-800">
            About
          </Link>
        </div>
        <div className="flex gap-4">
          <a
            href="https://www.instagram.com/sliptail_/"
            target="_blank"
            rel="noopener noreferrer"
            aria-label="Instagram"
            className="text-gray-600 hover:text-gray-800"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="currentColor"
              className="h-6 w-6"
            >
              <path d="M12.001 2.163c3.204 0 3.584.012 4.85.07 1.366.062 2.633.334 3.608 1.31.975.975 1.248 2.241 1.31 3.608.058 1.266.069 1.651.069 4.851 0 3.2-.012 3.584-.069 4.85-.062 1.367-.334 2.633-1.31 3.608-.975.975-2.241 1.248-3.608 1.31-1.266.058-1.651.069-4.85.069-3.204 0-3.584-.012-4.851-.069-1.366-.062-2.633-.334-3.608-1.31-.975-.975-1.248-2.241-1.31-3.608C2.175 15.784 2.163 15.399 2.163 12c0-3.2.012-3.584.069-4.851.062-1.366.334-2.633 1.31-3.608.975-.975 2.241-1.248 3.608-1.31 1.266-.058 1.651-.069 4.851-.069zm0 1.837c-3.157 0-3.523.012-4.762.069-.997.046-1.538.213-1.897.356-.477.185-.82.406-1.18.766-.36.36-.581.703-.766 1.18-.142.359-.309.9-.356 1.897-.057 1.239-.069 1.605-.069 4.762 0 3.157.012 3.523.069 4.762.046.997.213 1.538.356 1.897.185.477.406.82.766 1.18.36.36.703.581 1.18.766.359.142.9.309 1.897.356 1.239.057 1.605.069 4.762.069 3.157 0 3.523-.012 4.762-.069.997-.046 1.538-.213 1.897-.356.477-.185.82-.406 1.18-.766.36-.36.581-.703.766-1.18.142-.359.309-.9.356-1.897.057-1.239.069-1.605.069-4.762 0-3.157-.012-3.523-.069-4.762-.046-.997-.213-1.538-.356-1.897-.185-.477-.406-.82-.766-1.18-.36-.36-.703-.581-1.18-.766-.359-.142-.9-.309-1.897-.356-1.239-.057-1.605-.069-4.762-.069zm0 3.905a5.944 5.944 0 110 11.887 5.944 5.944 0 010-11.887zm0 9.809a3.865 3.865 0 100-7.73 3.865 3.865 0 000 7.73zm5.844-10.98a1.386 1.386 0 11-2.772 0 1.386 1.386 0 012.772 0z" />
            </svg>
          </a>
          <a
            href="https://x.com/Sliptail_"
            target="_blank"
            rel="noopener noreferrer"
            aria-label="Twitter"
            className="text-gray-600 hover:text-gray-800"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="currentColor"
              className="h-6 w-6"
            >
              <path d="M23.954 4.569c-.885.392-1.83.656-2.825.775 1.014-.609 1.794-1.574 2.163-2.724-.951.564-2.005.974-3.127 1.195-.897-.959-2.178-1.559-3.594-1.559-2.717 0-4.92 2.203-4.92 4.917 0 .39.045.765.127 1.124-4.09-.205-7.72-2.165-10.148-5.144-.424.729-.666 1.562-.666 2.475 0 1.71.87 3.213 2.188 4.096-.807-.026-1.566-.248-2.229-.616v.06c0 2.385 1.693 4.374 3.946 4.827-.413.111-.849.171-1.296.171-.314 0-.615-.03-.916-.086.631 1.953 2.445 3.377 4.6 3.418-1.68 1.316-3.809 2.101-6.115 2.101-.398 0-.79-.023-1.17-.067 2.179 1.396 4.768 2.209 7.557 2.209 9.054 0 14-7.496 14-13.986 0-.21 0-.42-.015-.63.961-.69 1.8-1.56 2.46-2.548l-.047-.02z" />
            </svg>
          </a>
          <a
            href="https://www.tiktok.com/@sliptail_"
            target="_blank"
            rel="noopener noreferrer"
            aria-label="TikTok"
            className="text-gray-600 hover:text-gray-800"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="currentColor"
              className="h-6 w-6"
            >
              <path d="M12.5 0c.3 2 2 3.6 4 3.8v1.9c-1-.1-2-.4-3-.9v7.4c0 4.3-3.5 7.8-7.8 7.8-1.6 0-3.2-.5-4.4-1.4 1.4 1.4 3.3 2.3 5.4 2.3 4.3 0 7.8-3.4 7.8-7.7V5.3c1.3.7 2.7 1.1 4.3 1.1V4.6c-.7 0-2.1-.3-3.1-.9-.8-.2-1.6-.6-2.3-1.1a8 8 0 012.3 6.2v7.1c0 6.4-5.1 11.5-11.5 11.5C2.9 27.4-2 22.2-2 15.9c0-3.1 1.1-5.99 3.1-8.16C3.1 5.1 4.9 4.28 6.9 4.19v8.04c-1.2-.73-2-2.06-2-3.56V2.1c0-1.1.5-2.1 1.3-2.76A8 8 0 004.68.024v1.9c-.22-.055-.43-.096-.65-.122v1.88c2.1.14 3.8 1.81 4.1 3.94z" />
            </svg>
          </a>
        </div>
      </div>
    </footer>
  );
}



===== FILE: sliptail-frontend\src\components\forms\PasswordField.tsx =====

"use client";
import { useState, InputHTMLAttributes, forwardRef } from "react";

type Props = Omit<InputHTMLAttributes<HTMLInputElement>, "type"> & {
  label?: string;
  error?: string;
};

const Eye = ({ className = "h-5 w-5" }) => (
  <svg viewBox="0 0 24 24" className={className} aria-hidden="true">
    <path
      d="M1.5 12S5 4.5 12 4.5 22.5 12 22.5 12 19 19.5 12 19.5 1.5 12 1.5 12Z"
      fill="none" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round"
    />
    <circle cx="12" cy="12" r="3.5" fill="none" stroke="currentColor" strokeWidth="1.8" />
  </svg>
);

const EyeOff = ({ className = "h-5 w-5" }) => (
  <svg viewBox="0 0 24 24" className={className} aria-hidden="true">
    <path d="M3 3l18 18" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round"/>
    <path
      d="M4.5 7.5S7.5 4.5 12 4.5c4.5 0 7.5 3 7.5 3s1.5 1.5 3 4.5c-1.5 3-3 4.5-3 4.5s-3 3-7.5 3c-4.5 0-7.5-3-7.5-3S3 12 1.5 12"
      fill="none" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round"
    />
  </svg>
);

const PasswordField = forwardRef<HTMLInputElement, Props>(
  ({ label = "Password", error, className = "", id, ...rest }, ref) => {
    const [visible, setVisible] = useState(false);
    const inputId = id || "password";

    return (
      <div className="w-full">
        <label htmlFor={inputId} className="block text-xs font-medium text-neutral-700">
          {label}
        </label>
        <div className="mt-1 relative">
          <input
            id={inputId}
            ref={ref}
            type={visible ? "text" : "password"}
            className={`w-full rounded-xl border px-3 py-2 pr-10 focus:outline-none focus:ring-2 focus:ring-black/20 ${className}`}
            autoComplete="current-password"
            {...rest}
          />
          <button
            type="button"
            onClick={() => setVisible((v) => !v)}
            className="absolute inset-y-0 right-0 px-3 flex items-center text-neutral-500 hover:text-neutral-800"
            aria-label={visible ? "Hide password" : "Show password"}
            title={visible ? "Hide password" : "Show password"}
          >
            {visible ? <EyeOff /> : <Eye />}
          </button>
        </div>
        {error && <p className="mt-1 text-xs text-red-600">{error}</p>}
      </div>
    );
  }
);

PasswordField.displayName = "PasswordField";
export default PasswordField;


===== FILE: sliptail-frontend\src\components\Navbar.tsx =====

"use client";

import Image from "next/image";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { useEffect, useRef, useState } from "react";
import useSWR, { mutate } from "swr";
import { setAuthToken } from "@/lib/api";
import { saveAuth, loadAuth } from "@/lib/auth";
import { useCreatorStatus } from "@/hooks/useCreatorStatus";

/* ----------------------------- Types ----------------------------- */

interface AuthUser {
  id: number;
  email: string;
  role: "user" | "creator" | "admin" | (string & {});
  email_verified_at?: string | null;
}

/* --------------------------- Fetcher --------------------------- */

const fetcher = async <T,>(url: string): Promise<T> => {
  let token: string | null = null;
  try {
    token = typeof loadAuth === "function" ? loadAuth()?.token ?? null : null;
  } catch {
    token = null;
  }

  const headers: Record<string, string> = {};
  if (token) headers.Authorization = `Bearer ${token}`;

  const res = await fetch(url, { credentials: "include", headers });
  if (!res.ok) throw new Error(String(res.status));
  return (await res.json()) as T;
};

/* ---------------------------- Component --------------------------- */

export default function Navbar() {
  const router = useRouter();

  // Auth (server truth)
  const { data: user, error: meErr } = useSWR<AuthUser>("/api/auth/me", fetcher);

  // Creator status via your hook
  const { isCreator } = useCreatorStatus();

  const [menuOpen, setMenuOpen] = useState(false);
  const [confirmOpen, setConfirmOpen] = useState(false);
  const menuRef = useRef<HTMLDivElement>(null);

  // Close menu on outside click
  useEffect(() => {
    function onDocClick(e: MouseEvent) {
      if (!menuRef.current) return;
      if (!menuRef.current.contains(e.target as Node)) setMenuOpen(false);
    }
    if (menuOpen) document.addEventListener("mousedown", onDocClick);
    return () => document.removeEventListener("mousedown", onDocClick);
  }, [menuOpen]);

  // If /api/auth/me 401s, clear any local token to avoid “phantom login”
  useEffect(() => {
    if (!meErr) return;
    try {
      const stored = typeof loadAuth === "function" ? loadAuth() : undefined;
      if (stored?.token) {
        saveAuth({ token: null, user: null });
        setAuthToken(null);
      }
    } catch {
      /* no-op */
    }
  }, [meErr]);

  function go(path: string) {
    setMenuOpen(false);
    router.push(path);
  }

  async function logout() {
    try {
      await fetch("/api/auth/logout", { method: "POST", credentials: "include" });
    } catch {
      /* ignore transport errors; we’ll still clear client state */
    }

    // Clear client auth surfaces
    try {
      saveAuth({ token: null, user: null });
      setAuthToken(null);
      if (typeof window !== "undefined") {
        localStorage.removeItem("creatorSetupDone");
        // Broadcast to other tabs
        localStorage.setItem("auth:logout", String(Date.now()));
      }
    } catch {
      /* noop */
    }

    // Nuke SWR caches so no page shows stale auth
    await mutate(() => true, undefined, { revalidate: false });

    // Make sure menus close quickly
    setMenuOpen(false);

    // Hard navigate home to fully reset (also triggers server components to refetch)
    // router.replace + refresh covers App Router, location.replace is a final safety.
    router.replace("/");
    router.refresh();
    if (typeof window !== "undefined") {
      // Safety: ensure no stale caches keep UI around (especially on static home)
      window.location.replace("/");
    }
  }

  return (
    <header className="sticky top-0 z-40 w-full border-b bg-white/70 backdrop-blur">
      <div className="mx-auto flex max-w-6xl items-center justify-between px-4 py-3">
        {/* Left: Logo */}
        <div className="flex items-center gap-3">
          <Link href="/" className="flex items-center gap-3" aria-label="Home">
            <Image src="/sliptail-logofull.png" alt="Sliptail" width={130} height={40} />
          </Link>
        </div>

        {/* Center: (empty—removed Creators & Creator Dashboard) */}
        <nav className="hidden md:flex" aria-hidden />

        {/* Right: auth area */}
        {!user ? (
          <div className="flex items-center gap-2">
            <Link
              href="/auth/login"
              className="rounded-2xl border px-4 py-2 text-sm font-semibold hover:bg-neutral-100"
            >
              Sign in
            </Link>
            <Link
              href="/auth/signup?next=%2Fcreator%2Fsetup"
              className="rounded-2xl bg-black px-4 py-2 text-sm font-semibold text-white hover:bg-black/90"
            >
              Become a creator
            </Link>
          </div>
        ) : (
          <div className="relative" ref={menuRef}>
            <button
              aria-label="Open menu"
              onClick={() => setMenuOpen((v) => !v)}
              className="inline-flex h-10 w-10 items-center justify-center rounded-full border hover:bg-neutral-50"
            >
              <svg width="20" height="20" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M3 6h18M3 12h18M3 18h18" stroke="currentColor" strokeWidth="2" strokeLinecap="round" />
              </svg>
            </button>

            {menuOpen && (
              <div className="absolute right-0 mt-2 w-60 rounded-2xl border bg-white p-1 shadow-lg">
                {isCreator ? (
                  <>
                    <MenuItem onClick={() => go("/dashboard")}>Creator Dashboard</MenuItem>
                    <MenuItem onClick={() => go("/purchases")}>My Purchases</MenuItem>
                    <MenuItem onClick={() => go("/notifications")}>Notifications</MenuItem>
                    <MenuItem onClick={() => go("/settings")}>Settings</MenuItem>
                    <MenuItem onClick={logout}>Log out</MenuItem>
                  </>
                ) : (
                  <>
                    <MenuItem onClick={() => go("/purchases")}>My Purchases</MenuItem>
                    <MenuItem onClick={() => go("/notifications")}>Notifications</MenuItem>
                    <MenuItem onClick={() => go("/settings")}>Settings</MenuItem>
                    <MenuItem onClick={() => go("/creator/setup")}>Become a Creator</MenuItem>
                    <MenuItem onClick={logout}>Log out</MenuItem>
                  </>
                )}
              </div>
            )}
          </div>
        )}
      </div>

      {/* Optional confirmation modal – routes to setup */}
      {confirmOpen && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/40 p-4">
          <div className="w-full max-w-md space-y-4 rounded-2xl bg-white p-5">
            <h3 className="text-lg font-semibold">Ready to start Creating?</h3>
            <p className="text-sm text-neutral-700">
              We’ll guide you through profile, Stripe, and your first product.
            </p>
            <div className="flex items-center justify-end gap-2">
              <button
                onClick={() => setConfirmOpen(false)}
                className="rounded-xl border px-4 py-2 text-sm"
              >
                No
              </button>
              <button
                onClick={() => {
                  setConfirmOpen(false);
                  router.push("/creator/setup");
                }}
                className="rounded-xl bg-black px-4 py-2 text-sm text-white"
              >
                Yes
              </button>
            </div>
          </div>
        </div>
      )}
    </header>
  );
}

/* ----------------------------- Subcomponents ---------------------------- */

function MenuItem({
  children,
  onClick,
}: {
  children: React.ReactNode;
  onClick: () => void;
}) {
  return (
    <button
      onClick={onClick}
      className="w-full rounded-xl px-3 py-2 text-left text-sm hover:bg-neutral-100"
    >
      {children}
    </button>
  );
}


===== FILE: sliptail-frontend\src\components\products\ProductCard.tsx =====

"use client";
import Link from "next/link";
import { Product } from "@/types/products";
import { formatUSD } from "@/lib/format";


export default function ProductCard({ product }: { product: Product }) {
const label =
product.productType === "purchase"
? "Digital Download"
: product.productType === "membership"
? "Membership"
: "Custom Request";


return (
<div className="group flex flex-col overflow-hidden rounded-2xl border shadow-sm">
<Link href={`/products/${product.id}`} className="aspect-[4/3] w-full overflow-hidden">
{product.thumbnailUrl ? (
<img
src={product.thumbnailUrl}
alt={product.title}
className="h-full w-full object-cover transition group-hover:scale-[1.02]"
/>
) : (
<div className="flex h-full w-full items-center justify-center bg-neutral-100">No image</div>
)}
</Link>
<div className="flex flex-1 flex-col gap-2 p-4">
<div className="flex items-center justify-between">
<div className="text-xs text-neutral-600">{label}</div>
<span className="text-sm font-semibold">{formatUSD(product.price)}</span>
</div>
<div className="text-base font-semibold leading-tight line-clamp-2">{product.title}</div>
<div className="mt-auto flex items-center justify-between">
<div className="text-xs text-neutral-600 line-clamp-2">{product.description}</div>
<Link href={`/products/${product.id}`} className="rounded-2xl border px-3 py-1.5 text-sm hover:bg-neutral-100">
{product.productType === "membership" ? "Join" : "View"}
</Link>
</div>
</div>
</div>
);
}

===== FILE: sliptail-frontend\src\components\StartSellingButton.tsx =====

// sliptail-frontend/src/components/StartSellingButton.tsx
"use client";

import { useMemo, useState } from "react";
import { useRouter } from "next/navigation";
import { useAuth } from "@/components/auth/AuthProvider";

// If you have a helper that returns your API base, use it; otherwise inline "" for same-origin.
function toApiBase() { return ""; }

export default function StartSellingButton({
  className,
  children,
}: {
  className?: string;
  children: React.ReactNode;
}) {
  const router = useRouter();
  const { user } = useAuth?.() ?? { user: null };
  const apiBase = useMemo(() => toApiBase(), []);
  const [busy, setBusy] = useState(false);

  async function handleClick() {
    if (busy) return;

    // 1) Not logged in → signup
    if (!user) {
      router.push("/auth/signup");
      return;
    }

    setBusy(true);
    try {
      // 2) Check readiness
      const res = await fetch(`${apiBase}/api/me/creator-status`, {
        method: "GET",
        credentials: "include",
        headers: { "Cache-Control": "no-store" },
      });

      if (!res.ok) {
        // On any error, fall back to setup (safe)
        router.push("/creator/setup");
        return;
      }

      const j: {
        profileComplete: boolean;
        stripeConnected: boolean;
        hasPublishedProduct: boolean;
        isActive: boolean;
      } = await res.json();

      if (j.isActive) {
        router.push("/dashboard"); // your creator dashboard route
      } else {
        router.push("/creator/setup");
      }
    } finally {
      setBusy(false);
    }
  }

  return (
    <button
      type="button"
      onClick={handleClick}
      className={className}
      aria-disabled={busy}
    >
      {children}
    </button>
  );
}


===== FILE: sliptail-frontend\src\components\Toast.tsx =====

"use client";
import { useEffect, useState } from "react";
import { consumeFlash, FlashPayload } from "@/lib/flash";

export default function Toast() {
  const [flash, setFlash] = useState<FlashPayload | null>(null);

  useEffect(() => {
    const f = consumeFlash();
    if (f) setFlash(f);
  }, []);

  useEffect(() => {
    if (!flash) return;
    const t = setTimeout(() => setFlash(null), 3500);
    return () => clearTimeout(t);
  }, [flash]);

  if (!flash) return null;

  const isSuccess = flash.kind === "success";
  return (
    <div className="pointer-events-none fixed inset-x-0 top-4 z-[100] flex justify-center px-4">
      <div
        role="status"
        className={`pointer-events-auto max-w-xl w-full rounded-xl border shadow-lg backdrop-blur px-5 py-4 flex gap-4 items-start ${
          isSuccess
            ? "border-green-500/30 bg-white/95"
            : "border-neutral-300 bg-white/95"
        }`}
      >
        <div
          className={`mt-0.5 flex h-9 w-9 items-center justify-center rounded-full text-2xl ${
            isSuccess ? "bg-green-500 text-white" : "bg-neutral-200"
          }`}
          aria-hidden="true"
        >
          {isSuccess ? "✔" : "ℹ"}
        </div>
        <div className="flex-1 min-w-0">
          <div className="font-semibold leading-snug text-sm md:text-base truncate">
            {flash.title}
          </div>
          {flash.message ? (
            <div className="text-xs md:text-sm text-neutral-600 mt-1 line-clamp-3">
              {flash.message}
            </div>
          ) : null}
        </div>
      </div>
    </div>
  );
}


===== FILE: sliptail-frontend\src\hooks\useCreatorStatus.ts =====

"use client";

import { useEffect, useState } from "react";
import { useAuth } from "@/components/auth/AuthProvider";

/**
 * Returns { isCreator, loading }.
 * Keeps the existing flow: 200 from /api/creators/:id => true, 404 => false.
 * Adds:
 *  - Optimistic local flag (creatorSetupDone) so the nav updates immediately after setup.
 *  - Optional check to /api/creator/status (if implemented); otherwise ignored.
 */
export function useCreatorStatus() {
  const { user } = useAuth();

  // Optimistic initial state (so nav updates immediately after setup success)
  const [isCreator, setIsCreator] = useState(() => {
    if (typeof window !== "undefined") {
      return localStorage.getItem("creatorSetupDone") === "true";
    }
    return false;
  });
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    let abort = false;

    async function check() {
      if (!user?.id) {
        if (!abort) {
          setIsCreator(false);
          setLoading(false);
        }
        return;
      }

      setLoading(true);

      // 1) OPTIONAL: Try a lightweight status endpoint if you mounted it.
      //    If it doesn't exist or errors, we silently fall back to the legacy check.
      try {
        const res = await fetch("/api/creator/status", { credentials: "include" });
        if (!abort && res.ok) {
          const data = await res.json().catch(() => ({}));
          const active = Boolean(data && data.active);
          if (active) {
            setIsCreator(true);
            try { localStorage.setItem("creatorSetupDone", "true"); } catch {}
          }
          // If not active, don't force false yet—do the legacy check next.
        }
      } catch {
        // ignore; we'll do the legacy check below
      }

      // 2) LEGACY (original) flow: public creator profile check
      try {
        const res = await fetch(`/api/creators/${user.id}`, {
          method: "GET",
          credentials: "include",
        });
        if (abort) return;

        if (res.ok) {
          setIsCreator(true);
          try { localStorage.setItem("creatorSetupDone", "true"); } catch {}
        } else if (res.status === 404) {
          setIsCreator(false);
          try { localStorage.removeItem("creatorSetupDone"); } catch {}
        } else {
          // transient error: keep previous value; don't crash UI
        }
      } catch {
        if (!abort) {
          // network error — keep whatever we had (optimistic or previous)
        }
      } finally {
        if (!abort) setLoading(false);
      }
    }

    check();
    return () => { abort = true; };
  }, [user?.id]);

  return { isCreator, loading };
}

===== FILE: sliptail-frontend\src\lib\api.ts =====

import axios from "axios";

export const API_BASE =
  process.env.NEXT_PUBLIC_API_URL?.replace(/\/$/, "") || "http://localhost:5000";

// ---------- SSR-friendly fetch helper ----------
export type HttpMethod = "GET" | "POST" | "PUT" | "PATCH" | "DELETE";

export async function fetchApi<T>(
  path: string,
  options: {
    method?: HttpMethod;
    body?: unknown;
    token?: string | null;
    headers?: Record<string, string>;
    cache?: RequestCache;
    next?: { revalidate?: number | false };
    signal?: AbortSignal;
  } = {}
): Promise<T> {
  const url =
    path.startsWith("http")
      ? path
      : `${API_BASE}${path.startsWith("/") ? path : `/${path}`}`;

  const headers = new Headers(options.headers);
  headers.set("Accept", "application/json");

  // Only set JSON content-type if we're not sending FormData
  const isForm =
    typeof FormData !== "undefined" && options.body instanceof FormData;
  if (!isForm && options.body !== undefined) {
    headers.set("Content-Type", "application/json");
  }
  if (options.token) headers.set("Authorization", `Bearer ${options.token}`);

  const res = await fetch(url, {
    method: options.method || "GET",
    credentials: "include", // send cookies for auth
    headers,
    body: isForm
      ? (options.body as BodyInit)
      : options.body !== undefined
      ? JSON.stringify(options.body)
      : undefined,
    cache: options.cache,
    next: options.next,
    signal: options.signal,
  });

  if (!res.ok) {
    // Try to extract a meaningful error message
    let msg = `${res.status} ${res.statusText}`;
    try {
      const ct = res.headers.get("content-type") || "";
      if (ct.includes("application/json")) {
        const j = await res.json();
        if (j?.error && typeof j.error === "string") msg = j.error;
        else if (typeof j === "string") msg = j;
      } else {
        const t = await res.text();
        if (t) msg = t;
      }
    } catch {
      // ignore parse errors; fall back to default msg
    }
    if (res.status === 401) msg = "Unauthorized (no token)";
    throw new Error(msg);
  }

  // Some endpoints may return 204 No Content
  if (res.status === 204) return undefined as unknown as T;

  const ct = res.headers.get("content-type") || "";
  if (ct.includes("application/json")) {
    return (await res.json()) as T;
  }
  // Fallback: text
  return (await res.text()) as unknown as T;
}

// ---------- Axios client (for Client Components) ----------
export const api = axios.create({
  baseURL: `${API_BASE}/api`,
  withCredentials: true, // send cookies with requests
  headers: {
    Accept: "application/json",
  },
});

// Optional: call this after login/logout to keep auth header in sync
export function setAuthToken(token: string | null) {
  if (token) {
    api.defaults.headers.common["Authorization"] = `Bearer ${token}`;
  } else {
    delete api.defaults.headers.common["Authorization"];
  }
}

// Small helpers if you like Axios ergonomics
export async function apiGet<T>(url: string, config?: Parameters<typeof api.get>[1]) {
  const res = await api.get<T>(url, config);
  return res.data;
}
export async function apiPost<T>(url: string, data?: unknown, config?: Parameters<typeof api.post>[2]) {
  const res = await api.post<T>(url, data, config);
  return res.data;
}
export async function apiPut<T>(url: string, data?: unknown, config?: Parameters<typeof api.put>[2]) {
  const res = await api.put<T>(url, data, config);
  return res.data;
}
export async function apiPatch<T>(url: string, data?: unknown, config?: Parameters<typeof api.patch>[2]) {
  const res = await api.patch<T>(url, data, config);
  return res.data;
}
export async function apiDelete<T>(url: string, config?: Parameters<typeof api.delete>[1]) {
  const res = await api.delete<T>(url, config);
  return res.data;
}

===== FILE: sliptail-frontend\src\lib\auth.ts =====

export type SafeUser = {
  id: number;
  email: string;
  username: string | null;
  role: "user" | "creator" | "admin";
  email_verified_at: string | null;
  created_at: string;
};

export type AuthState = {
  token: string | null;
  user: SafeUser | null;
};

export type LoginResponse = { token: string; user: SafeUser };

// Canonical key
const KEY = "auth";

// Legacy keys we’ll migrate from
const LEGACY_KEY = "sliptail.auth";
const LEGACY_TOKEN_KEY = "token";

/** Safely parse JSON and return undefined on failure */
function safeParse<T>(raw: string | null): T | undefined {
  if (!raw) return undefined;
  try {
    return JSON.parse(raw) as T;
  } catch {
    return undefined;
  }
}

/** Normalize unknown object into AuthState */
function normalize(input: unknown): AuthState {
  if (typeof input === "object" && input !== null) {
    const maybe = input as Record<string, unknown>;
    const token = typeof maybe.token === "string" ? maybe.token : null;
    const user =
      typeof maybe.user === "object" && maybe.user !== null
        ? (maybe.user as SafeUser)
        : null;
    return { token, user };
  }
  return { token: null, user: null };
}

/** Read {token,user} from localStorage (with migration) */
export function loadAuth(): AuthState {
  if (typeof window === "undefined" || !("localStorage" in window)) {
    return { token: null, user: null };
  }

  // 1) Canonical key
  const current = safeParse<AuthState>(localStorage.getItem(KEY));
  if (current) return normalize(current);

  // 2) Legacy object
  const legacy = safeParse<AuthState>(localStorage.getItem(LEGACY_KEY));
  if (legacy) {
    const normalized = normalize(legacy);
    try {
      localStorage.setItem(KEY, JSON.stringify(normalized));
      localStorage.removeItem(LEGACY_KEY);
    } catch {
      /* no-op */
    }
    return normalized;
  }

  // 3) Stray token
  const strayToken = localStorage.getItem(LEGACY_TOKEN_KEY);
  if (strayToken && strayToken.trim()) {
    const migrated: AuthState = { token: strayToken, user: null };
    try {
      localStorage.setItem(KEY, JSON.stringify(migrated));
      localStorage.removeItem(LEGACY_TOKEN_KEY);
    } catch {
      /* no-op */
    }
    return migrated;
  }

  return { token: null, user: null };
}

/** Persist {token,user} */
export function saveAuth(state: AuthState): void {
  if (typeof window === "undefined" || !("localStorage" in window)) return;
  const normalized = normalize(state);
  try {
    localStorage.setItem(KEY, JSON.stringify(normalized));
  } catch {
    /* no-op */
  }
}

/** Clear all keys */
export function clearAuth(): void {
  if (typeof window === "undefined" || !("localStorage" in window)) return;
  try {
    localStorage.removeItem(KEY);
    localStorage.removeItem(LEGACY_KEY);
    localStorage.removeItem(LEGACY_TOKEN_KEY);
  } catch {
    /* no-op */
  }
}

===== FILE: sliptail-frontend\src\lib\currency.ts =====

export const money = (cents: number) => `$${(Number(cents || 0) / 100).toFixed(2)}`

===== FILE: sliptail-frontend\src\lib\flash.ts =====

export type FlashKind = "success" | "error" | "info";
export interface FlashPayload {
  kind: FlashKind;
  title: string;
  message?: string;
  ts: number;
}

const KEY = "sliptail_flash";

export function setFlash(payload: FlashPayload) {
  if (typeof window === "undefined") return;
  localStorage.setItem(KEY, JSON.stringify(payload));
}

export function consumeFlash(): FlashPayload | null {
  if (typeof window === "undefined") return null;
  const raw = localStorage.getItem(KEY);
  if (!raw) return null;
  localStorage.removeItem(KEY);
  try {
    const parsed = JSON.parse(raw) as FlashPayload;
    // ignore stale flashes (> 2 minutes)
    if (Date.now() - (parsed.ts ?? 0) > 2 * 60 * 1000) return null;
    return parsed;
  } catch {
    return null;
  }
}

===== FILE: sliptail-frontend\src\lib\format.ts =====

export const formatUSD = (cents: number) =>
(cents / 100).toLocaleString("en-US", { style: "currency", currency: "USD" });

===== FILE: sliptail-frontend\src\lib\types.ts =====

export type Role = "user" | "creator" | "admin";

export interface SafeUser {
  id: number;
  email: string;
  username: string | null;
  role: Role;
  email_verified_at: string | null;
  created_at: string;
}

===== FILE: sliptail-frontend\src\types\index.ts =====

export type Category = 'Music' | 'Art' | 'Fitness' | 'Gaming' | 'Education' | 'Cooking' | 'Other'
export type ProductType = 'purchase' | 'request' | 'membership'

export interface Product {
  id: string
  title: string
  description?: string
  price: number            // cents (DB column is named "price")
  product_type: ProductType
  fileUrl?: string         // for purchases (digital download)
}

export interface Review {
  id: string
  authorDisplay: string
  rating: number           // 1-5
  text?: string
  createdAt: string
}

export interface Creator {
  id: string
  displayName: string
  bio: string
  avatarUrl: string
  categories: Category[]
  rating: number
  images4: string[]        // back of card & profile gallery
  products: Product[]
  reviews: Review[]
}

export interface RequestItem {
  id: string
  buyerDisplay: string
  note?: string
  fileUrl?: string
  status: 'pending' | 'completed'
}

export interface MembershipPost {
  id: string
  creatorId: string
  createdAt: string
  mediaUrl?: string
  text?: string
}

===== FILE: sliptail-frontend\src\types\products.ts =====

export type ProductType = "purchase" | "membership" | "request";


export type Product = {
id: string;
creatorId: string;
title: string;
description?: string;
price: number; // used for all product types (including memberships)
productType: ProductType;
thumbnailUrl?: string;
};


export type Creator = {
id: string;
name: string;
avatarUrl?: string;
};

===== FILE: sliptail-frontend\tsconfig.json =====

{
  "compilerOptions": {
    "target": "es2021",
    "lib": [
      "dom",
      "dom.iterable",
       "es2021"
    ],
    "allowJs": false,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "src/*"
      ]
    },
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
